{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Point Cloud Utils is an easy-to-use Python library for processing and manipulating 3D point clouds and meshes. Installation pip install point-cloud-utils A very simple example Point Cloud Utils uses numpy arrays as fundamental data structure, making it very easy to integrate with existing numerical code. For example, here's how to remove all points in a point cloud which are greater than some distance from a mesh. import point_cloud_utils as pcu # Load a mesh stored in my_mesh.ply: # v is a NumPy array of coordinates with shape (V, 3) # f is a NumPy array of face indices with shape (F, 3) v, f = pcu.load_mesh_vf(\"my_mesh.ply\") # Load a point cloud stored in my_point_cloud.ply: # p is a NumPy array of point coordinates with shape (P, 3) p = pcu.load_mesh_v(\"my_point_cloud.ply\") # Compute the shortest distance between each point in p and the mesh: # dists is a NumPy array of shape (P,) where dists[i] is the # shortest distnace between the point p[i, :] and the mesh (v, f) dists, _, _ = pcu.closest_points_on_mesh(p, v, f) # Delete all points which are farther than some distance away from the mesh dist_thresh = 0.1 keep_points = p[dists < dist_thresh] # Save the filtered point cloud to my_point_cloud_trimmed.ply pcu.save_mesh_v(\"my_point_cloud_trimmed.ply\", keep_points) Core Features Point Cloud Utils includes utilities to perform the following tasks: Reading and writing meshes and point clouds from disk . Point Cloud Utils can handle any file that can be opened in MeshLab. Resampling point clouds to have different distributions. Generating point samples on a mesh . Computing metrics between point clouds and meshes (e.g. Chamfer Distance, Hausdorff Distance, etc...). Making a Mesh a Watertight Manifold . Computing signed distances to triangle meshes . Estimating normals for point clouds . Computing normals for triangle meshes . Fast ray/mesh intersection . Surface mesh smoothing . API Reference All available functions and classes are listed in the API reference","title":"Home"},{"location":"#installation","text":"pip install point-cloud-utils","title":"Installation"},{"location":"#a-very-simple-example","text":"Point Cloud Utils uses numpy arrays as fundamental data structure, making it very easy to integrate with existing numerical code. For example, here's how to remove all points in a point cloud which are greater than some distance from a mesh. import point_cloud_utils as pcu # Load a mesh stored in my_mesh.ply: # v is a NumPy array of coordinates with shape (V, 3) # f is a NumPy array of face indices with shape (F, 3) v, f = pcu.load_mesh_vf(\"my_mesh.ply\") # Load a point cloud stored in my_point_cloud.ply: # p is a NumPy array of point coordinates with shape (P, 3) p = pcu.load_mesh_v(\"my_point_cloud.ply\") # Compute the shortest distance between each point in p and the mesh: # dists is a NumPy array of shape (P,) where dists[i] is the # shortest distnace between the point p[i, :] and the mesh (v, f) dists, _, _ = pcu.closest_points_on_mesh(p, v, f) # Delete all points which are farther than some distance away from the mesh dist_thresh = 0.1 keep_points = p[dists < dist_thresh] # Save the filtered point cloud to my_point_cloud_trimmed.ply pcu.save_mesh_v(\"my_point_cloud_trimmed.ply\", keep_points)","title":"A very simple example"},{"location":"#core-features","text":"Point Cloud Utils includes utilities to perform the following tasks: Reading and writing meshes and point clouds from disk . Point Cloud Utils can handle any file that can be opened in MeshLab. Resampling point clouds to have different distributions. Generating point samples on a mesh . Computing metrics between point clouds and meshes (e.g. Chamfer Distance, Hausdorff Distance, etc...). Making a Mesh a Watertight Manifold . Computing signed distances to triangle meshes . Estimating normals for point clouds . Computing normals for triangle meshes . Fast ray/mesh intersection . Surface mesh smoothing .","title":"Core Features"},{"location":"#api-reference","text":"All available functions and classes are listed in the API reference","title":"API Reference"},{"location":"about/","text":"","title":"About"},{"location":"sections/api_reference/","text":"API Reference point_cloud_utils.RayMeshIntersector Class used to find the intersection between rays and a triangle mesh. __init__ ( mesh_v , mesh_f ) Create a RayMeshIntersector object which can be used to do ray/mesh queries with a triangle mesh. Parameters: Name Type Description Default mesh_v #v by 3 array of vertex positions (each row is a vertex) required mesh_f #f by 3 Matrix of face (triangle) indices required intersect_rays ( ray_o , ray_d , ray_near = 0.0 , ray_far = np . inf ) Compute intersection between a set of rays and the triangle mesh enclosed in this class Parameters: Name Type Description Default ray_o array of shape (#rays, 3) of ray origins (one per row) or a single array of shape (3,) to use required ray_d array of shape (#rays, 3) of ray directions (one per row) required ray_near an optional floating point value indicating the distance along each ray to start searching (default 0.0) 0.0 ray_far an optional floating point value indicating the maximum distance along each ray to search (default inf) np.inf Returns: Name Type Description f_id an array of shape (#rays,) representing the face id hit by each ray bc an array of shape (#rays, 3) where each row is the barycentric coordinates within each face of the ray intersection t the distance along each ray to the intersection point_cloud_utils.RaySurfelIntersector Class used to find the intersection between rays and a point cloud converted to surfels (i.e. a point cloud represented as circles centered at each point and oriented perpendicularly to each normal). __init__ ( p , n , r = 0.1 , subdivs = 7 ) Construct a RayPointCloudIntersector which can be used to compute the intersection between a set of rays and a point cloud converted to circular patches oriented with the point normals Parameters: Name Type Description Default p #p by 3 array of vertex positions (each row is a vertex) required n #p by 3 Matrix of vertex normals (each row is a vertex) required r Array or Scalar describing the size of each geometry element (Either one radius per vertex, or a global size for the whole point cloud) 0.1 subdivs Number of times to subdivide the patch geometry for each point (i.e. # tris per cicle) 7 intersect_rays ( ray_o , ray_d , ray_near = 0.0 , ray_far = np . inf ) Compute intersection between a set of rays and the point cloud converted to circular patches oriented with the point normals Parameters: Name Type Description Default ray_o array of shape (#rays, 3) of ray origins (one per row) or a single array of shape (3,) to use required ray_d array of shape (#rays, 3) of ray directions (one per row) required ray_near an optional floating point value indicating the distance along each ray to start searching (default 0.0) 0.0 ray_far an optional floating point value indicating the maximum distance along each ray to search (default inf) np.inf Returns: Name Type Description t a (#rays,) shaped array encoding the distance between the ray origin and intersection point for each ray (inf for missed rays) pid a (#rays,) shaped array of integer indices corresponding to which points were hit (-1 for a ray miss) point_cloud_utils.TriangleMesh A lightweight container class representing a triangle mesh with attributes stored at each vertex, wedge, and face, where: A vertex is a 3D position A wedge is a vertex and its two adjacent edges A face is a triangle connecting 3 vertices (Each triangle has 3 vertices and 3 wedges). The data in encapsulated into vertex data and face data, accessible via TriangleMes.vertex_data and TriangleMesh.face_data respectively: TriangleMesh.vertex_data : positions : [V, 3]-shaped numpy array of per-vertex positions normals : [V, 3]-shaped numpy array of per-vertex normals (or None) texcoords : [V, 2]-shaped numpy array of per-vertex uv coordinates (or None) tex_ids : [V,]-shaped numpy array of integer indices into TriangleMesh.textures indicating which texture to use at this vertex (or None) colors : [V, 4]-shaped numpy array of per-vertex RBGA colors in [0.0, 1.0] (or None) radius : [V,]-shaped numpy array of per-vertex curvature radii (or None) quality : [V,]-shaped numpy array of per-vertex quality measures (or None) flags : [V,]-shaped numpy array of 32-bit integer flags per vertex (or None) TriangleMesh.face_data : vertex_ids : [F, 3]-shaped numpy array of integer face indices into TrianglMesh.vertex_data.positions normals : [F, 3]-shaped numpy array of per-face normals (or None) colors : [F, 4]-shaped numpy array of per-face RBGA colors in [0.0, 1.0] (or None) quality : [F,]-shaped numpy array of per-face quality measures (or None) flags : [F,]-shaped numpy array of 32-bit integer flags per face (or None) wedge_colors : [F, 3, 4]-shaped numpy array of per-wedge RBGA colors in [0.0, 1.0] (or None) wedge_normals : [F, 3, 3]-shaped numpy array of per-wedge normals (or None) wedge_texcoords : [F, 3, 2]-shaped numpy array of per-wedge] uv coordinates (or None) wedge_tex_ids : [F, 3]-shaped numpy array of integer indices into TriangleMesh.textures indicating which texture to use at this wedge (or None) textures : A list of paths to texture image files for this mesh normal_maps : A list of paths to texture image files for this mesh f property An (m, 3)-shaped integer array containing this mesh's face indices (None if no faces) fc property An (m, 4)-shaped array containing this mesh's per-face RBGA colors (None if no face colors) fn property An (m, 3)-shaped array containing this mesh's per-face normals (None if no face normals) v property An (n, 3)-shaped array containing this mesh's vertex positions vc property An (n, 4)-shaped array containing this mesh's per-vertex RGBA (None if no vertex colors) vn property An (n, 3)-shaped array containing this mesh's per-vertex normals (None if no vertex normals) FaceData A lightweight container class representing per-face information within a TriangleMesh with the following attributes vertex_ids : [F, 3]-shaped numpy array of integer face indices into TrianglMesh.vertex_data.positions normals : [F, 3]-shaped numpy array of per-face normals (or None) colors : [F, 4]-shaped numpy array of per-face RBGA colors in [0.0, 1.0] (or None) quality : [F,]-shaped numpy array of per-face quality measures (or None) flags : [F,]-shaped numpy array of 32-bit integer flags per face (or None) wedge_colors : [F, 3, 4]-shaped numpy array of per-wedge RBGA colors in [0.0, 1.0] (or None) wedge_normals : [F, 3, 3]-shaped numpy array of per-wedge normals (or None) wedge_texcoords : [F, 3, 2]-shaped numpy array of per-wedge] uv coordinates (or None) wedge_tex_ids : [F, 3]-shaped numpy array of integer indices into TriangleMesh.textures indicating which texture to use at this wedge (or None) textures : A list of paths to texture image files for this mesh normal_maps : A list of paths to texture image files for this mesh VertexData A lightweight container class representing per-vertex information within a TriangleMesh with the following attributes positions : [V, 3]-shaped numpy array of per-vertex positions normals : [V, 3]-shaped numpy array of per-vertex normals (or None) texcoords : [V, 2]-shaped numpy array of per-vertex uv coordinates (or None) tex_ids : [V,]-shaped numpy array of integer indices into TriangleMesh.textures indicating which texture to use at this vertex (or None) colors : [V, 4]-shaped numpy array of per-vertex RBGA colors in [0.0, 1.0] (or None) radius : [V,]-shaped numpy array of per-vertex curvature radii (or None) quality : [V,]-shaped numpy array of per-vertex quality measures (or None) flags : [V,]-shaped numpy array of 32-bit integer flags per vertex (or None) load ( filename , dtype = np . float64 ) Load a mesh into this class from a file. The type of file is determined by the extension. Point Cloud Utils currently supports PLY, OBJ, STL, OFF, VRML 2.0, X3D, COLLADA, 3DS. Parameters: Name Type Description Default filename Path to the file to be loaded. Must have a valid extension. required dtype Type to save floating point data in (defaults to np.float32) np.float64 save ( filename , dtype = np . float32 ) Save this mesh to a file. The type of file is determined by the extension. Point Cloud Utils currently supports PLY, OBJ, STL, OFF, VRML 2.0, X3D, COLLADA, 3DS. Parameters: Name Type Description Default filename Path to the file to be saved. Must have a valid extension. required dtype Type to save floating point data in (defaults to np.float32) np.float32 point_cloud_utils . chamfer_distance ( x , y , return_index = False , p_norm = 2 , max_points_per_leaf = 10 ) Compute the chamfer distance between two point clouds x, and y Parameters: Name Type Description Default x A m-sized minibatch of point sets in R^d. i.e. shape [m, n_a, d] required y A m-sized minibatch of point sets in R^d. i.e. shape [m, n_b, d] required return_index If set to True, will return a pair (corrs_x_to_y, corrs_y_to_x) where corrs_x_to_y[i] stores the index into y of the closest point to x[i] (i.e. y[corrs_x_to_y[i]] is the nearest neighbor to x[i] in y). corrs_y_to_x is similar to corrs_x_to_y but with x and y reversed. False max_points_per_leaf The maximum number of points per leaf node in the KD tree used by this function. Default is 10. 10 p_norm Which norm to use. p_norm can be any real number, inf (for the max norm) -inf (for the min norm), 0 (for sum(x != 0)) 2 Returns: Type Description The chamfer distance between x an dy. If return_index is set, then this function returns a tuple (chamfer_dist, corrs_x_to_y, corrs_y_to_x) where corrs_x_to_y and corrs_y_to_x are described above. point_cloud_utils . closest_points_on_mesh () builtin closest_points_on_mesh(p: numpy.ndarray, v: numpy.ndarray, f: numpy.ndarray) -> Tuple[object, object, object] Compute distances from a set of points p to a triangle mesh (v, f) Parameters: Name Type Description Default p (#p, 3)-shaped array of query point positions required v (#v, 3)-shaped array of mesh vertex positions required f (#f, 3)-shaped array of triangle face indices required Returns: Name Type Description d a (#p,)-shaped array of shortest distances for each query point p f_idx a (#p,)-shaped array of indices into f of the face containing the closest point to eaach query point bc a (#p, 3)-shaped array of barycentric coordinates for each query point Notes Known bugs: This only computes distances to given primitives. So unreferenced vertices are ignored. However, degenerate primitives are handled correctly: triangle [1 2 2] is treated as a segment [1 2], and triangle [1 1 1] is treated as a point. So one could add extra combinatorially degenerate rows to Ele for all unreferenced vertices to also get distances to points. point_cloud_utils . connected_components () builtin connected_components(v: numpy.ndarray, f: numpy.ndarray) -> Tuple[object, object, object, object] Determine the connected components of a mesh Parameters: Name Type Description Default v (#v, 3)-shaped array of mesh vertex positions (one vertex position per row) required f (#f, 3)-shaped array of mesh face indexes into v (a row (fi, fj, fk) indicate the 3 vertices of a face) required Returns: Name Type Description cv a (#vertices,)-shaped array of integer indexes (starting from 0) indicating which component each vertex belongs to. i.e. cv[i] is the component of the vertex v[i]. nv the number of vertices in each connected component. i.e. nv[j] is the number of vertices in component j cf a (#faces,)-shaped array of integer indexes (starting from 0) indicating which component each face belongs to. i.e. cf[i] is the component of the face f[i]. nf the number of faces in each connected component. i.e. nf[j] is the number of faces in component j point_cloud_utils . decimate_triangle_mesh () builtin decimate_triangle_mesh(v: numpy.ndarray, f: numpy.ndarray, max_faces: int, decimation_heuristic: str = 'shortest_edge') -> Tuple[object, object, object, object] Decimate a (manifold) triangle mesh by collapsing edges Parameters: Name Type Description Default v (#v, 3)-shaped array of mesh vertex positions required f (#f, 3)-shaped array of triangle face indices required max_faces The maximum number of faces in the decimated output mesh (must be between 0 and #f) required decimation_heuristic Which decimation heuristic to use. Currently only supports \"shortest_edge\". required Returns: Name Type Description v_out (#v_out, 3)-shaped array of vertex positions for the decimated mesh f_out (#f_out, 3)-shaped array of triangle face indices for the decimated mesh v_correspondences (#v_out, 1)-shaped array where v_correspondences[i] is the index of the vertex in v which generated v_out[i] f_correspondences (#f_out, 1)-shaped array where f_correspondences[i] is the index of the face in f which generated f_out[i] point_cloud_utils . deduplicate_mesh_vertices () builtin deduplicate_mesh_vertices(v: numpy.ndarray, f: numpy.ndarray, epsilon: float, return_index: bool = True) -> object Removes duplicated vertices from a triangle mesh two vertices are considered the same if their distance is below some threshold Parameters: Name Type Description Default v #v by 3 Matrix of mesh vertex 3D positions required f #f by 3 Matrix of face (triangle) indices required epsilon threshold below which two points are considered equal required return_index If true, return indices to map between input and output required Returns: Name Type Description x_new #x_new x 3 Point cloud with duplicates removed svi #x x 1 indices so that x_new = x[svi] (only returned if return_index is True) svj #x_new x 1 indices so that x = x_new[svj] (only returned if return_index is True) See also deduplicate_point_cloud point_cloud_utils . deduplicate_point_cloud () builtin deduplicate_point_cloud(points: numpy.ndarray, epsilon: float, return_index: bool = True) -> object Removes duplicated points from a point cloud where two points are considered the same if their distance is below some threshold Parameters: Name Type Description Default x #x by 3 Matrix of 3D positions required epsilon threshold below which two points are considered equal required return_index If true, return indices to map between input and output required Returns: Name Type Description x_new #x_new x 3 Point cloud with duplicates removed if return indices is set, this function also returns: svi : #x x 1 indices so that x_new = x[svi] svj : #x_new x 1 indices so that x = x_new[svj] See also deduplicate_mesh_vertices point_cloud_utils . dilate_sparse_voxel_grid ( grid_coordinates , count = 1 ) Perform binary dilation on a sparse voxel grid, using a 3x3 filter of ones applied count times. i.e. convolve the filter: [[1, 1, 1], [1, 1, 1], [1, 1, 1]] with the sparse voxel grid. Parameters: Name Type Description Default grid_coordinates An (n, 3) shaped integer array of voxels coordinates in the sparse voxel grid required count The number of iterations of binary dilation to run 1 Returns: Name Type Description dilated_grid_coordinates An (m, 3) integer array encoding the coordinates of the sparse voxel grid after dilation point_cloud_utils . downsample_point_cloud_on_voxel_grid ( voxel_size , points , * args , min_bound = None , max_bound = None , min_points_per_voxel = 1 ) Downsample a point set to conform with a voxel grid by taking the average of points within each voxel. Parameters: Name Type Description Default voxel_size a scalar representing the size of each voxel or a 3 tuple representing the size per axis of each voxel. required points a [#v, 3]-shaped array of 3d points. required *args Any additional arguments of shape [#v, *] are treated as attributes and will averaged into each voxel along with the points These will be returns () min_bound a 3 tuple representing the minimum coordinate of the voxel grid or None to use the bounding box of the input point cloud. None max_bound a 3 tuple representing the maximum coordinate of the voxel grid or None to use the bounding box of the input point cloud. None min_points_per_voxel If a voxel contains fewer than this many points, then don't include the points in that voxel in the output. 1 Returns: Type Description A tuple (v, attrib0, attrib1, ....) of downsampled points, and point attributes. Attributes are returned in the same order they are passed in. If no attributes are passed in, then this function simply returns vertices. point_cloud_utils . downsample_point_cloud_poisson_disk () builtin downsample_point_cloud_poisson_disk(v: numpy.ndarray, num_samples: int, radius: float = 0.0, best_choice_sampling: bool = True, random_seed: int = 0, sample_num_tolerance: float = 0.04) -> object Downsample a point set so that samples are approximately evenly spaced. This function uses the method in \"Parallel Poisson Disk Sampling with Spectrum Analysis on Surface\" (http://graphics.cs.umass.edu/pubs/sa_2010.pdf) Parameters: Name Type Description Default v #v by 3 array of vertex positions required n #v by 3 array of vertex normals required num_samples desired number of Poisson Disk samples. Note that the actual number of returned samples will not be exactly this value (see sample_num_tolerance) to control the range of possible returned samples. Note: If this value <= 0, then the parameter radius is used to decide the number of samples required radius desired separation between points, if num_samples <= 0, then this value is used to determine the sampling (-1.0, by default). required best_choice_sampling When downsampling, always keep the sample that will remove the fewest number of samples. (True by default). required random_seed A random seed used to generate the samples. Passing in 0 will use the current time. (0 by default). required sample_num_tolerance If you requested a target number of samples, by passsing num_samples > 0, then this function will return between (1 - sample_num_tolerance) * num_samples and (1 + sample_num_tolerance) * num_samples. Setting a very small value for this parameter will increase convergence time. (0.04 by default). required Returns: Name Type Description p_idx A (m,) shaped array of indices into v where m is the number of Poisson-disk samples point_cloud_utils . earth_movers_distance ( p , q , p_norm = 2 , eps = 0.0001 , max_iters = 100 , stop_thresh = 0.001 ) Compute the (batched) Sinkhorn correspondences between two dirac delta distributions, U, and V. This implementation is numerically stable with float32. Parameters: Name Type Description Default p An (n, d)-shaped array of d-dimensional points required b An (m, d)-shaped array of d-dimensional points required p_norm Which norm to use. Must be one of {non-zero int, inf, -inf, \u2018fro\u2019, \u2018nuc\u2019} (default is 2), 2 eps The reciprocal of the sinkhorn regularization parameter (default 1e-4) 0.0001 max_iters The maximum number of Sinkhorn iterations 100 stop_thresh Stop if the change in iterates is below this value 0.001 Returns: Name Type Description emd The earth mover's distance between point clouds p and q P An (n, m)-shaped array of correspondences between point clouds p and q point_cloud_utils . erode_sparse_voxel_grid ( grid_coordinates , count = 1 ) Perform binary erosion on a sparse voxel grid, using a 3x3 filter of ones applied count times. i.e. take the negation of the convolution of the filter: [[1, 1, 1], [1, 1, 1], [1, 1, 1]] with the sparse voxel grid. Parameters: Name Type Description Default grid_coordinates An (n, 3) shaped integer array of voxels coordinates in the sparse voxel grid required count The number of iterations of binary erosion to run 1 Returns: Name Type Description eroded_grid_coordinates An (m, 3) integer array encoding the coordinates of the sparse voxel grid after erosion point_cloud_utils . estimate_mesh_face_normals () builtin estimate_mesh_face_normals(v: numpy.ndarray, f: numpy.ndarray) -> object Compute vertex normals of a mesh from its vertices and faces using face area weighting Parameters: Name Type Description Default v (#v, 3)-shaped NumPy array of mesh vertex 3D positions required f (#f, 3)-shaped NumPy array of face (triangle) indices required Returns: Name Type Description n (#f, 3)-shaped NumPy array of face normals (i.e. n[i] is the normal at face f[i]). Note that any degenerate faces will have a zero normal. point_cloud_utils . estimate_mesh_vertex_normals () builtin estimate_mesh_vertex_normals(v: numpy.ndarray, f: numpy.ndarray, weighting_type: str = 'uniform') -> object Compute vertex normals of a mesh from its vertices and faces using face area weighting Parameters: Name Type Description Default v (#v, 3)-shaped NumPy array of mesh vertex 3D positions required f (#f, 3)-shaped NumPy array of face (triangle) indices required weighting_type Weighting type must be one of 'uniform', 'angle', or 'area' (default is 'uniform') required Returns: Name Type Description n (#v, 3)-shaped NumPy array of vertex normals (i.e. n[i] is the normal at vertex v[i]) estimate_mesh_face_normals point_cloud_utils . estimate_point_cloud_normals_ball ( points , ball_radius , view_directions = None , drop_angle_threshold = np . deg2rad ( 90.0 ), min_pts_per_ball = 3 , max_pts_per_ball =- 1 , weight_function = 'constant' , max_points_per_leaf = 10 , num_threads =- 1 ) Estimate normals for a point cloud by locally fitting a plane to all points within a radius of each point (possibly weighted by a radial basis function). This function can optionally consider directions to the sensor for each point to compute neighborhoods of points which are all facing the same direction, and align the final normal directions. Parameters: Name Type Description Default points (n, 3)-shaped NumPy array of point positions (each row is a point) required ball_radius The radius of each neighborhood used to estimate normals required view_directions (n, 3)-shaped NumPy array or None, representing the unit direction to the sensor for each point. This parameter is used to align the normals and compute neighborhoods of similar facing points. None drop_angle_threshold If view_directions is passed in, drop points whose angle between the normal and view direction exceeds drop_angle_threshold (in radians). Useful for filtering out low quality points. np.deg2rad(90.0) min_pts_per_ball Discard points whose neighborhood contains fewer than min_pts_per_ball points. 3 max_pts_per_ball If set to a positive number, then only use max_pts_per_ball points within each neighborhood whose number of points exceeds this value. -1 weight_function Weighting function for points in a neighborhood. Must be one of 'constant' or 'rbf' where: 'constant' max_points_per_leaf Maximum number of points in each leaf node of the KD-tree used for nearest neighbor queries. Tuning this can potentially improve performance on large point clouds. 10 num_threads Number of threads used to parallelize computation. If set to 0 ir 1, will run in single threaded mode. If set to a positive number t > 1, will use t threads. If set to -1, will use #processors threads for inputs greater than 1 million points. -1 Returns: Name Type Description p an (m, 3)-shaped Numpy array of 3d points n an (m, 3)-shaped Numpy array of unit normals for each point in p See Also estimate_pointcloud_normals_ball point_cloud_utils . estimate_point_cloud_normals_knn ( points , num_neighbors , view_directions = None , drop_angle_threshold = np . deg2rad ( 90.0 ), max_points_per_leaf = 10 , num_threads =- 1 ) Estimate normals for a point cloud by locally fitting a plane to the k nearest neighbors of each point. This function can optionally consider directions to the sensor for each point to compute neighborhoods of points which are all facing the same direction, and align the final normal directions. Parameters: Name Type Description Default points (n, 3)-shaped NumPy array of point positions (each row is a point) required num_neighbors Integer number of neighbors to use in each neigghborhood. required view_directions (n, 3)-shaped NumPy array or None, representing the unit direction to the sensor for each point. This parameter is used to align the normals and compute neighborhoods of similar facing points. None drop_angle_threshold If view_directions is passed in, drop points whose angle between the normal and view direction exceeds drop_angle_threshold (in radians). Useful for filtering out low quality points. np.deg2rad(90.0) max_points_per_leaf Maximum number of points in each leaf node of the KD-tree used for nearest neighbor queries. Tuning this can potentially improve performance on large point clouds. 10 num_threads Number of threads used to parallelize computation. If set to 0 ir 1, will run in single threaded mode. If set to a positive number t > 1, will use t threads. If set to -1, will use #processors threads for inputs greater than 1 million points. -1 Returns: Name Type Description idx an (m, 1)-shaped Numpy array of indices into points n an (m, 3)-shaped Numpy array of unit normals for each point in p See Also estimate_pointcloud_normals_ball point_cloud_utils . hausdorff_distance ( x , y , return_index = False , squared_distances = False , max_points_per_leaf = 10 ) Compute the Hausdorff distance between x and y Parameters: Name Type Description Default x n by 3 array of representing a set of n points (each row is a point of dimension 3) required y m by 3 array of representing a set of m points (each row is a point of dimension 3) required return_index Optionally return the index pair (i, j) into x and y such that x[i, :] and y[j, :] are the two points with maximum shortest distance. False squared_distances If set to True, then return squared L2 distances. Default is False. False max_points_per_leaf The maximum number of points per leaf node in the KD tree used by this function. Default is 10. 10 Returns: Type Description The largest shortest distance, d between each point in source and the points in target . If return_index is set, then this function returns a tuple (d, i, j) where d is as described above and (i, j) are such that source[i, :] and target[j, :] are the two points with maximum shortest distance. point_cloud_utils . interpolate_barycentric_coords ( f , fi , bc , attribute ) Interpolate an attribute stored at each vertex of a mesh across the faces of a triangle mesh using barycentric coordinates Parameters: Name Type Description Default f a (#faces, 3)-shaped NumPy array of mesh faces (indexing into some vertex array). required fi a (#attribs,)-shaped NumPy array of indexes into f indicating which face each attribute lies within. required bc a (#attribs, 3)-shaped NumPy array of barycentric coordinates for each attribute required attribute a (#vertices, dim)-shaped NumPy array of attributes at each of the mesh vertices required Returns: Type Description A (#attribs, dim)-shaped array of interpolated attributes. point_cloud_utils . k_nearest_neighbors () builtin k_nearest_neighbors(query_points: numpy.ndarray, dataset_points: numpy.ndarray, k: int, squared_distances: bool = False, max_points_per_leaf: int = 10, num_threads: int = -1) -> Tuple[object, object] Compute the k nearest neighbors (L2 distance) from each point in the query point cloud to the dataset point cloud. Parameters: Name Type Description Default query_points n by 3 array of representing a set of n points (each row is a point of dimension 3). required dataset_points m by 3 array of representing a set of m points (each row is a point of dimension 3). required k the number of nearest neighbors to query per point. required squared_distances If set to True, then return squared L2 distances. Default is False. required max_points_per_leaf The maximum number of points per leaf node in the KD tree used by this function. Default is 10. required num_threads Number of threads to use. If set to -1, will use all available CPUs. If set to 0, will run in serial. Default is -1. required Returns: Name Type Description dists An (n, k)-shaped array such that dists[i,k] contains the k^th shortest L2 distance from the point query_points[i, :] to dataset_points corrs An (n, k)-shaped array such that corrs[i,k] contains the index into dataset_points of the k^th nearest point to query_points[i, :] point_cloud_utils . laplacian_smooth_mesh () builtin laplacian_smooth_mesh(v: numpy.ndarray, f: numpy.ndarray, num_iters: int, use_cotan_weights: bool = False) -> object Smooth a mesh using Laplacian smoothing Parameters: Name Type Description Default v #v by 3 Matrix of mesh vertex 3D positions required f #f by 3 Matrix of face (triangle) indices required num_iters Number of smoothing iterations required use_cotan_weights Whether to use cotagent weighting (False by default) required Returns: Name Type Description n list of vertex normals of shape #v by 3 point_cloud_utils . lloyd_2d () builtin lloyd_2d(n: int, num_lloyd: int = 10, num_newton: int = 10) -> object Generate n samples in the unit square, [0, 1]^2 using Lloyd's algorithm (https://en.wikipedia.org/wiki/Lloyd%27s_algorithm). Parameters: Name Type Description Default n The number of 2d point samples to generate required num_lloyd The number of Lloyd iterations to do (default 10) required num_newton The number of Newton iterations to do when computing Voronoi diagrams (default 10) required Returns: Name Type Description lloyd_points a (n, 2)-shaped array of point samples in the unit square [0, 1]^2 point_cloud_utils . lloyd_3d () builtin lloyd_3d(n: int, num_lloyd: int = 10, num_newton: int = 10) -> object Generate n samples in the unit cube, [0, 1]^3 using Lloyd's algorithm (https://en.wikipedia.org/wiki/Lloyd%27s_algorithm). Parameters: Name Type Description Default n The number of 3d point samples to generate required num_lloyd The number of Lloyd iterations to do (default 10) required num_newton The number of Newton iterations to do when computing Voronoi diagrams (default 10) required Returns: Name Type Description lloyd_pts a (n, 3)-shaped array of point samples in the unit square [0, 1]^3 point_cloud_utils . load_mesh_v ( filename , dtype = float ) Load a point cloud consisting only of vertex positions. Point Cloud Utils currently supports PLY, OBJ, STL, OFF, VRML 2.0, X3D, COLLADA, 3DS. Parameters: Name Type Description Default filename Path to the file to be loaded. Must have a valid extension. required dtype The floating point type of loaded data ( np.float32 or np.float64 ) float Returns: Name Type Description v An (n, 3)-shaped numpy array of coordinates point_cloud_utils . load_mesh_vc ( filename , dtype = float ) Load a point cloud consisting of vertex positions, and vertex colors. Point Cloud Utils currently supports PLY, OBJ, STL, OFF, VRML 2.0, X3D, COLLADA, 3DS. Parameters: Name Type Description Default filename Path to the file to be loaded. Must have a valid extension. required dtype The floating point type of loaded data ( np.float32 or np.float64 ) float Returns: Name Type Description v An (n, 3)-shaped numpy array of coordinates c An (n, 3)-shaped or (n, 4)-shaped numpy array of per-vertex RGB or RGBA colors (from 0.0 to 1.0) point_cloud_utils . load_mesh_vf ( filename , dtype = float ) Load a triangle mesh consisting of vertex positions and face indices. Point Cloud Utils currently supports PLY, OBJ, STL, OFF, VRML 2.0, X3D, COLLADA, 3DS. Parameters: Name Type Description Default filename Path to the file to be loaded. Must have a valid extension. required dtype The floating point type of loaded data ( np.float32 or np.float64 ) float Returns: Name Type Description v An (n, 3)-shaped numpy array of coordinates f An (m, 3)-shaped integer numpy array of face indices into v point_cloud_utils . load_mesh_vfn ( filename , dtype = float ) Load a triangle mesh consisting of vertex positions, face indices, and vertex normals. Point Cloud Utils currently supports PLY, OBJ, STL, OFF, VRML 2.0, X3D, COLLADA, 3DS. Parameters: Name Type Description Default filename Path to the file to be loaded. Must have a valid extension. required dtype The floating point type of loaded data ( np.float32 or np.float64 ) float Returns: Name Type Description v An (n, 3)-shaped numpy array of coordinates f An (m, 3)-shaped integer numpy array of face indices into v n An (n, 3)-shaped numpy array of per-vertex normals point_cloud_utils . load_mesh_vfnc ( filename , dtype = float ) Load a triangle mesh consisting of vertex positions, face indices, vertex normals, and vertex colors. Point Cloud Utils currently supports PLY, OBJ, STL, OFF, VRML 2.0, X3D, COLLADA, 3DS. Parameters: Name Type Description Default filename Path to the file to be loaded. Must have a valid extension. required dtype The floating point type of loaded data ( np.float32 or np.float64 ) float Returns: Name Type Description v An (n, 3)-shaped numpy array of coordinates f An (m, 3)-shaped integer numpy array of face indices into v n An (n, 3)-shaped numpy array of per-vertex normals c An (n, 3)-shaped or (n, 4)-shaped numpy array of per-vertex RGB or RGBA colors (from 0.0 to 1.0) point_cloud_utils . load_mesh_vn ( filename , dtype = float ) Load a point cloud consisting of vertex positions, and vertex normals. Point Cloud Utils currently supports PLY, OBJ, STL, OFF, VRML 2.0, X3D, COLLADA, 3DS. Parameters: Name Type Description Default filename Path to the file to be loaded. Must have a valid extension. required dtype The floating point type of loaded data ( np.float32 or np.float64 ) float Returns: Name Type Description v An (n, 3)-shaped numpy array of coordinates n An (n, 3)-shaped numpy array of per-vertex normals point_cloud_utils . load_mesh_vnc ( filename , dtype = float ) Load a point cloud consisting of vertex positions, vertex normals, and vertex colors. Point Cloud Utils currently supports PLY, OBJ, STL, OFF, VRML 2.0, X3D, COLLADA, 3DS. Parameters: Name Type Description Default filename Path to the file to be loaded. Must have a valid extension. required dtype The floating point type of loaded data ( np.float32 or np.float64 ) float Returns: Name Type Description v An (n, 3)-shaped numpy array of coordinates n An (n, 3)-shaped numpy array of per-vertex normals c An (n, 3)-shaped or (n, 4)-shaped numpy array of per-vertex RGB or RGBA colors (from 0.0 to 1.0) point_cloud_utils . load_triangle_mesh ( filename , dtype = np . float64 ) Load a triangle mesh into a TriangleMesh class. Point Cloud Utils currently supports PLY, OBJ, STL, OFF, VRML 2.0, X3D, COLLADA, 3DS. Parameters: Name Type Description Default filename Path to the file to be saved. Must have a valid extension. required dtype The type of floating point number to store the data in (np.float32 or np.float64) np.float64 Returns: Name Type Description mesh A TriangleMesh class containing the loaded mesh point_cloud_utils . make_mesh_watertight () builtin make_mesh_watertight(v: numpy.ndarray, f: numpy.ndarray, resolution: float = 20000, seed: int = -1) -> Tuple[object, object] Convert a mesh into a watertight manifold Parameters: Name Type Description Default v (#v, 3)-shaped array of mesh vertex positions (one vertex position per row) required f (#f, 3)-shaped array of mesh face indexes into v (a row (fi, fj, fk) indicate the 3 vertices of a face) required resolution A resolution parameter for the algorithm required Returns: Name Type Description vw a (#vw, 3)-shaped array of vertices (one per row) fw a (#fw, 3)-shaped array of face indices into vw (one face per row) point_cloud_utils . marching_cubes_sparse_voxel_grid () builtin marching_cubes_sparse_voxel_grid(grid_scalars: numpy.ndarray, grid_coordinates: numpy.ndarray, cube_indices: numpy.ndarray, isovalue: float) -> Tuple[object, object] Run marching cubes on a hex mesh representing a sparse voxel grid (see also sparse_voxel_grid_to_hex_mesh) Parameters: Name Type Description Default grid_scalars An (n,) shaped array of scalar values at each hex mesh vertex required grid_coordinates An (n, 3) shaped array of hex mesh vertices required cube_indices An (m, 8) shaped array of indices into grid_coordinates where cube_indices[i, :] are the indices of the 8 points forming the i^th cube Note the cube indices must be ordered as: [[0, 0, 0], [1, 0, 0], [1, 1, 0], [0, 1, 0], [0, 0, 1], [1, 0, 1], [1, 1, 1], [0, 1, 1]] where [i, j, k] indicates the offset along the (x, y, z) axes from the bottom, back, left corner of the cube required isovalue Which level set to extract required Returns: Name Type Description v A (#v, 3) array of triangle mesh vertices f A (#f, 3) array of indices into v where f[i, :] are the indices into vof the 3 points forming the i^th triangle See Also sparse_voxel_grid_to_hex_mesh point_cloud_utils . mesh_face_areas () builtin mesh_face_areas(v: numpy.ndarray, f: numpy.ndarray, num_threads: int = -1) -> object Compute the areas of each face of a triangle mesh Parameters: Name Type Description Default v #v by 3 array of vertex positions (each row is a vertex) required f #f by 3 Matrix of face (triangle) indices required Returns: Name Type Description areas a numpy array of shape (#faces,) where areas[i] is the area of the face f[i] point_cloud_utils . mesh_mean_and_gaussian_curvatures ( v , f , r =- 1.0 ) Estimate mean and Gaussian curvatures for a mesh Parameters: Name Type Description Default v #v by 3 Matrix of mesh vertex 3D positions required f #f by 3 Matrix of face (triangle) indices required r optional floating point radius of neighborhood to consider when estimating curvature If set to a positive value, will use a more robust curvature estimation method (but may require some tuning) -1.0 Returns: Name Type Description kh an array of shape (#v,) of per-vertex mean curvatures kg an array of shape (#v,) of per-vertex Gaussian curvatures point_cloud_utils . mesh_principal_curvatures () builtin mesh_principal_curvatures(v: numpy.ndarray, f: numpy.ndarray, r: float = -1.0) -> Tuple[object, object, object, object] Estimate principal curvature directions and magnitudes for a mesh Parameters: Name Type Description Default v #v by 3 Matrix of mesh vertex 3D positions required f #f by 3 Matrix of face (triangle) indices required r optional floating point radius of neighborhood to consider when estimating curvature required Returns: Name Type Description k1 an array of shape (#v,) of maximum curvature magnitudes k2 an array of shape (#v,) of minimum curvature magnitudes d1 an array of shape (#v, 3) of maximum curvature directions d2 an array of shape (#v, 3) of minimum curvature directions point_cloud_utils . morton_add () builtin morton_add(codes_1: numpy.ndarray, codes_2: numpy.ndarray, num_threads: int = -1) -> object Add morton codes together (corresponding to adding the vectors they encode) Parameters: Name Type Description Default codes_1 an (n,)-shaped array of morton codes required codes_2 an (n,)-shaped array of morton codes required num_threads Number of threads to use. If set to -1, will use all available CPUs. If set to 0, will run in serial. Default is -1. required Returns: Name Type Description morton_codes an (n,)-shaped array of added morton codes point_cloud_utils . morton_decode () builtin morton_decode(codes: numpy.ndarray, num_threads: int = -1) -> object Decode n points along a Morton curve into 3D points Parameters: Name Type Description Default codes an (n,)-shaped array of Morton codes required Returns: Name Type Description points an (n, 3)-shaped array of 3D points point_cloud_utils . morton_encode () builtin morton_encode(pts: numpy.ndarray, num_threads: int = -1) -> object Encode n 3D points using Morton coding, possibly sorting them Parameters: Name Type Description Default pts an (n, 3)-shaped array of 3D points required num_threads Number of threads to use. If set to -1, will use all available CPUs. If set to 0, will run in serial. Default is -1. required Returns: Name Type Description morton_codes an (n,)-shaped array of morton encoded points point_cloud_utils . morton_knn () builtin morton_knn(codes: numpy.ndarray, qcodes: numpy.ndarray, k: int, sort_dist: bool = True) -> object Queries a sorted array of morton encoded points to find the (approximate) k nearest neighbors Parameters: Name Type Description Default codes an (n)-shaped array of morton codes required qcodes an (m)-shaped array of query codes required k an integer representing the number of nearest neighbors required sort_dist (optional, defaults to True) whether to return the nearest neigbors in distance sorted order required Returns: Name Type Description nn_idx an (m, k)-shaped array of indices into codes point_cloud_utils . morton_subtract () builtin morton_subtract(codes_1: numpy.ndarray, codes_2: numpy.ndarray, num_threads: int = -1) -> object Subtract morton codes from each other (corresponding to adding the vectors they encode) Parameters: Name Type Description Default codes_1 an (n,)-shaped array of morton codes required codes_2 an (n,)-shaped array of morton codes required num_threads Number of threads to use. If set to -1, will use all available CPUs. If set to 0, will run in serial. Default is -1. required Returns: Name Type Description morton_codes an (n,)-shaped shaped array of added morton codes point_cloud_utils . one_sided_hausdorff_distance () builtin one_sided_hausdorff_distance(source: numpy.ndarray, target: numpy.ndarray, return_index: bool = True, squared_distances: bool = False, max_points_per_leaf: int = 10) -> object Compute the one sided Hausdorff distance from source to target Parameters: Name Type Description Default source n by 3 array of representing a set of n points (each row is a point of dimension 3) required target m by 3 array of representing a set of m points (each row is a point of dimension 3) required return_index Optionally return the index pair (i, j) into source and target such that source[i, :] and target[j, :] are the two points with maximum shortest distance. required squared_distances If set to True, then return squared L2 distances. required max_points_per_leaf the maximum number of points per leaf node in the KD tree used by this function. Default is 10. required Returns: Name Type Description d The largest shortest distance, d between each point in source and the points in target . i (n,)-shaped array of indices such that source[i, :] and target[j, :] are the two points with maximum shortest distance. j (m,)-shaped array of indices such that source[i, :] and target[j, :] are the two points with maximum shortest distance. point_cloud_utils . orient_mesh_faces () builtin orient_mesh_faces(f: numpy.ndarray, weighting_type: str = 'uniform') -> Tuple[object, object] Consistently orient faces of a mesh within each connected component Parameters: Name Type Description Default f (#f, 3)-shaped NumPy array of face (triangle) indices required Returns: Name Type Description oriented_faces (#f, 3)-shaped NumPy array of faces which are consistently oriented face_components (#f,)-shaped NumPy array of connected component ids (i.e. face_components[i] is the component id of facef[i]) point_cloud_utils . pairwise_distances ( a , b , p = None ) Compute the (batched) pairwise distance matrix between a and b which both have size [m, n, d] or [n, d]. The result is a tensor of size [m, n, n] (or [n, n]) whose entry [m, i, j] contains the distance_tensor between a[m, i, :] and b[m, j, :]. Parameters: Name Type Description Default a A tensor containing m batches of n points of dimension d. i.e. of size (m, n, d) required b A tensor containing m batches of n points of dimension d. i.e. of size (m, n, d) required p Norm to use for the distance_tensor None Returns: Name Type Description M A (m, n, n)-shaped array containing the pairwise distance_tensor between each pair of inputs in a batch. point_cloud_utils . point_cloud_fast_winding_number () builtin point_cloud_fast_winding_number(p: numpy.ndarray, n: numpy.ndarray, a: numpy.ndarray, q: numpy.ndarray) -> object Compute a consistent inside/outside field given a point cloud and evaluate that field at a set of query points Parameters: Name Type Description Default p (#p, 3)-shaped array of points required n (#p, 3)-shaped array of point normals at p required a (#p, 1)-shaped array of point areas (e.g. computed with pcu.estimate_point_cloud_areas) required q (#q, 3)-shaped array of query positions at which to evaluat the winding number field required Returns: Name Type Description signs (#q,)-shaped array with a sign value for each query point (positive for outside and negative for inside) point_cloud_utils . quantize_subdivided_sparse_voxel_grid ( fractional_grid_coordinates , num_subdivs ) subdivide_sparse_voxel_grid returns fractional voxel coordinates (since we are subdividing an integer grid). This function transforms these fractional coordinates into integer coordinates. This operation can be undone with unquantize_subdivided_sparse_voxel_grid Parameters: Name Type Description Default fractional_grid_coordinates An (n, 3) shaped array of fractional voxels coordinates returned by subdivide_sparse_voxel_grid required num_subdivs The number of subdivision iterations used to compute fractional_grid_coordinates required Returns: Name Type Description quantized_grid_coordinates An (n, 3) shaped array of quantized grid coordinates See Also subdivide_sparse_voxel_grid unquantize_subdivided_sparse_voxel_grid point_cloud_utils . ray_mesh_intersection () builtin ray_mesh_intersection(v: numpy.ndarray, f: numpy.ndarray, ray_o: numpy.ndarray, ray_d: numpy.ndarray, ray_near: float = 0.0, ray_far: float = inf) -> Tuple[object, object, object] Compute intersection between a set of rays and a triangle mesh Parameters: Name Type Description Default v #v by 3 array of vertex positions (each row is a vertex) required f #f by 3 Matrix of face (triangle) indices required ray_o array of shape (#rays, 3) of ray origins (one per row) or a single array of shape (3,) to use required ray_d array of shape (#rays, 3) of ray directions (one per row) required ray_near an optional floating point value indicating the distance along each ray to start searching (default 0.0) required ray_far an optional floating point value indicating the maximum distance along each ray to search (default inf) required Returns: Name Type Description f_id an array of shape (#rays,) representing the face id hit by each ray bc an array of shape (#rays, 3) where each row is the barycentric coordinates within each face of the ray intersection t the distance along each ray to the intersection point_cloud_utils . ray_surfel_intersection ( p , n , ray_o , ray_d , r = 0.1 , subdivs = 4 , ray_near = 0.0 , ray_far = np . inf ) Compute intersection between a set of rays and a point cloud converted to surfels (i.e. circular patches oriented with the point normals) Parameters: Name Type Description Default p #p by 3 array of vertex positions (each row is a vertex) required n #p by 3 Matrix of vertex normals (each row is a vertex) required ray_o array of shape (#rays, 3) of ray origins (one per row) or a single array of shape (3,) to use required ray_d array of shape (#rays, 3) of ray directions (one per row) required r Array or Scalar describing the size of each geometry element (Either one radius per vertex, or a global size for the whole point cloud) 0.1 subdivs Number of times to subdivide the patch geometry for each point (i.e. # tris per cicle) 4 ray_near an optional floating point value indicating the distance along each ray to start searching (default 0.0) 0.0 ray_far an optional floating point value indicating the maximum distance along each ray to search (default inf) np.inf Returns: Name Type Description t a (#rays,) shaped array encoding the distance between the ray origin and intersection point for each ray (inf for missed rays) pid a (#rays,) shaped array of integer indices corresponding to which points were hit (-1 for a ray miss) point_cloud_utils . remove_unreferenced_mesh_vertices () builtin remove_unreferenced_mesh_vertices(v: numpy.ndarray, f: numpy.ndarray) -> Tuple[object, object, object, object] Removes duplicated vertices from a triangle mesh two vertices are considered the same if their distance is below some threshold Parameters: Name Type Description Default v (#v, 3)-shaped array of mesh vertex 3D positions required f (#f, 3)-shaped array of face (triangle) indices required Returns: Name Type Description v_new (#v_new, 3)-shaped array of mesh vertex positions without unreferenced vertices f_new (#f_new, 3)-shaped array of mesh faces indexing into v_new correspondences_v (#v, 1)-shaped array of indices so that v_new = correspondences_v[svi] correspondences_f (#f, 1)-shaped array of indices so that f_new = correspondences_f[svj] point_cloud_utils . sample_mesh_lloyd () builtin sample_mesh_lloyd(v: numpy.ndarray, f: numpy.ndarray, num_samples: int, num_lloyd: int = 10, num_newton: int = 10, return_mesh: bool = False) -> object Generate n samples on a surface defined by a triangle mesh using Lloyd's algorithm (https://en.wikipedia.org/wiki/Lloyd%27s_algorithm). Parameters: Name Type Description Default v A #v by 3 array where each row is a vertex of the input mesh required f A #f by 3 array of indices into v where each row is a triangle of the input mesh. required n The number of surface samples to generate required num_lloyd The number of Lloyd iterations to do (default 10) required num_newton The number of Newton iterations to do when computing Voronoi diagrams (default 10) required Returns: Name Type Description lloyd_pts a (n, 3)-shaped array of point samples on the input surface defined by (v, f) point_cloud_utils . sample_mesh_poisson_disk () builtin sample_mesh_poisson_disk(v: numpy.ndarray, f: numpy.ndarray, num_samples: int, radius: float = 0.0, use_geodesic_distance: bool = True, best_choice_sampling: bool = True, random_seed: int = 0, sample_num_tolerance: float = 0.04, oversampling_factor: float = 40.0) -> Tuple[object, object] Downsample a point set (possibly on a mesh) so that samples are approximately evenly spaced. This function uses the method in (\"Parallel Poisson Disk Sampling with Spectrum Analysis on Surface\")[http://graphics.cs.umass.edu/pubs/sa_2010.pdf] Parameters: Name Type Description Default v #v by 3 array of mesh vertex positions required f #f by 3 array of mesh face indices required num_samples desired number of Poisson Disk samples. Note that the actual number of returned samples will not be exactly this value (see sample_num_tolerance) to control the range of possible returned samples. Note: If this value <= 0, then the parameter radius is used to decide the number of samples required radius desired separation between points, if num_samples <= 0, then this value is used to determine the sampling (-1.0, by default). required use_geodesic_distance Use geodesic distance on the mesh downsampling. (True by default). required best_choice_sampling When downsampling, always keep the sample that will remove the fewest number of samples. (True by default). required random_seed A random seed used to generate the samples. Passing in 0 will use the current time. (0 by default). required sample_num_tolerance If you requested a target number of samples, by passsing num_samples > 0, then this function will return between (1 - sample_num_tolerance) * num_samples and (1 + sample_num_tolerance) * num_samples. Setting a very small value for this parameter will increase convergence time. (0.04 by default). required oversampling_factor To generate Poisson disk samples, we first generate a very dense (uniform) random sampling of the mesh, then prune these down to have the Poisson disk property. This parameter controls how many dense samples are generated. i.e. we generate oversampling_factor * num_samples samples (if you passed in radius, we estimate num_samples from the input points and radius). This parameter must be >= 1.0. (Default 40.0). required Returns: Name Type Description f_idx a (m,)-shaped array of face indices into f where m is the number of Poisson-disk samples bc a (m, 3)-shaped array of barycentric coordinates where m is the number of Poisson-disk samples point_cloud_utils . sample_mesh_random () builtin sample_mesh_random(v: numpy.ndarray, f: numpy.ndarray, num_samples: int, random_seed: int = 0) -> Tuple[object, object] Generate uniformly distributed random point samples on a mesh Parameters: Name Type Description Default v (#v, 3)-shaped array of mesh vertex positions required f (#f, 3)-shaped array of mesh face indices required num_samples The number of samples to generate required random_seed A random seed used to generate the samples. Passing in 0 will use the current time. (0 by default). required Returns: Name Type Description f_idx (num_samples,) shaped array of face indices into f where bc (num_samples, 3) shaped array of barycentric coordinates point_cloud_utils . save_mesh_v ( filename , v , dtype = np . float32 ) Save a point cloud consisting only of vertex positions. Point Cloud Utils currently supports PLY, OBJ, STL, OFF, VRML 2.0, X3D, COLLADA, 3DS. Parameters: Name Type Description Default filename Path to the file to be saved. Must have a valid extension. required v An (n, 3)-shaped numpy array of coordinates required dtype The floating point written to the file ( np.float32 or np.float64 ) np.float32 point_cloud_utils . save_mesh_vc ( filename , v , c , dtype = np . float32 ) Save a point cloud consisting of vertex positions and vertex colors. Point Cloud Utils currently supports PLY, OBJ, STL, OFF, VRML 2.0, X3D, COLLADA, 3DS. Parameters: Name Type Description Default filename Path to the file to be saved. Must have a valid extension. required v An (n, 3)-shaped numpy array of coordinates required c An (n, 3)-shaped or (n, 4)-shaped numpy array of per-vertex RGB or RGBA colors (from 0.0 to 1.0) required dtype The floating point written to the file ( np.float32 or np.float64 ) np.float32 point_cloud_utils . save_mesh_vf ( filename , v , f , dtype = np . float32 ) Save a triangle mesh consisting of vertex positions and face indices. Point Cloud Utils currently supports PLY, OBJ, STL, OFF, VRML 2.0, X3D, COLLADA, 3DS. Parameters: Name Type Description Default filename Path to the file to be saved. Must have a valid extension. required v An (n, 3)-shaped numpy array of coordinates required f An (m, 3)-shaped integer numpy array of face indices into v required dtype The floating point written to the file ( np.float32 or np.float64 ) np.float32 point_cloud_utils . save_mesh_vfn ( filename , v , f , n , dtype = np . float32 ) Save a triangle mesh consisting of vertex positions, face indices, and vertex normals. Point Cloud Utils currently supports PLY, OBJ, STL, OFF, VRML 2.0, X3D, COLLADA, 3DS. Parameters: Name Type Description Default filename Path to the file to be saved. Must have a valid extension. required v An (n, 3)-shaped numpy array of coordinates required f An (m, 3)-shaped integer numpy array of face indices into v required n An (n, 3)-shaped numpy array of per-vertex normals required dtype The floating point written to the file ( np.float32 or np.float64 ) np.float32 point_cloud_utils . save_mesh_vfnc ( filename , v , f , n , c , dtype = np . float32 ) Save a triangle mesh consisting of vertex positions, face indices, vertex normals, and vertex colors. Point Cloud Utils currently supports PLY, OBJ, STL, OFF, VRML 2.0, X3D, COLLADA, 3DS. Parameters: Name Type Description Default filename Path to the file to be saved. Must have a valid extension. required v An (n, 3)-shaped numpy array of coordinates required f An (m, 3)-shaped integer numpy array of face indices into v required n An (n, 3)-shaped numpy array of per-vertex normals required c An (n, 3)-shaped or (n, 4)-shaped numpy array of per-vertex RGB or RGBA colors (from 0.0 to 1.0) required dtype The floating point written to the file ( np.float32 or np.float64 ) np.float32 point_cloud_utils . save_mesh_vn ( filename , v , n , dtype = np . float32 ) Save a point cloud consisting of vertex positions and vertex normals. Point Cloud Utils currently supports PLY, OBJ, STL, OFF, VRML 2.0, X3D, COLLADA, 3DS. Parameters: Name Type Description Default filename Path to the file to be saved. Must have a valid extension. required v An (n, 3)-shaped numpy array of coordinates required n An (n, 3)-shaped numpy array of per-vertex normals required dtype The floating point written to the file ( np.float32 or np.float64 ) np.float32 point_cloud_utils . save_mesh_vnc ( filename , v , n , c , dtype = np . float32 ) Save a point cloud consisting of vertex positions, vertex normals, and vertex colors. Point Cloud Utils currently supports PLY, OBJ, STL, OFF, VRML 2.0, X3D, COLLADA, 3DS. Parameters: Name Type Description Default filename Path to the file to be saved. Must have a valid extension. required v An (n, 3)-shaped numpy array of coordinates required n An (n, 3)-shaped numpy array of per-vertex normals required c An (n, 3)-shaped or (n, 4)-shaped numpy array of per-vertex RGB or RGBA colors (from 0.0 to 1.0) required dtype The floating point written to the file ( np.float32 or np.float64 ) np.float32 point_cloud_utils . save_triangle_mesh ( filename , v , f = None , vn = None , vt = None , vc = None , vq = None , vr = None , vti = None , vflags = None , fn = None , fc = None , fq = None , fflags = None , wc = None , wn = None , wt = None , wti = None , textures = [], normal_maps = [], dtype = np . float32 ) Save a triangle mesh to a file with various per-vertex, per-face, and per-wedge attributes. Each argument (except v) is optional and can be None. Parameters: Name Type Description Default filename Path to the mesh to save. The type of file will be determined from the file extension. required v [V, 3]-shaped numpy array of per-vertex positions required f [F, 3]-shaped numpy array of integer face indices into TrianglMesh.vertex_data.positions (or None) None vn [V, 3]-shaped numpy array of per-vertex normals (or None) None vt [V, 2]-shaped numpy array of per-vertex uv coordinates (or None) None vc [V, 4]-shaped numpy array of per-vertex RBGA colors in [0.0, 1.0] (or None) None vq [V,]-shaped numpy array of per-vertex quality measures (or None) None vr [V,]-shaped numpy array of per-vertex curvature radii (or None) None vti [V,]-shaped numpy array of integer indices into TriangleMesh.textures indicating which texture to use at this vertex (or None) None vflags [V,]-shaped numpy array of 32-bit integer flags per vertex (or None) None fn [F, 3]-shaped numpy array of per-face normals (or None) None fc [F, 4]-shaped numpy array of per-face RBGA colors in [0.0, 1.0] (or None) None fq [F,]-shaped numpy array of per-face quality measures (or None) None fflags [F,]-shaped numpy array of 32-bit integer flags per face (or None) None wc [F, 3, 4]-shaped numpy array of per-wedge RBGA colors in [0.0, 1.0] (or None) None wn [F, 3, 3]-shaped numpy array of per-wedge normals (or None) None wt [F, 3, 2]-shaped numpy array of per-wedge] uv coordinates (or None) None wti [F, 3]-shaped numpy array of integer indices into TriangleMesh.textures indicating which None textures A list of paths to texture image files for this mesh [] normal_maps A list of paths to texture image files for this mesh [] dtype The floating point written to the file ( np.float32 or np.float64 ) np.float32 point_cloud_utils . signed_distance_to_mesh () builtin signed_distance_to_mesh(p: numpy.ndarray, v: numpy.ndarray, f: numpy.ndarray, lower_bound: float = -inf, upper_bound: float = inf) -> Tuple[object, object, object] Computes signed distances of a point cloud with respect to a Mesh using Fast Winding Numbers Parameters: Name Type Description Default p (#p, 3)-shaped array point cloud (one 3D point per row) required v (#v, 3)-shaped array of mesh vertex positions (one vertex position per row) required f (#f, 3)-shaped array of mesh face indexes into v (a row (fi, fj, fk) indicate the 3 vertices of a face) required lower_bound The minimum distance value possible (use this to clamp SDF values). negative infinite by default required upper_bound The maximum distance value possible (use this to clamp SDF values). negative infinite by default required Returns: Name Type Description s a (#p,) shaped array of signed distance values for each query point in p fi a (#p,) shaped array of indices to the closest face for each query point in p bc a (#p, 3) shaped array of barycentric coordinates for the closest point on the mesh to each query point in p point_cloud_utils . sinkhorn ( a , b , M , eps , max_iters = 100 , stop_thresh = 0.001 ) Compute the (batched) Sinkhorn correspondences between two dirac delta distributions, U, and V. This implementation is numerically stable with float32. Parameters: Name Type Description Default a A m-sized minibatch of weights for each dirac in the first distribution, U. i.e. shape = (m, n) required b A m-sized minibatch of weights for each dirac in the second distribution, V. i.e. shape = (m, n) required M A minibatch of n-by-n tensors storing the distance between each pair of diracs in U and V. i.e. shape = (m, n, n) and each i.e. M[k, i, j] = ||u[k,_i] - v[k, j]|| required eps The reciprocal of the sinkhorn regularization parameter required max_iters The maximum number of Sinkhorn iterations 100 stop_thresh Stop if the change in iterates is below this value 0.001 Returns: Name Type Description P An (m, n, n)-shaped array of correspondences between distributions U and V point_cloud_utils . sparse_voxel_grid_boundary () builtin sparse_voxel_grid_boundary(grid_coordinates: numpy.ndarray) -> object point_cloud_utils . sparse_voxel_grid_from_pointcloud ( points , voxel_size , origin = ( 0.0 , 0.0 , 0.0 )) Construct a sparse voxel grid containing a point cloud, optionally returning the voxel index for each point. Parameters: Name Type Description Default points An (n, 3) shaped array of points (one per row) required voxel_size Either a scalar representing the sidelength of a voxel or a triple representing the sidelength of a voxel along each axis. required origin The origin of the point cloud corresponding to the bottom, back, left corner of the (0, 0, 0) voxel. (0.0, 0.0, 0.0) Returns: Name Type Description grid_coordinates An (n, 3)-shaped array of integer grid coordinates corresponding to voxels in the sparse grid point_to_vox_idx An (#points,)-shaped array where the i^th entry point_to_vox_idx[i] is the index into grid_coordinates of of the voxel containing points[i] point_cloud_utils . sparse_voxel_grid_to_hex_mesh ( grid_coordinates , voxel_size = 1.0 , origin = ( 0.0 , 0.0 , 0.0 ), dtype = np . float64 ) Convert a sparse voxel grid where the voxel indices represent the centers of each voxel coordinate into a hexahedral mesh. i.e. a pair of arrays (v, c) where v has shape (n, 3) and each row is a vertex position and c has shape (m, 8) where the i^th row c[i, :] are the indices into v of the 8 corners of the i^th cube Parameters: Name Type Description Default grid_coordinates An (n, 3) shaped integer array of voxels coordinates in the sparse voxel grid required voxel_size Either a scalar encoding the length of one voxel along an axis or a triple encoding the length of a voxel on each of 3 axes 1.0 origin A triple encoding a global offset for the hex mesh (i.e. all vertices will have origin added to them). Default is (0.0, 0.0, 0.0). (0.0, 0.0, 0.0) dtype The scalar type of vertices to return. Default is np.float64. np.float64 Returns: Name Type Description vertices An (n, 3) shaped array where each row vertices[i, :] is a vertex position in the hex mesh cubes An (m, 8) shaped array of indices into v where each row cubes[j, :] are indices of the 8 points forming the j^th cube point_cloud_utils . subdivide_sparse_voxel_grid ( grid_coordinates , num_subdivs = 1 ) Subdivide a sparse voxel grid such that every subdivision round splits each voxel into 8 subvoxels. Parameters: Name Type Description Default grid_coordinates An (n, 3) shaped integer array of voxels coordinates in the sparse voxel grid required num_subdivs The number of subdivision iterations to perform 1 An (m, 3) shaped array containing (fractional) coordinates representing the subdivided grid voxel grid. To convert to integer coordinates you can run: integer_grid_coords = quantize_subdivided_sparse_voxel_grid(num_subdivs) point_cloud_utils . surfel_geometry ( p , n , r = 0.1 , subdivs = 7 ) Generate geometry for a point cloud encoded as surfels (i.e. circular patches centered at each point and oriented perpendicularly to each normal) Parameters: Name Type Description Default p #p by 3 array of vertex positions (each row is a vertex) required n #p by 3 array of vertex normals (each row is a vertex) required r Array or Scalar describing the size of each geometry element (Either one radius per vertex, or a global size for the whole point cloud) 0.1 subdivs Number of times to subdivide the patch geometry for each point (i.e. # tris per cicle) 7 Returns: Name Type Description verts an array of shape (#output_vertices, 3) faces an array of shape (#output_faces, 3) indexing into verts point_cloud_utils . triangle_soup_fast_winding_number () builtin triangle_soup_fast_winding_number(v: numpy.ndarray, f: numpy.ndarray, p: numpy.ndarray) -> object Compute a consistent inside/outside field given a triangle soup and evaluate that field at a set of query points Parameters: Name Type Description Default v (#v, 3)-shaped array of mesh vertex positions (one vertex position per row) required f (#f, 3)-shaped array of mesh face indexes into v (a row (fi, fj, fk) indicate the 3 vertices of a face) required q (#q, 3)-shaped array of query positions at which to evaluat the winding number field required Returns: Type Description A (#q,)-shaped array with a sign value for each query point (positive for outside and negative for inside) point_cloud_utils . unquantize_subdivided_sparse_voxel_grid ( quantized_grid_coordinates , num_subdivs ) Undo quantization done by quantize_subdivided_sparse_voxel_grid. Parameters: Name Type Description Default quantized_grid_coordinates An (n, 3) shaped array of quantized voxels coordinates returned by quantize_subdivided_sparse_voxel_grid required num_subdivs The number of subdivision iterations used to compute the original fractional coordinates required Returns: Name Type Description fractional_grid_coordinates An (n, 3) shaped array of fractional grid coordinates See Also subdivide_sparse_voxel_grid quantize_subdivided_sparse_voxel_grid point_cloud_utils . voronoi_centroids_unit_cube () builtin voronoi_centroids_unit_cube(centers: numpy.ndarray) -> object Generate n samples in the unit cube, [0, 1]^3 using Lloyd's algorithm (https://en.wikipedia.org/wiki/Lloyd%27s_algorithm). Parameters: Name Type Description Default n The number of 3d point samples to generate required num_lloyd The number of Lloyd iterations to do (default 10) required num_newton The number of Newton iterations to do when computing Voronoi diagrams (default 10) required Returns: Name Type Description lloyd_pts a (n, 3)-shaped array of point samples in the unit square [0, 1]^3","title":"API Reference"},{"location":"sections/api_reference/#api-reference","text":"","title":"API Reference"},{"location":"sections/api_reference/#point_cloud_utils.RayMeshIntersector","text":"Class used to find the intersection between rays and a triangle mesh.","title":"RayMeshIntersector"},{"location":"sections/api_reference/#point_cloud_utils._ray_mesh_intersector.RayMeshIntersector.__init__","text":"Create a RayMeshIntersector object which can be used to do ray/mesh queries with a triangle mesh. Parameters: Name Type Description Default mesh_v #v by 3 array of vertex positions (each row is a vertex) required mesh_f #f by 3 Matrix of face (triangle) indices required","title":"__init__()"},{"location":"sections/api_reference/#point_cloud_utils._ray_mesh_intersector.RayMeshIntersector.intersect_rays","text":"Compute intersection between a set of rays and the triangle mesh enclosed in this class Parameters: Name Type Description Default ray_o array of shape (#rays, 3) of ray origins (one per row) or a single array of shape (3,) to use required ray_d array of shape (#rays, 3) of ray directions (one per row) required ray_near an optional floating point value indicating the distance along each ray to start searching (default 0.0) 0.0 ray_far an optional floating point value indicating the maximum distance along each ray to search (default inf) np.inf Returns: Name Type Description f_id an array of shape (#rays,) representing the face id hit by each ray bc an array of shape (#rays, 3) where each row is the barycentric coordinates within each face of the ray intersection t the distance along each ray to the intersection","title":"intersect_rays()"},{"location":"sections/api_reference/#point_cloud_utils.RaySurfelIntersector","text":"Class used to find the intersection between rays and a point cloud converted to surfels (i.e. a point cloud represented as circles centered at each point and oriented perpendicularly to each normal).","title":"RaySurfelIntersector"},{"location":"sections/api_reference/#point_cloud_utils._ray_point_cloud_intersector.RaySurfelIntersector.__init__","text":"Construct a RayPointCloudIntersector which can be used to compute the intersection between a set of rays and a point cloud converted to circular patches oriented with the point normals Parameters: Name Type Description Default p #p by 3 array of vertex positions (each row is a vertex) required n #p by 3 Matrix of vertex normals (each row is a vertex) required r Array or Scalar describing the size of each geometry element (Either one radius per vertex, or a global size for the whole point cloud) 0.1 subdivs Number of times to subdivide the patch geometry for each point (i.e. # tris per cicle) 7","title":"__init__()"},{"location":"sections/api_reference/#point_cloud_utils._ray_point_cloud_intersector.RaySurfelIntersector.intersect_rays","text":"Compute intersection between a set of rays and the point cloud converted to circular patches oriented with the point normals Parameters: Name Type Description Default ray_o array of shape (#rays, 3) of ray origins (one per row) or a single array of shape (3,) to use required ray_d array of shape (#rays, 3) of ray directions (one per row) required ray_near an optional floating point value indicating the distance along each ray to start searching (default 0.0) 0.0 ray_far an optional floating point value indicating the maximum distance along each ray to search (default inf) np.inf Returns: Name Type Description t a (#rays,) shaped array encoding the distance between the ray origin and intersection point for each ray (inf for missed rays) pid a (#rays,) shaped array of integer indices corresponding to which points were hit (-1 for a ray miss)","title":"intersect_rays()"},{"location":"sections/api_reference/#point_cloud_utils.TriangleMesh","text":"A lightweight container class representing a triangle mesh with attributes stored at each vertex, wedge, and face, where: A vertex is a 3D position A wedge is a vertex and its two adjacent edges A face is a triangle connecting 3 vertices (Each triangle has 3 vertices and 3 wedges). The data in encapsulated into vertex data and face data, accessible via TriangleMes.vertex_data and TriangleMesh.face_data respectively: TriangleMesh.vertex_data : positions : [V, 3]-shaped numpy array of per-vertex positions normals : [V, 3]-shaped numpy array of per-vertex normals (or None) texcoords : [V, 2]-shaped numpy array of per-vertex uv coordinates (or None) tex_ids : [V,]-shaped numpy array of integer indices into TriangleMesh.textures indicating which texture to use at this vertex (or None) colors : [V, 4]-shaped numpy array of per-vertex RBGA colors in [0.0, 1.0] (or None) radius : [V,]-shaped numpy array of per-vertex curvature radii (or None) quality : [V,]-shaped numpy array of per-vertex quality measures (or None) flags : [V,]-shaped numpy array of 32-bit integer flags per vertex (or None) TriangleMesh.face_data : vertex_ids : [F, 3]-shaped numpy array of integer face indices into TrianglMesh.vertex_data.positions normals : [F, 3]-shaped numpy array of per-face normals (or None) colors : [F, 4]-shaped numpy array of per-face RBGA colors in [0.0, 1.0] (or None) quality : [F,]-shaped numpy array of per-face quality measures (or None) flags : [F,]-shaped numpy array of 32-bit integer flags per face (or None) wedge_colors : [F, 3, 4]-shaped numpy array of per-wedge RBGA colors in [0.0, 1.0] (or None) wedge_normals : [F, 3, 3]-shaped numpy array of per-wedge normals (or None) wedge_texcoords : [F, 3, 2]-shaped numpy array of per-wedge] uv coordinates (or None) wedge_tex_ids : [F, 3]-shaped numpy array of integer indices into TriangleMesh.textures indicating which texture to use at this wedge (or None) textures : A list of paths to texture image files for this mesh normal_maps : A list of paths to texture image files for this mesh","title":"TriangleMesh"},{"location":"sections/api_reference/#point_cloud_utils._mesh_io.TriangleMesh.f","text":"An (m, 3)-shaped integer array containing this mesh's face indices (None if no faces)","title":"f"},{"location":"sections/api_reference/#point_cloud_utils._mesh_io.TriangleMesh.fc","text":"An (m, 4)-shaped array containing this mesh's per-face RBGA colors (None if no face colors)","title":"fc"},{"location":"sections/api_reference/#point_cloud_utils._mesh_io.TriangleMesh.fn","text":"An (m, 3)-shaped array containing this mesh's per-face normals (None if no face normals)","title":"fn"},{"location":"sections/api_reference/#point_cloud_utils._mesh_io.TriangleMesh.v","text":"An (n, 3)-shaped array containing this mesh's vertex positions","title":"v"},{"location":"sections/api_reference/#point_cloud_utils._mesh_io.TriangleMesh.vc","text":"An (n, 4)-shaped array containing this mesh's per-vertex RGBA (None if no vertex colors)","title":"vc"},{"location":"sections/api_reference/#point_cloud_utils._mesh_io.TriangleMesh.vn","text":"An (n, 3)-shaped array containing this mesh's per-vertex normals (None if no vertex normals)","title":"vn"},{"location":"sections/api_reference/#point_cloud_utils._mesh_io.TriangleMesh.FaceData","text":"A lightweight container class representing per-face information within a TriangleMesh with the following attributes vertex_ids : [F, 3]-shaped numpy array of integer face indices into TrianglMesh.vertex_data.positions normals : [F, 3]-shaped numpy array of per-face normals (or None) colors : [F, 4]-shaped numpy array of per-face RBGA colors in [0.0, 1.0] (or None) quality : [F,]-shaped numpy array of per-face quality measures (or None) flags : [F,]-shaped numpy array of 32-bit integer flags per face (or None) wedge_colors : [F, 3, 4]-shaped numpy array of per-wedge RBGA colors in [0.0, 1.0] (or None) wedge_normals : [F, 3, 3]-shaped numpy array of per-wedge normals (or None) wedge_texcoords : [F, 3, 2]-shaped numpy array of per-wedge] uv coordinates (or None) wedge_tex_ids : [F, 3]-shaped numpy array of integer indices into TriangleMesh.textures indicating which texture to use at this wedge (or None) textures : A list of paths to texture image files for this mesh normal_maps : A list of paths to texture image files for this mesh","title":"FaceData"},{"location":"sections/api_reference/#point_cloud_utils._mesh_io.TriangleMesh.VertexData","text":"A lightweight container class representing per-vertex information within a TriangleMesh with the following attributes positions : [V, 3]-shaped numpy array of per-vertex positions normals : [V, 3]-shaped numpy array of per-vertex normals (or None) texcoords : [V, 2]-shaped numpy array of per-vertex uv coordinates (or None) tex_ids : [V,]-shaped numpy array of integer indices into TriangleMesh.textures indicating which texture to use at this vertex (or None) colors : [V, 4]-shaped numpy array of per-vertex RBGA colors in [0.0, 1.0] (or None) radius : [V,]-shaped numpy array of per-vertex curvature radii (or None) quality : [V,]-shaped numpy array of per-vertex quality measures (or None) flags : [V,]-shaped numpy array of 32-bit integer flags per vertex (or None)","title":"VertexData"},{"location":"sections/api_reference/#point_cloud_utils._mesh_io.TriangleMesh.load","text":"Load a mesh into this class from a file. The type of file is determined by the extension. Point Cloud Utils currently supports PLY, OBJ, STL, OFF, VRML 2.0, X3D, COLLADA, 3DS. Parameters: Name Type Description Default filename Path to the file to be loaded. Must have a valid extension. required dtype Type to save floating point data in (defaults to np.float32) np.float64","title":"load()"},{"location":"sections/api_reference/#point_cloud_utils._mesh_io.TriangleMesh.save","text":"Save this mesh to a file. The type of file is determined by the extension. Point Cloud Utils currently supports PLY, OBJ, STL, OFF, VRML 2.0, X3D, COLLADA, 3DS. Parameters: Name Type Description Default filename Path to the file to be saved. Must have a valid extension. required dtype Type to save floating point data in (defaults to np.float32) np.float32","title":"save()"},{"location":"sections/api_reference/#point_cloud_utils.chamfer_distance","text":"Compute the chamfer distance between two point clouds x, and y Parameters: Name Type Description Default x A m-sized minibatch of point sets in R^d. i.e. shape [m, n_a, d] required y A m-sized minibatch of point sets in R^d. i.e. shape [m, n_b, d] required return_index If set to True, will return a pair (corrs_x_to_y, corrs_y_to_x) where corrs_x_to_y[i] stores the index into y of the closest point to x[i] (i.e. y[corrs_x_to_y[i]] is the nearest neighbor to x[i] in y). corrs_y_to_x is similar to corrs_x_to_y but with x and y reversed. False max_points_per_leaf The maximum number of points per leaf node in the KD tree used by this function. Default is 10. 10 p_norm Which norm to use. p_norm can be any real number, inf (for the max norm) -inf (for the min norm), 0 (for sum(x != 0)) 2 Returns: Type Description The chamfer distance between x an dy. If return_index is set, then this function returns a tuple (chamfer_dist, corrs_x_to_y, corrs_y_to_x) where corrs_x_to_y and corrs_y_to_x are described above.","title":"chamfer_distance()"},{"location":"sections/api_reference/#point_cloud_utils.closest_points_on_mesh","text":"closest_points_on_mesh(p: numpy.ndarray, v: numpy.ndarray, f: numpy.ndarray) -> Tuple[object, object, object] Compute distances from a set of points p to a triangle mesh (v, f) Parameters: Name Type Description Default p (#p, 3)-shaped array of query point positions required v (#v, 3)-shaped array of mesh vertex positions required f (#f, 3)-shaped array of triangle face indices required Returns: Name Type Description d a (#p,)-shaped array of shortest distances for each query point p f_idx a (#p,)-shaped array of indices into f of the face containing the closest point to eaach query point bc a (#p, 3)-shaped array of barycentric coordinates for each query point Notes Known bugs: This only computes distances to given primitives. So unreferenced vertices are ignored. However, degenerate primitives are handled correctly: triangle [1 2 2] is treated as a segment [1 2], and triangle [1 1 1] is treated as a point. So one could add extra combinatorially degenerate rows to Ele for all unreferenced vertices to also get distances to points.","title":"closest_points_on_mesh()"},{"location":"sections/api_reference/#point_cloud_utils.connected_components","text":"connected_components(v: numpy.ndarray, f: numpy.ndarray) -> Tuple[object, object, object, object] Determine the connected components of a mesh Parameters: Name Type Description Default v (#v, 3)-shaped array of mesh vertex positions (one vertex position per row) required f (#f, 3)-shaped array of mesh face indexes into v (a row (fi, fj, fk) indicate the 3 vertices of a face) required Returns: Name Type Description cv a (#vertices,)-shaped array of integer indexes (starting from 0) indicating which component each vertex belongs to. i.e. cv[i] is the component of the vertex v[i]. nv the number of vertices in each connected component. i.e. nv[j] is the number of vertices in component j cf a (#faces,)-shaped array of integer indexes (starting from 0) indicating which component each face belongs to. i.e. cf[i] is the component of the face f[i]. nf the number of faces in each connected component. i.e. nf[j] is the number of faces in component j","title":"connected_components()"},{"location":"sections/api_reference/#point_cloud_utils.decimate_triangle_mesh","text":"decimate_triangle_mesh(v: numpy.ndarray, f: numpy.ndarray, max_faces: int, decimation_heuristic: str = 'shortest_edge') -> Tuple[object, object, object, object] Decimate a (manifold) triangle mesh by collapsing edges Parameters: Name Type Description Default v (#v, 3)-shaped array of mesh vertex positions required f (#f, 3)-shaped array of triangle face indices required max_faces The maximum number of faces in the decimated output mesh (must be between 0 and #f) required decimation_heuristic Which decimation heuristic to use. Currently only supports \"shortest_edge\". required Returns: Name Type Description v_out (#v_out, 3)-shaped array of vertex positions for the decimated mesh f_out (#f_out, 3)-shaped array of triangle face indices for the decimated mesh v_correspondences (#v_out, 1)-shaped array where v_correspondences[i] is the index of the vertex in v which generated v_out[i] f_correspondences (#f_out, 1)-shaped array where f_correspondences[i] is the index of the face in f which generated f_out[i]","title":"decimate_triangle_mesh()"},{"location":"sections/api_reference/#point_cloud_utils.deduplicate_mesh_vertices","text":"deduplicate_mesh_vertices(v: numpy.ndarray, f: numpy.ndarray, epsilon: float, return_index: bool = True) -> object Removes duplicated vertices from a triangle mesh two vertices are considered the same if their distance is below some threshold Parameters: Name Type Description Default v #v by 3 Matrix of mesh vertex 3D positions required f #f by 3 Matrix of face (triangle) indices required epsilon threshold below which two points are considered equal required return_index If true, return indices to map between input and output required Returns: Name Type Description x_new #x_new x 3 Point cloud with duplicates removed svi #x x 1 indices so that x_new = x[svi] (only returned if return_index is True) svj #x_new x 1 indices so that x = x_new[svj] (only returned if return_index is True) See also deduplicate_point_cloud","title":"deduplicate_mesh_vertices()"},{"location":"sections/api_reference/#point_cloud_utils.deduplicate_point_cloud","text":"deduplicate_point_cloud(points: numpy.ndarray, epsilon: float, return_index: bool = True) -> object Removes duplicated points from a point cloud where two points are considered the same if their distance is below some threshold Parameters: Name Type Description Default x #x by 3 Matrix of 3D positions required epsilon threshold below which two points are considered equal required return_index If true, return indices to map between input and output required Returns: Name Type Description x_new #x_new x 3 Point cloud with duplicates removed if return indices is set, this function also returns: svi : #x x 1 indices so that x_new = x[svi] svj : #x_new x 1 indices so that x = x_new[svj] See also deduplicate_mesh_vertices","title":"deduplicate_point_cloud()"},{"location":"sections/api_reference/#point_cloud_utils.dilate_sparse_voxel_grid","text":"Perform binary dilation on a sparse voxel grid, using a 3x3 filter of ones applied count times. i.e. convolve the filter: [[1, 1, 1], [1, 1, 1], [1, 1, 1]] with the sparse voxel grid. Parameters: Name Type Description Default grid_coordinates An (n, 3) shaped integer array of voxels coordinates in the sparse voxel grid required count The number of iterations of binary dilation to run 1 Returns: Name Type Description dilated_grid_coordinates An (m, 3) integer array encoding the coordinates of the sparse voxel grid after dilation","title":"dilate_sparse_voxel_grid()"},{"location":"sections/api_reference/#point_cloud_utils.downsample_point_cloud_on_voxel_grid","text":"Downsample a point set to conform with a voxel grid by taking the average of points within each voxel. Parameters: Name Type Description Default voxel_size a scalar representing the size of each voxel or a 3 tuple representing the size per axis of each voxel. required points a [#v, 3]-shaped array of 3d points. required *args Any additional arguments of shape [#v, *] are treated as attributes and will averaged into each voxel along with the points These will be returns () min_bound a 3 tuple representing the minimum coordinate of the voxel grid or None to use the bounding box of the input point cloud. None max_bound a 3 tuple representing the maximum coordinate of the voxel grid or None to use the bounding box of the input point cloud. None min_points_per_voxel If a voxel contains fewer than this many points, then don't include the points in that voxel in the output. 1 Returns: Type Description A tuple (v, attrib0, attrib1, ....) of downsampled points, and point attributes. Attributes are returned in the same order they are passed in. If no attributes are passed in, then this function simply returns vertices.","title":"downsample_point_cloud_on_voxel_grid()"},{"location":"sections/api_reference/#point_cloud_utils.downsample_point_cloud_poisson_disk","text":"downsample_point_cloud_poisson_disk(v: numpy.ndarray, num_samples: int, radius: float = 0.0, best_choice_sampling: bool = True, random_seed: int = 0, sample_num_tolerance: float = 0.04) -> object Downsample a point set so that samples are approximately evenly spaced. This function uses the method in \"Parallel Poisson Disk Sampling with Spectrum Analysis on Surface\" (http://graphics.cs.umass.edu/pubs/sa_2010.pdf) Parameters: Name Type Description Default v #v by 3 array of vertex positions required n #v by 3 array of vertex normals required num_samples desired number of Poisson Disk samples. Note that the actual number of returned samples will not be exactly this value (see sample_num_tolerance) to control the range of possible returned samples. Note: If this value <= 0, then the parameter radius is used to decide the number of samples required radius desired separation between points, if num_samples <= 0, then this value is used to determine the sampling (-1.0, by default). required best_choice_sampling When downsampling, always keep the sample that will remove the fewest number of samples. (True by default). required random_seed A random seed used to generate the samples. Passing in 0 will use the current time. (0 by default). required sample_num_tolerance If you requested a target number of samples, by passsing num_samples > 0, then this function will return between (1 - sample_num_tolerance) * num_samples and (1 + sample_num_tolerance) * num_samples. Setting a very small value for this parameter will increase convergence time. (0.04 by default). required Returns: Name Type Description p_idx A (m,) shaped array of indices into v where m is the number of Poisson-disk samples","title":"downsample_point_cloud_poisson_disk()"},{"location":"sections/api_reference/#point_cloud_utils.earth_movers_distance","text":"Compute the (batched) Sinkhorn correspondences between two dirac delta distributions, U, and V. This implementation is numerically stable with float32. Parameters: Name Type Description Default p An (n, d)-shaped array of d-dimensional points required b An (m, d)-shaped array of d-dimensional points required p_norm Which norm to use. Must be one of {non-zero int, inf, -inf, \u2018fro\u2019, \u2018nuc\u2019} (default is 2), 2 eps The reciprocal of the sinkhorn regularization parameter (default 1e-4) 0.0001 max_iters The maximum number of Sinkhorn iterations 100 stop_thresh Stop if the change in iterates is below this value 0.001 Returns: Name Type Description emd The earth mover's distance between point clouds p and q P An (n, m)-shaped array of correspondences between point clouds p and q","title":"earth_movers_distance()"},{"location":"sections/api_reference/#point_cloud_utils.erode_sparse_voxel_grid","text":"Perform binary erosion on a sparse voxel grid, using a 3x3 filter of ones applied count times. i.e. take the negation of the convolution of the filter: [[1, 1, 1], [1, 1, 1], [1, 1, 1]] with the sparse voxel grid. Parameters: Name Type Description Default grid_coordinates An (n, 3) shaped integer array of voxels coordinates in the sparse voxel grid required count The number of iterations of binary erosion to run 1 Returns: Name Type Description eroded_grid_coordinates An (m, 3) integer array encoding the coordinates of the sparse voxel grid after erosion","title":"erode_sparse_voxel_grid()"},{"location":"sections/api_reference/#point_cloud_utils.estimate_mesh_face_normals","text":"estimate_mesh_face_normals(v: numpy.ndarray, f: numpy.ndarray) -> object Compute vertex normals of a mesh from its vertices and faces using face area weighting Parameters: Name Type Description Default v (#v, 3)-shaped NumPy array of mesh vertex 3D positions required f (#f, 3)-shaped NumPy array of face (triangle) indices required Returns: Name Type Description n (#f, 3)-shaped NumPy array of face normals (i.e. n[i] is the normal at face f[i]). Note that any degenerate faces will have a zero normal.","title":"estimate_mesh_face_normals()"},{"location":"sections/api_reference/#point_cloud_utils.estimate_mesh_vertex_normals","text":"estimate_mesh_vertex_normals(v: numpy.ndarray, f: numpy.ndarray, weighting_type: str = 'uniform') -> object Compute vertex normals of a mesh from its vertices and faces using face area weighting Parameters: Name Type Description Default v (#v, 3)-shaped NumPy array of mesh vertex 3D positions required f (#f, 3)-shaped NumPy array of face (triangle) indices required weighting_type Weighting type must be one of 'uniform', 'angle', or 'area' (default is 'uniform') required Returns: Name Type Description n (#v, 3)-shaped NumPy array of vertex normals (i.e. n[i] is the normal at vertex v[i]) estimate_mesh_face_normals","title":"estimate_mesh_vertex_normals()"},{"location":"sections/api_reference/#point_cloud_utils.estimate_point_cloud_normals_ball","text":"Estimate normals for a point cloud by locally fitting a plane to all points within a radius of each point (possibly weighted by a radial basis function). This function can optionally consider directions to the sensor for each point to compute neighborhoods of points which are all facing the same direction, and align the final normal directions. Parameters: Name Type Description Default points (n, 3)-shaped NumPy array of point positions (each row is a point) required ball_radius The radius of each neighborhood used to estimate normals required view_directions (n, 3)-shaped NumPy array or None, representing the unit direction to the sensor for each point. This parameter is used to align the normals and compute neighborhoods of similar facing points. None drop_angle_threshold If view_directions is passed in, drop points whose angle between the normal and view direction exceeds drop_angle_threshold (in radians). Useful for filtering out low quality points. np.deg2rad(90.0) min_pts_per_ball Discard points whose neighborhood contains fewer than min_pts_per_ball points. 3 max_pts_per_ball If set to a positive number, then only use max_pts_per_ball points within each neighborhood whose number of points exceeds this value. -1 weight_function Weighting function for points in a neighborhood. Must be one of 'constant' or 'rbf' where: 'constant' max_points_per_leaf Maximum number of points in each leaf node of the KD-tree used for nearest neighbor queries. Tuning this can potentially improve performance on large point clouds. 10 num_threads Number of threads used to parallelize computation. If set to 0 ir 1, will run in single threaded mode. If set to a positive number t > 1, will use t threads. If set to -1, will use #processors threads for inputs greater than 1 million points. -1 Returns: Name Type Description p an (m, 3)-shaped Numpy array of 3d points n an (m, 3)-shaped Numpy array of unit normals for each point in p See Also estimate_pointcloud_normals_ball","title":"estimate_point_cloud_normals_ball()"},{"location":"sections/api_reference/#point_cloud_utils.estimate_point_cloud_normals_knn","text":"Estimate normals for a point cloud by locally fitting a plane to the k nearest neighbors of each point. This function can optionally consider directions to the sensor for each point to compute neighborhoods of points which are all facing the same direction, and align the final normal directions. Parameters: Name Type Description Default points (n, 3)-shaped NumPy array of point positions (each row is a point) required num_neighbors Integer number of neighbors to use in each neigghborhood. required view_directions (n, 3)-shaped NumPy array or None, representing the unit direction to the sensor for each point. This parameter is used to align the normals and compute neighborhoods of similar facing points. None drop_angle_threshold If view_directions is passed in, drop points whose angle between the normal and view direction exceeds drop_angle_threshold (in radians). Useful for filtering out low quality points. np.deg2rad(90.0) max_points_per_leaf Maximum number of points in each leaf node of the KD-tree used for nearest neighbor queries. Tuning this can potentially improve performance on large point clouds. 10 num_threads Number of threads used to parallelize computation. If set to 0 ir 1, will run in single threaded mode. If set to a positive number t > 1, will use t threads. If set to -1, will use #processors threads for inputs greater than 1 million points. -1 Returns: Name Type Description idx an (m, 1)-shaped Numpy array of indices into points n an (m, 3)-shaped Numpy array of unit normals for each point in p See Also estimate_pointcloud_normals_ball","title":"estimate_point_cloud_normals_knn()"},{"location":"sections/api_reference/#point_cloud_utils.hausdorff_distance","text":"Compute the Hausdorff distance between x and y Parameters: Name Type Description Default x n by 3 array of representing a set of n points (each row is a point of dimension 3) required y m by 3 array of representing a set of m points (each row is a point of dimension 3) required return_index Optionally return the index pair (i, j) into x and y such that x[i, :] and y[j, :] are the two points with maximum shortest distance. False squared_distances If set to True, then return squared L2 distances. Default is False. False max_points_per_leaf The maximum number of points per leaf node in the KD tree used by this function. Default is 10. 10 Returns: Type Description The largest shortest distance, d between each point in source and the points in target . If return_index is set, then this function returns a tuple (d, i, j) where d is as described above and (i, j) are such that source[i, :] and target[j, :] are the two points with maximum shortest distance.","title":"hausdorff_distance()"},{"location":"sections/api_reference/#point_cloud_utils.interpolate_barycentric_coords","text":"Interpolate an attribute stored at each vertex of a mesh across the faces of a triangle mesh using barycentric coordinates Parameters: Name Type Description Default f a (#faces, 3)-shaped NumPy array of mesh faces (indexing into some vertex array). required fi a (#attribs,)-shaped NumPy array of indexes into f indicating which face each attribute lies within. required bc a (#attribs, 3)-shaped NumPy array of barycentric coordinates for each attribute required attribute a (#vertices, dim)-shaped NumPy array of attributes at each of the mesh vertices required Returns: Type Description A (#attribs, dim)-shaped array of interpolated attributes.","title":"interpolate_barycentric_coords()"},{"location":"sections/api_reference/#point_cloud_utils.k_nearest_neighbors","text":"k_nearest_neighbors(query_points: numpy.ndarray, dataset_points: numpy.ndarray, k: int, squared_distances: bool = False, max_points_per_leaf: int = 10, num_threads: int = -1) -> Tuple[object, object] Compute the k nearest neighbors (L2 distance) from each point in the query point cloud to the dataset point cloud. Parameters: Name Type Description Default query_points n by 3 array of representing a set of n points (each row is a point of dimension 3). required dataset_points m by 3 array of representing a set of m points (each row is a point of dimension 3). required k the number of nearest neighbors to query per point. required squared_distances If set to True, then return squared L2 distances. Default is False. required max_points_per_leaf The maximum number of points per leaf node in the KD tree used by this function. Default is 10. required num_threads Number of threads to use. If set to -1, will use all available CPUs. If set to 0, will run in serial. Default is -1. required Returns: Name Type Description dists An (n, k)-shaped array such that dists[i,k] contains the k^th shortest L2 distance from the point query_points[i, :] to dataset_points corrs An (n, k)-shaped array such that corrs[i,k] contains the index into dataset_points of the k^th nearest point to query_points[i, :]","title":"k_nearest_neighbors()"},{"location":"sections/api_reference/#point_cloud_utils.laplacian_smooth_mesh","text":"laplacian_smooth_mesh(v: numpy.ndarray, f: numpy.ndarray, num_iters: int, use_cotan_weights: bool = False) -> object Smooth a mesh using Laplacian smoothing Parameters: Name Type Description Default v #v by 3 Matrix of mesh vertex 3D positions required f #f by 3 Matrix of face (triangle) indices required num_iters Number of smoothing iterations required use_cotan_weights Whether to use cotagent weighting (False by default) required Returns: Name Type Description n list of vertex normals of shape #v by 3","title":"laplacian_smooth_mesh()"},{"location":"sections/api_reference/#point_cloud_utils.lloyd_2d","text":"lloyd_2d(n: int, num_lloyd: int = 10, num_newton: int = 10) -> object Generate n samples in the unit square, [0, 1]^2 using Lloyd's algorithm (https://en.wikipedia.org/wiki/Lloyd%27s_algorithm). Parameters: Name Type Description Default n The number of 2d point samples to generate required num_lloyd The number of Lloyd iterations to do (default 10) required num_newton The number of Newton iterations to do when computing Voronoi diagrams (default 10) required Returns: Name Type Description lloyd_points a (n, 2)-shaped array of point samples in the unit square [0, 1]^2","title":"lloyd_2d()"},{"location":"sections/api_reference/#point_cloud_utils.lloyd_3d","text":"lloyd_3d(n: int, num_lloyd: int = 10, num_newton: int = 10) -> object Generate n samples in the unit cube, [0, 1]^3 using Lloyd's algorithm (https://en.wikipedia.org/wiki/Lloyd%27s_algorithm). Parameters: Name Type Description Default n The number of 3d point samples to generate required num_lloyd The number of Lloyd iterations to do (default 10) required num_newton The number of Newton iterations to do when computing Voronoi diagrams (default 10) required Returns: Name Type Description lloyd_pts a (n, 3)-shaped array of point samples in the unit square [0, 1]^3","title":"lloyd_3d()"},{"location":"sections/api_reference/#point_cloud_utils.load_mesh_v","text":"Load a point cloud consisting only of vertex positions. Point Cloud Utils currently supports PLY, OBJ, STL, OFF, VRML 2.0, X3D, COLLADA, 3DS. Parameters: Name Type Description Default filename Path to the file to be loaded. Must have a valid extension. required dtype The floating point type of loaded data ( np.float32 or np.float64 ) float Returns: Name Type Description v An (n, 3)-shaped numpy array of coordinates","title":"load_mesh_v()"},{"location":"sections/api_reference/#point_cloud_utils.load_mesh_vc","text":"Load a point cloud consisting of vertex positions, and vertex colors. Point Cloud Utils currently supports PLY, OBJ, STL, OFF, VRML 2.0, X3D, COLLADA, 3DS. Parameters: Name Type Description Default filename Path to the file to be loaded. Must have a valid extension. required dtype The floating point type of loaded data ( np.float32 or np.float64 ) float Returns: Name Type Description v An (n, 3)-shaped numpy array of coordinates c An (n, 3)-shaped or (n, 4)-shaped numpy array of per-vertex RGB or RGBA colors (from 0.0 to 1.0)","title":"load_mesh_vc()"},{"location":"sections/api_reference/#point_cloud_utils.load_mesh_vf","text":"Load a triangle mesh consisting of vertex positions and face indices. Point Cloud Utils currently supports PLY, OBJ, STL, OFF, VRML 2.0, X3D, COLLADA, 3DS. Parameters: Name Type Description Default filename Path to the file to be loaded. Must have a valid extension. required dtype The floating point type of loaded data ( np.float32 or np.float64 ) float Returns: Name Type Description v An (n, 3)-shaped numpy array of coordinates f An (m, 3)-shaped integer numpy array of face indices into v","title":"load_mesh_vf()"},{"location":"sections/api_reference/#point_cloud_utils.load_mesh_vfn","text":"Load a triangle mesh consisting of vertex positions, face indices, and vertex normals. Point Cloud Utils currently supports PLY, OBJ, STL, OFF, VRML 2.0, X3D, COLLADA, 3DS. Parameters: Name Type Description Default filename Path to the file to be loaded. Must have a valid extension. required dtype The floating point type of loaded data ( np.float32 or np.float64 ) float Returns: Name Type Description v An (n, 3)-shaped numpy array of coordinates f An (m, 3)-shaped integer numpy array of face indices into v n An (n, 3)-shaped numpy array of per-vertex normals","title":"load_mesh_vfn()"},{"location":"sections/api_reference/#point_cloud_utils.load_mesh_vfnc","text":"Load a triangle mesh consisting of vertex positions, face indices, vertex normals, and vertex colors. Point Cloud Utils currently supports PLY, OBJ, STL, OFF, VRML 2.0, X3D, COLLADA, 3DS. Parameters: Name Type Description Default filename Path to the file to be loaded. Must have a valid extension. required dtype The floating point type of loaded data ( np.float32 or np.float64 ) float Returns: Name Type Description v An (n, 3)-shaped numpy array of coordinates f An (m, 3)-shaped integer numpy array of face indices into v n An (n, 3)-shaped numpy array of per-vertex normals c An (n, 3)-shaped or (n, 4)-shaped numpy array of per-vertex RGB or RGBA colors (from 0.0 to 1.0)","title":"load_mesh_vfnc()"},{"location":"sections/api_reference/#point_cloud_utils.load_mesh_vn","text":"Load a point cloud consisting of vertex positions, and vertex normals. Point Cloud Utils currently supports PLY, OBJ, STL, OFF, VRML 2.0, X3D, COLLADA, 3DS. Parameters: Name Type Description Default filename Path to the file to be loaded. Must have a valid extension. required dtype The floating point type of loaded data ( np.float32 or np.float64 ) float Returns: Name Type Description v An (n, 3)-shaped numpy array of coordinates n An (n, 3)-shaped numpy array of per-vertex normals","title":"load_mesh_vn()"},{"location":"sections/api_reference/#point_cloud_utils.load_mesh_vnc","text":"Load a point cloud consisting of vertex positions, vertex normals, and vertex colors. Point Cloud Utils currently supports PLY, OBJ, STL, OFF, VRML 2.0, X3D, COLLADA, 3DS. Parameters: Name Type Description Default filename Path to the file to be loaded. Must have a valid extension. required dtype The floating point type of loaded data ( np.float32 or np.float64 ) float Returns: Name Type Description v An (n, 3)-shaped numpy array of coordinates n An (n, 3)-shaped numpy array of per-vertex normals c An (n, 3)-shaped or (n, 4)-shaped numpy array of per-vertex RGB or RGBA colors (from 0.0 to 1.0)","title":"load_mesh_vnc()"},{"location":"sections/api_reference/#point_cloud_utils.load_triangle_mesh","text":"Load a triangle mesh into a TriangleMesh class. Point Cloud Utils currently supports PLY, OBJ, STL, OFF, VRML 2.0, X3D, COLLADA, 3DS. Parameters: Name Type Description Default filename Path to the file to be saved. Must have a valid extension. required dtype The type of floating point number to store the data in (np.float32 or np.float64) np.float64 Returns: Name Type Description mesh A TriangleMesh class containing the loaded mesh","title":"load_triangle_mesh()"},{"location":"sections/api_reference/#point_cloud_utils.make_mesh_watertight","text":"make_mesh_watertight(v: numpy.ndarray, f: numpy.ndarray, resolution: float = 20000, seed: int = -1) -> Tuple[object, object] Convert a mesh into a watertight manifold Parameters: Name Type Description Default v (#v, 3)-shaped array of mesh vertex positions (one vertex position per row) required f (#f, 3)-shaped array of mesh face indexes into v (a row (fi, fj, fk) indicate the 3 vertices of a face) required resolution A resolution parameter for the algorithm required Returns: Name Type Description vw a (#vw, 3)-shaped array of vertices (one per row) fw a (#fw, 3)-shaped array of face indices into vw (one face per row)","title":"make_mesh_watertight()"},{"location":"sections/api_reference/#point_cloud_utils.marching_cubes_sparse_voxel_grid","text":"marching_cubes_sparse_voxel_grid(grid_scalars: numpy.ndarray, grid_coordinates: numpy.ndarray, cube_indices: numpy.ndarray, isovalue: float) -> Tuple[object, object] Run marching cubes on a hex mesh representing a sparse voxel grid (see also sparse_voxel_grid_to_hex_mesh) Parameters: Name Type Description Default grid_scalars An (n,) shaped array of scalar values at each hex mesh vertex required grid_coordinates An (n, 3) shaped array of hex mesh vertices required cube_indices An (m, 8) shaped array of indices into grid_coordinates where cube_indices[i, :] are the indices of the 8 points forming the i^th cube Note the cube indices must be ordered as: [[0, 0, 0], [1, 0, 0], [1, 1, 0], [0, 1, 0], [0, 0, 1], [1, 0, 1], [1, 1, 1], [0, 1, 1]] where [i, j, k] indicates the offset along the (x, y, z) axes from the bottom, back, left corner of the cube required isovalue Which level set to extract required Returns: Name Type Description v A (#v, 3) array of triangle mesh vertices f A (#f, 3) array of indices into v where f[i, :] are the indices into vof the 3 points forming the i^th triangle See Also sparse_voxel_grid_to_hex_mesh","title":"marching_cubes_sparse_voxel_grid()"},{"location":"sections/api_reference/#point_cloud_utils.mesh_face_areas","text":"mesh_face_areas(v: numpy.ndarray, f: numpy.ndarray, num_threads: int = -1) -> object Compute the areas of each face of a triangle mesh Parameters: Name Type Description Default v #v by 3 array of vertex positions (each row is a vertex) required f #f by 3 Matrix of face (triangle) indices required Returns: Name Type Description areas a numpy array of shape (#faces,) where areas[i] is the area of the face f[i]","title":"mesh_face_areas()"},{"location":"sections/api_reference/#point_cloud_utils.mesh_mean_and_gaussian_curvatures","text":"Estimate mean and Gaussian curvatures for a mesh Parameters: Name Type Description Default v #v by 3 Matrix of mesh vertex 3D positions required f #f by 3 Matrix of face (triangle) indices required r optional floating point radius of neighborhood to consider when estimating curvature If set to a positive value, will use a more robust curvature estimation method (but may require some tuning) -1.0 Returns: Name Type Description kh an array of shape (#v,) of per-vertex mean curvatures kg an array of shape (#v,) of per-vertex Gaussian curvatures","title":"mesh_mean_and_gaussian_curvatures()"},{"location":"sections/api_reference/#point_cloud_utils.mesh_principal_curvatures","text":"mesh_principal_curvatures(v: numpy.ndarray, f: numpy.ndarray, r: float = -1.0) -> Tuple[object, object, object, object] Estimate principal curvature directions and magnitudes for a mesh Parameters: Name Type Description Default v #v by 3 Matrix of mesh vertex 3D positions required f #f by 3 Matrix of face (triangle) indices required r optional floating point radius of neighborhood to consider when estimating curvature required Returns: Name Type Description k1 an array of shape (#v,) of maximum curvature magnitudes k2 an array of shape (#v,) of minimum curvature magnitudes d1 an array of shape (#v, 3) of maximum curvature directions d2 an array of shape (#v, 3) of minimum curvature directions","title":"mesh_principal_curvatures()"},{"location":"sections/api_reference/#point_cloud_utils.morton_add","text":"morton_add(codes_1: numpy.ndarray, codes_2: numpy.ndarray, num_threads: int = -1) -> object Add morton codes together (corresponding to adding the vectors they encode) Parameters: Name Type Description Default codes_1 an (n,)-shaped array of morton codes required codes_2 an (n,)-shaped array of morton codes required num_threads Number of threads to use. If set to -1, will use all available CPUs. If set to 0, will run in serial. Default is -1. required Returns: Name Type Description morton_codes an (n,)-shaped array of added morton codes","title":"morton_add()"},{"location":"sections/api_reference/#point_cloud_utils.morton_decode","text":"morton_decode(codes: numpy.ndarray, num_threads: int = -1) -> object Decode n points along a Morton curve into 3D points Parameters: Name Type Description Default codes an (n,)-shaped array of Morton codes required Returns: Name Type Description points an (n, 3)-shaped array of 3D points","title":"morton_decode()"},{"location":"sections/api_reference/#point_cloud_utils.morton_encode","text":"morton_encode(pts: numpy.ndarray, num_threads: int = -1) -> object Encode n 3D points using Morton coding, possibly sorting them Parameters: Name Type Description Default pts an (n, 3)-shaped array of 3D points required num_threads Number of threads to use. If set to -1, will use all available CPUs. If set to 0, will run in serial. Default is -1. required Returns: Name Type Description morton_codes an (n,)-shaped array of morton encoded points","title":"morton_encode()"},{"location":"sections/api_reference/#point_cloud_utils.morton_knn","text":"morton_knn(codes: numpy.ndarray, qcodes: numpy.ndarray, k: int, sort_dist: bool = True) -> object Queries a sorted array of morton encoded points to find the (approximate) k nearest neighbors Parameters: Name Type Description Default codes an (n)-shaped array of morton codes required qcodes an (m)-shaped array of query codes required k an integer representing the number of nearest neighbors required sort_dist (optional, defaults to True) whether to return the nearest neigbors in distance sorted order required Returns: Name Type Description nn_idx an (m, k)-shaped array of indices into codes","title":"morton_knn()"},{"location":"sections/api_reference/#point_cloud_utils.morton_subtract","text":"morton_subtract(codes_1: numpy.ndarray, codes_2: numpy.ndarray, num_threads: int = -1) -> object Subtract morton codes from each other (corresponding to adding the vectors they encode) Parameters: Name Type Description Default codes_1 an (n,)-shaped array of morton codes required codes_2 an (n,)-shaped array of morton codes required num_threads Number of threads to use. If set to -1, will use all available CPUs. If set to 0, will run in serial. Default is -1. required Returns: Name Type Description morton_codes an (n,)-shaped shaped array of added morton codes","title":"morton_subtract()"},{"location":"sections/api_reference/#point_cloud_utils.one_sided_hausdorff_distance","text":"one_sided_hausdorff_distance(source: numpy.ndarray, target: numpy.ndarray, return_index: bool = True, squared_distances: bool = False, max_points_per_leaf: int = 10) -> object Compute the one sided Hausdorff distance from source to target Parameters: Name Type Description Default source n by 3 array of representing a set of n points (each row is a point of dimension 3) required target m by 3 array of representing a set of m points (each row is a point of dimension 3) required return_index Optionally return the index pair (i, j) into source and target such that source[i, :] and target[j, :] are the two points with maximum shortest distance. required squared_distances If set to True, then return squared L2 distances. required max_points_per_leaf the maximum number of points per leaf node in the KD tree used by this function. Default is 10. required Returns: Name Type Description d The largest shortest distance, d between each point in source and the points in target . i (n,)-shaped array of indices such that source[i, :] and target[j, :] are the two points with maximum shortest distance. j (m,)-shaped array of indices such that source[i, :] and target[j, :] are the two points with maximum shortest distance.","title":"one_sided_hausdorff_distance()"},{"location":"sections/api_reference/#point_cloud_utils.orient_mesh_faces","text":"orient_mesh_faces(f: numpy.ndarray, weighting_type: str = 'uniform') -> Tuple[object, object] Consistently orient faces of a mesh within each connected component Parameters: Name Type Description Default f (#f, 3)-shaped NumPy array of face (triangle) indices required Returns: Name Type Description oriented_faces (#f, 3)-shaped NumPy array of faces which are consistently oriented face_components (#f,)-shaped NumPy array of connected component ids (i.e. face_components[i] is the component id of facef[i])","title":"orient_mesh_faces()"},{"location":"sections/api_reference/#point_cloud_utils.pairwise_distances","text":"Compute the (batched) pairwise distance matrix between a and b which both have size [m, n, d] or [n, d]. The result is a tensor of size [m, n, n] (or [n, n]) whose entry [m, i, j] contains the distance_tensor between a[m, i, :] and b[m, j, :]. Parameters: Name Type Description Default a A tensor containing m batches of n points of dimension d. i.e. of size (m, n, d) required b A tensor containing m batches of n points of dimension d. i.e. of size (m, n, d) required p Norm to use for the distance_tensor None Returns: Name Type Description M A (m, n, n)-shaped array containing the pairwise distance_tensor between each pair of inputs in a batch.","title":"pairwise_distances()"},{"location":"sections/api_reference/#point_cloud_utils.point_cloud_fast_winding_number","text":"point_cloud_fast_winding_number(p: numpy.ndarray, n: numpy.ndarray, a: numpy.ndarray, q: numpy.ndarray) -> object Compute a consistent inside/outside field given a point cloud and evaluate that field at a set of query points Parameters: Name Type Description Default p (#p, 3)-shaped array of points required n (#p, 3)-shaped array of point normals at p required a (#p, 1)-shaped array of point areas (e.g. computed with pcu.estimate_point_cloud_areas) required q (#q, 3)-shaped array of query positions at which to evaluat the winding number field required Returns: Name Type Description signs (#q,)-shaped array with a sign value for each query point (positive for outside and negative for inside)","title":"point_cloud_fast_winding_number()"},{"location":"sections/api_reference/#point_cloud_utils.quantize_subdivided_sparse_voxel_grid","text":"subdivide_sparse_voxel_grid returns fractional voxel coordinates (since we are subdividing an integer grid). This function transforms these fractional coordinates into integer coordinates. This operation can be undone with unquantize_subdivided_sparse_voxel_grid Parameters: Name Type Description Default fractional_grid_coordinates An (n, 3) shaped array of fractional voxels coordinates returned by subdivide_sparse_voxel_grid required num_subdivs The number of subdivision iterations used to compute fractional_grid_coordinates required Returns: Name Type Description quantized_grid_coordinates An (n, 3) shaped array of quantized grid coordinates See Also subdivide_sparse_voxel_grid unquantize_subdivided_sparse_voxel_grid","title":"quantize_subdivided_sparse_voxel_grid()"},{"location":"sections/api_reference/#point_cloud_utils.ray_mesh_intersection","text":"ray_mesh_intersection(v: numpy.ndarray, f: numpy.ndarray, ray_o: numpy.ndarray, ray_d: numpy.ndarray, ray_near: float = 0.0, ray_far: float = inf) -> Tuple[object, object, object] Compute intersection between a set of rays and a triangle mesh Parameters: Name Type Description Default v #v by 3 array of vertex positions (each row is a vertex) required f #f by 3 Matrix of face (triangle) indices required ray_o array of shape (#rays, 3) of ray origins (one per row) or a single array of shape (3,) to use required ray_d array of shape (#rays, 3) of ray directions (one per row) required ray_near an optional floating point value indicating the distance along each ray to start searching (default 0.0) required ray_far an optional floating point value indicating the maximum distance along each ray to search (default inf) required Returns: Name Type Description f_id an array of shape (#rays,) representing the face id hit by each ray bc an array of shape (#rays, 3) where each row is the barycentric coordinates within each face of the ray intersection t the distance along each ray to the intersection","title":"ray_mesh_intersection()"},{"location":"sections/api_reference/#point_cloud_utils.ray_surfel_intersection","text":"Compute intersection between a set of rays and a point cloud converted to surfels (i.e. circular patches oriented with the point normals) Parameters: Name Type Description Default p #p by 3 array of vertex positions (each row is a vertex) required n #p by 3 Matrix of vertex normals (each row is a vertex) required ray_o array of shape (#rays, 3) of ray origins (one per row) or a single array of shape (3,) to use required ray_d array of shape (#rays, 3) of ray directions (one per row) required r Array or Scalar describing the size of each geometry element (Either one radius per vertex, or a global size for the whole point cloud) 0.1 subdivs Number of times to subdivide the patch geometry for each point (i.e. # tris per cicle) 4 ray_near an optional floating point value indicating the distance along each ray to start searching (default 0.0) 0.0 ray_far an optional floating point value indicating the maximum distance along each ray to search (default inf) np.inf Returns: Name Type Description t a (#rays,) shaped array encoding the distance between the ray origin and intersection point for each ray (inf for missed rays) pid a (#rays,) shaped array of integer indices corresponding to which points were hit (-1 for a ray miss)","title":"ray_surfel_intersection()"},{"location":"sections/api_reference/#point_cloud_utils.remove_unreferenced_mesh_vertices","text":"remove_unreferenced_mesh_vertices(v: numpy.ndarray, f: numpy.ndarray) -> Tuple[object, object, object, object] Removes duplicated vertices from a triangle mesh two vertices are considered the same if their distance is below some threshold Parameters: Name Type Description Default v (#v, 3)-shaped array of mesh vertex 3D positions required f (#f, 3)-shaped array of face (triangle) indices required Returns: Name Type Description v_new (#v_new, 3)-shaped array of mesh vertex positions without unreferenced vertices f_new (#f_new, 3)-shaped array of mesh faces indexing into v_new correspondences_v (#v, 1)-shaped array of indices so that v_new = correspondences_v[svi] correspondences_f (#f, 1)-shaped array of indices so that f_new = correspondences_f[svj]","title":"remove_unreferenced_mesh_vertices()"},{"location":"sections/api_reference/#point_cloud_utils.sample_mesh_lloyd","text":"sample_mesh_lloyd(v: numpy.ndarray, f: numpy.ndarray, num_samples: int, num_lloyd: int = 10, num_newton: int = 10, return_mesh: bool = False) -> object Generate n samples on a surface defined by a triangle mesh using Lloyd's algorithm (https://en.wikipedia.org/wiki/Lloyd%27s_algorithm). Parameters: Name Type Description Default v A #v by 3 array where each row is a vertex of the input mesh required f A #f by 3 array of indices into v where each row is a triangle of the input mesh. required n The number of surface samples to generate required num_lloyd The number of Lloyd iterations to do (default 10) required num_newton The number of Newton iterations to do when computing Voronoi diagrams (default 10) required Returns: Name Type Description lloyd_pts a (n, 3)-shaped array of point samples on the input surface defined by (v, f)","title":"sample_mesh_lloyd()"},{"location":"sections/api_reference/#point_cloud_utils.sample_mesh_poisson_disk","text":"sample_mesh_poisson_disk(v: numpy.ndarray, f: numpy.ndarray, num_samples: int, radius: float = 0.0, use_geodesic_distance: bool = True, best_choice_sampling: bool = True, random_seed: int = 0, sample_num_tolerance: float = 0.04, oversampling_factor: float = 40.0) -> Tuple[object, object] Downsample a point set (possibly on a mesh) so that samples are approximately evenly spaced. This function uses the method in (\"Parallel Poisson Disk Sampling with Spectrum Analysis on Surface\")[http://graphics.cs.umass.edu/pubs/sa_2010.pdf] Parameters: Name Type Description Default v #v by 3 array of mesh vertex positions required f #f by 3 array of mesh face indices required num_samples desired number of Poisson Disk samples. Note that the actual number of returned samples will not be exactly this value (see sample_num_tolerance) to control the range of possible returned samples. Note: If this value <= 0, then the parameter radius is used to decide the number of samples required radius desired separation between points, if num_samples <= 0, then this value is used to determine the sampling (-1.0, by default). required use_geodesic_distance Use geodesic distance on the mesh downsampling. (True by default). required best_choice_sampling When downsampling, always keep the sample that will remove the fewest number of samples. (True by default). required random_seed A random seed used to generate the samples. Passing in 0 will use the current time. (0 by default). required sample_num_tolerance If you requested a target number of samples, by passsing num_samples > 0, then this function will return between (1 - sample_num_tolerance) * num_samples and (1 + sample_num_tolerance) * num_samples. Setting a very small value for this parameter will increase convergence time. (0.04 by default). required oversampling_factor To generate Poisson disk samples, we first generate a very dense (uniform) random sampling of the mesh, then prune these down to have the Poisson disk property. This parameter controls how many dense samples are generated. i.e. we generate oversampling_factor * num_samples samples (if you passed in radius, we estimate num_samples from the input points and radius). This parameter must be >= 1.0. (Default 40.0). required Returns: Name Type Description f_idx a (m,)-shaped array of face indices into f where m is the number of Poisson-disk samples bc a (m, 3)-shaped array of barycentric coordinates where m is the number of Poisson-disk samples","title":"sample_mesh_poisson_disk()"},{"location":"sections/api_reference/#point_cloud_utils.sample_mesh_random","text":"sample_mesh_random(v: numpy.ndarray, f: numpy.ndarray, num_samples: int, random_seed: int = 0) -> Tuple[object, object] Generate uniformly distributed random point samples on a mesh Parameters: Name Type Description Default v (#v, 3)-shaped array of mesh vertex positions required f (#f, 3)-shaped array of mesh face indices required num_samples The number of samples to generate required random_seed A random seed used to generate the samples. Passing in 0 will use the current time. (0 by default). required Returns: Name Type Description f_idx (num_samples,) shaped array of face indices into f where bc (num_samples, 3) shaped array of barycentric coordinates","title":"sample_mesh_random()"},{"location":"sections/api_reference/#point_cloud_utils.save_mesh_v","text":"Save a point cloud consisting only of vertex positions. Point Cloud Utils currently supports PLY, OBJ, STL, OFF, VRML 2.0, X3D, COLLADA, 3DS. Parameters: Name Type Description Default filename Path to the file to be saved. Must have a valid extension. required v An (n, 3)-shaped numpy array of coordinates required dtype The floating point written to the file ( np.float32 or np.float64 ) np.float32","title":"save_mesh_v()"},{"location":"sections/api_reference/#point_cloud_utils.save_mesh_vc","text":"Save a point cloud consisting of vertex positions and vertex colors. Point Cloud Utils currently supports PLY, OBJ, STL, OFF, VRML 2.0, X3D, COLLADA, 3DS. Parameters: Name Type Description Default filename Path to the file to be saved. Must have a valid extension. required v An (n, 3)-shaped numpy array of coordinates required c An (n, 3)-shaped or (n, 4)-shaped numpy array of per-vertex RGB or RGBA colors (from 0.0 to 1.0) required dtype The floating point written to the file ( np.float32 or np.float64 ) np.float32","title":"save_mesh_vc()"},{"location":"sections/api_reference/#point_cloud_utils.save_mesh_vf","text":"Save a triangle mesh consisting of vertex positions and face indices. Point Cloud Utils currently supports PLY, OBJ, STL, OFF, VRML 2.0, X3D, COLLADA, 3DS. Parameters: Name Type Description Default filename Path to the file to be saved. Must have a valid extension. required v An (n, 3)-shaped numpy array of coordinates required f An (m, 3)-shaped integer numpy array of face indices into v required dtype The floating point written to the file ( np.float32 or np.float64 ) np.float32","title":"save_mesh_vf()"},{"location":"sections/api_reference/#point_cloud_utils.save_mesh_vfn","text":"Save a triangle mesh consisting of vertex positions, face indices, and vertex normals. Point Cloud Utils currently supports PLY, OBJ, STL, OFF, VRML 2.0, X3D, COLLADA, 3DS. Parameters: Name Type Description Default filename Path to the file to be saved. Must have a valid extension. required v An (n, 3)-shaped numpy array of coordinates required f An (m, 3)-shaped integer numpy array of face indices into v required n An (n, 3)-shaped numpy array of per-vertex normals required dtype The floating point written to the file ( np.float32 or np.float64 ) np.float32","title":"save_mesh_vfn()"},{"location":"sections/api_reference/#point_cloud_utils.save_mesh_vfnc","text":"Save a triangle mesh consisting of vertex positions, face indices, vertex normals, and vertex colors. Point Cloud Utils currently supports PLY, OBJ, STL, OFF, VRML 2.0, X3D, COLLADA, 3DS. Parameters: Name Type Description Default filename Path to the file to be saved. Must have a valid extension. required v An (n, 3)-shaped numpy array of coordinates required f An (m, 3)-shaped integer numpy array of face indices into v required n An (n, 3)-shaped numpy array of per-vertex normals required c An (n, 3)-shaped or (n, 4)-shaped numpy array of per-vertex RGB or RGBA colors (from 0.0 to 1.0) required dtype The floating point written to the file ( np.float32 or np.float64 ) np.float32","title":"save_mesh_vfnc()"},{"location":"sections/api_reference/#point_cloud_utils.save_mesh_vn","text":"Save a point cloud consisting of vertex positions and vertex normals. Point Cloud Utils currently supports PLY, OBJ, STL, OFF, VRML 2.0, X3D, COLLADA, 3DS. Parameters: Name Type Description Default filename Path to the file to be saved. Must have a valid extension. required v An (n, 3)-shaped numpy array of coordinates required n An (n, 3)-shaped numpy array of per-vertex normals required dtype The floating point written to the file ( np.float32 or np.float64 ) np.float32","title":"save_mesh_vn()"},{"location":"sections/api_reference/#point_cloud_utils.save_mesh_vnc","text":"Save a point cloud consisting of vertex positions, vertex normals, and vertex colors. Point Cloud Utils currently supports PLY, OBJ, STL, OFF, VRML 2.0, X3D, COLLADA, 3DS. Parameters: Name Type Description Default filename Path to the file to be saved. Must have a valid extension. required v An (n, 3)-shaped numpy array of coordinates required n An (n, 3)-shaped numpy array of per-vertex normals required c An (n, 3)-shaped or (n, 4)-shaped numpy array of per-vertex RGB or RGBA colors (from 0.0 to 1.0) required dtype The floating point written to the file ( np.float32 or np.float64 ) np.float32","title":"save_mesh_vnc()"},{"location":"sections/api_reference/#point_cloud_utils.save_triangle_mesh","text":"Save a triangle mesh to a file with various per-vertex, per-face, and per-wedge attributes. Each argument (except v) is optional and can be None. Parameters: Name Type Description Default filename Path to the mesh to save. The type of file will be determined from the file extension. required v [V, 3]-shaped numpy array of per-vertex positions required f [F, 3]-shaped numpy array of integer face indices into TrianglMesh.vertex_data.positions (or None) None vn [V, 3]-shaped numpy array of per-vertex normals (or None) None vt [V, 2]-shaped numpy array of per-vertex uv coordinates (or None) None vc [V, 4]-shaped numpy array of per-vertex RBGA colors in [0.0, 1.0] (or None) None vq [V,]-shaped numpy array of per-vertex quality measures (or None) None vr [V,]-shaped numpy array of per-vertex curvature radii (or None) None vti [V,]-shaped numpy array of integer indices into TriangleMesh.textures indicating which texture to use at this vertex (or None) None vflags [V,]-shaped numpy array of 32-bit integer flags per vertex (or None) None fn [F, 3]-shaped numpy array of per-face normals (or None) None fc [F, 4]-shaped numpy array of per-face RBGA colors in [0.0, 1.0] (or None) None fq [F,]-shaped numpy array of per-face quality measures (or None) None fflags [F,]-shaped numpy array of 32-bit integer flags per face (or None) None wc [F, 3, 4]-shaped numpy array of per-wedge RBGA colors in [0.0, 1.0] (or None) None wn [F, 3, 3]-shaped numpy array of per-wedge normals (or None) None wt [F, 3, 2]-shaped numpy array of per-wedge] uv coordinates (or None) None wti [F, 3]-shaped numpy array of integer indices into TriangleMesh.textures indicating which None textures A list of paths to texture image files for this mesh [] normal_maps A list of paths to texture image files for this mesh [] dtype The floating point written to the file ( np.float32 or np.float64 ) np.float32","title":"save_triangle_mesh()"},{"location":"sections/api_reference/#point_cloud_utils.signed_distance_to_mesh","text":"signed_distance_to_mesh(p: numpy.ndarray, v: numpy.ndarray, f: numpy.ndarray, lower_bound: float = -inf, upper_bound: float = inf) -> Tuple[object, object, object] Computes signed distances of a point cloud with respect to a Mesh using Fast Winding Numbers Parameters: Name Type Description Default p (#p, 3)-shaped array point cloud (one 3D point per row) required v (#v, 3)-shaped array of mesh vertex positions (one vertex position per row) required f (#f, 3)-shaped array of mesh face indexes into v (a row (fi, fj, fk) indicate the 3 vertices of a face) required lower_bound The minimum distance value possible (use this to clamp SDF values). negative infinite by default required upper_bound The maximum distance value possible (use this to clamp SDF values). negative infinite by default required Returns: Name Type Description s a (#p,) shaped array of signed distance values for each query point in p fi a (#p,) shaped array of indices to the closest face for each query point in p bc a (#p, 3) shaped array of barycentric coordinates for the closest point on the mesh to each query point in p","title":"signed_distance_to_mesh()"},{"location":"sections/api_reference/#point_cloud_utils.sinkhorn","text":"Compute the (batched) Sinkhorn correspondences between two dirac delta distributions, U, and V. This implementation is numerically stable with float32. Parameters: Name Type Description Default a A m-sized minibatch of weights for each dirac in the first distribution, U. i.e. shape = (m, n) required b A m-sized minibatch of weights for each dirac in the second distribution, V. i.e. shape = (m, n) required M A minibatch of n-by-n tensors storing the distance between each pair of diracs in U and V. i.e. shape = (m, n, n) and each i.e. M[k, i, j] = ||u[k,_i] - v[k, j]|| required eps The reciprocal of the sinkhorn regularization parameter required max_iters The maximum number of Sinkhorn iterations 100 stop_thresh Stop if the change in iterates is below this value 0.001 Returns: Name Type Description P An (m, n, n)-shaped array of correspondences between distributions U and V","title":"sinkhorn()"},{"location":"sections/api_reference/#point_cloud_utils.sparse_voxel_grid_boundary","text":"sparse_voxel_grid_boundary(grid_coordinates: numpy.ndarray) -> object","title":"sparse_voxel_grid_boundary()"},{"location":"sections/api_reference/#point_cloud_utils.sparse_voxel_grid_from_pointcloud","text":"Construct a sparse voxel grid containing a point cloud, optionally returning the voxel index for each point. Parameters: Name Type Description Default points An (n, 3) shaped array of points (one per row) required voxel_size Either a scalar representing the sidelength of a voxel or a triple representing the sidelength of a voxel along each axis. required origin The origin of the point cloud corresponding to the bottom, back, left corner of the (0, 0, 0) voxel. (0.0, 0.0, 0.0) Returns: Name Type Description grid_coordinates An (n, 3)-shaped array of integer grid coordinates corresponding to voxels in the sparse grid point_to_vox_idx An (#points,)-shaped array where the i^th entry point_to_vox_idx[i] is the index into grid_coordinates of of the voxel containing points[i]","title":"sparse_voxel_grid_from_pointcloud()"},{"location":"sections/api_reference/#point_cloud_utils.sparse_voxel_grid_to_hex_mesh","text":"Convert a sparse voxel grid where the voxel indices represent the centers of each voxel coordinate into a hexahedral mesh. i.e. a pair of arrays (v, c) where v has shape (n, 3) and each row is a vertex position and c has shape (m, 8) where the i^th row c[i, :] are the indices into v of the 8 corners of the i^th cube Parameters: Name Type Description Default grid_coordinates An (n, 3) shaped integer array of voxels coordinates in the sparse voxel grid required voxel_size Either a scalar encoding the length of one voxel along an axis or a triple encoding the length of a voxel on each of 3 axes 1.0 origin A triple encoding a global offset for the hex mesh (i.e. all vertices will have origin added to them). Default is (0.0, 0.0, 0.0). (0.0, 0.0, 0.0) dtype The scalar type of vertices to return. Default is np.float64. np.float64 Returns: Name Type Description vertices An (n, 3) shaped array where each row vertices[i, :] is a vertex position in the hex mesh cubes An (m, 8) shaped array of indices into v where each row cubes[j, :] are indices of the 8 points forming the j^th cube","title":"sparse_voxel_grid_to_hex_mesh()"},{"location":"sections/api_reference/#point_cloud_utils.subdivide_sparse_voxel_grid","text":"Subdivide a sparse voxel grid such that every subdivision round splits each voxel into 8 subvoxels. Parameters: Name Type Description Default grid_coordinates An (n, 3) shaped integer array of voxels coordinates in the sparse voxel grid required num_subdivs The number of subdivision iterations to perform 1 An (m, 3) shaped array containing (fractional) coordinates representing the subdivided grid voxel grid. To convert to integer coordinates you can run: integer_grid_coords = quantize_subdivided_sparse_voxel_grid(num_subdivs)","title":"subdivide_sparse_voxel_grid()"},{"location":"sections/api_reference/#point_cloud_utils.surfel_geometry","text":"Generate geometry for a point cloud encoded as surfels (i.e. circular patches centered at each point and oriented perpendicularly to each normal) Parameters: Name Type Description Default p #p by 3 array of vertex positions (each row is a vertex) required n #p by 3 array of vertex normals (each row is a vertex) required r Array or Scalar describing the size of each geometry element (Either one radius per vertex, or a global size for the whole point cloud) 0.1 subdivs Number of times to subdivide the patch geometry for each point (i.e. # tris per cicle) 7 Returns: Name Type Description verts an array of shape (#output_vertices, 3) faces an array of shape (#output_faces, 3) indexing into verts","title":"surfel_geometry()"},{"location":"sections/api_reference/#point_cloud_utils.triangle_soup_fast_winding_number","text":"triangle_soup_fast_winding_number(v: numpy.ndarray, f: numpy.ndarray, p: numpy.ndarray) -> object Compute a consistent inside/outside field given a triangle soup and evaluate that field at a set of query points Parameters: Name Type Description Default v (#v, 3)-shaped array of mesh vertex positions (one vertex position per row) required f (#f, 3)-shaped array of mesh face indexes into v (a row (fi, fj, fk) indicate the 3 vertices of a face) required q (#q, 3)-shaped array of query positions at which to evaluat the winding number field required Returns: Type Description A (#q,)-shaped array with a sign value for each query point (positive for outside and negative for inside)","title":"triangle_soup_fast_winding_number()"},{"location":"sections/api_reference/#point_cloud_utils.unquantize_subdivided_sparse_voxel_grid","text":"Undo quantization done by quantize_subdivided_sparse_voxel_grid. Parameters: Name Type Description Default quantized_grid_coordinates An (n, 3) shaped array of quantized voxels coordinates returned by quantize_subdivided_sparse_voxel_grid required num_subdivs The number of subdivision iterations used to compute the original fractional coordinates required Returns: Name Type Description fractional_grid_coordinates An (n, 3) shaped array of fractional grid coordinates See Also subdivide_sparse_voxel_grid quantize_subdivided_sparse_voxel_grid","title":"unquantize_subdivided_sparse_voxel_grid()"},{"location":"sections/api_reference/#point_cloud_utils.voronoi_centroids_unit_cube","text":"voronoi_centroids_unit_cube(centers: numpy.ndarray) -> object Generate n samples in the unit cube, [0, 1]^3 using Lloyd's algorithm (https://en.wikipedia.org/wiki/Lloyd%27s_algorithm). Parameters: Name Type Description Default n The number of 3d point samples to generate required num_lloyd The number of Lloyd iterations to do (default 10) required num_newton The number of Newton iterations to do when computing Voronoi diagrams (default 10) required Returns: Name Type Description lloyd_pts a (n, 3)-shaped array of point samples in the unit square [0, 1]^3","title":"voronoi_centroids_unit_cube()"},{"location":"sections/mesh_io/","text":"Mesh and Point Cloud I/O If your file can be imported into MeshLab, we can read it! Point Cloud Utils supports reading and writing many common 3D formats (PLY, STL, OFF, OBJ, 3DS, VRML 2.0, X3D, COLLADA). In all the functions in this section, the type of file is inferred from its file extension. 3D Data Representation in Point Cloud Utils Point Cloud Utils uses NumPy arrays as a fundamental data structure for storing 3D data. Representing Point Clouds A point cloud with #p points is represented as a simple Numpy array with shape (#p, 3) (one point per row). The example below illustrates a point cloud with six points. Representing Triangle Meshes A triangle mesh with #v vertices and #f faces is stored using a pair of NumPy arrays v, f with shape (#v, 3) and (#f, 3) respectively. Each row of v stores a vertex coordinate and each row of f stores three integer indexes into v denoting the three vertices forming that face. Per-vertex attributes are stored as separate NumPy arrays with #v rows (one row per vertex). For example, consider the mesh with 6 vertices and 5 faces illustrated above. We would store this as two numpy arrays v, f with v.shape = (6, 3) and f.shape = (5, 3) . The i th row of v is a 3D vector encoding the position of the vertex v i , and j th row of f holds three indices to each of the vertices of the j th face. In the figure, the second face is formed by the vertices v 1 , v 2 , v 5 , so the second row of f are the integers (1, 2, 5) . Representing Point and Face Attributes In addition to vertices and face data, we often want to store attributes alongside a point cloud or mesh. Attributes can be stored per-point as well as per-face. Attributes are stored as NumPy arrays with one attribute per row. Examples of attributes include point cloud normals, point colors, per-face colors, or per-vertex texture coordinates. Example - Storing face colors and vertex normals in a mesh: For example, consider the mesh described above with 6 vertices and 5 faces, stored as two arrays v and f with shapes (6, 3) and (5, 3) respectively. We could store per-face colors as a NumPy array with shape (5, 3) each row is the color of the correponding face: Per-face attributes are stored in an array with the same number of rows as the face array We could store per-vertex normals as a NumPy array of shape (6, 3) where each row contains the normal at the corresponding vertex: Per-vertex attributes (e.g. normals) are stored in an array with the same number of rows as the vertex array Shorthand functions for loading and saving 3D data Many times, we only need to load a few attributes from a mesh or point cloud. For example, we may only want the vertices, faces, and vertex colors for mesh. Point Cloud Utils provides a number of shorthand helper functions which can load these attributes directly into NumPy arrays. These functions have the form load_mesh_* and save_mesh_* where * indicates which data to load. If some attribute is not present in the file being loaded, these functions will simply return an empty array. Load/Save only points import point_cloud_utils as pcu # v is a NumPy array of shape (#v, 3) of points v = pcu.load_mesh_v(\"path/to/mesh\") pcu.save_mesh_v(\"path/to/mash\", v) Load/Save mesh vertices and faces import point_cloud_utils as pcu # v is a NumPy array of shape (#v, 3) of points # f is a NumPy array of shape (#f, 3) of face indices v, f = pcu.load_mesh_vf(\"path/to/mesh\") pcu.save_mesh_vf(\"path/to/mash\", v, f) Load/Save points and per-point normals import point_cloud_utils as pcu # v is a NumPy array of shape (#v, 3) of points # n is a NumPy array of shape (#v, 3) of per-vertex normals v, n = pcu.load_mesh_vn(\"path/to/mesh\") pcu.save_mesh_vn(\"path/to/mash\", v, n) Load/Save mesh vertices, faces, and vertex colors import point_cloud_utils as pcu # v is a NumPy array of shape (#v, 3) of points # f is a NumPy array of shape (#f, 3) of face indices # c is a NumPy array of shape (#v, 4) of RBGA per-vertex colors v, f, c = pcu.load_mesh_vfc(\"path/to/mesh\") pcu.save_mesh_vfc(\"path/to/mash\", v, f, c) Load/Save mesh vertices, faces, and vertex normals import point_cloud_utils as pcu # v is a NumPy array of shape (#v, 3) of points # f is a NumPy array of shape (#f, 3) of face indices # n is a NumPy array of shape (#v, 3) of per-vertex normals v, f, n = pcu.load_mesh_vfn(\"path/to/mesh\") pcu.save_mesh_vfn(\"path/to/mash\", v, f, n) Load/Save mesh vertices, faces, vertex normals, and vertex colors import point_cloud_utils as pcu # v is a NumPy array of shape (#v, 3) of points # f is a NumPy array of shape (#f, 3) of face indices # n is a NumPy array of shape (#v, 3) of per-vertex normals # c is a NumPy array of shape (#v, 4) of RBGA per-vertex colors v, f, n, c = pcu.load_mesh_vfn(\"path/to/mesh\") pcu.save_mesh_vfnc(\"path/to/mash\", v, f, n, c) Loading 3D data with all attributes Some meshes or point clouds may have more complex attribute structures, or we may not know which attributes are stored in the mesh file before loading it. In this case, Point Cloud Utils provides utilities to load a mesh into a TriangleMesh class. TriangleMesh is a lightweight container containing numpy arrays for vertices, faces, textures, and other attributes. To load a mesh into a TriangleMesh class simply construct it with the path to the mesh: import point_cloud_utils as pcu mesh = pcu.TriangleMesh(\"path/to/mesh\") To save a TriangleMesh object, simply call the save method with the desired path: mesh.save(\"path/to/mesh\") The TriangleMesh class contains attributes encoding vertex and face data as well as texture information. It is structured as follows: TriangleMesh : vertex_data : positions : (#v, 3)-shaped NumPy array of per-vertex positions normals : (#v, 3)-shaped NumPy array of per-vertex normals (or None ) texcoords : (#v, 2)-shaped NumPy array of per-vertex uv coordinates (or None ) tex_ids : (#v,)-shaped NumPy array of integer indices into TriangleMesh.textures indicating which texture to use at this vertex (or None ) colors : (#v, 4)-shaped NumPy array of per-vertex RBGA colors in [0.0, 1.0] (or None ) radius : (#v,)-shaped NumPy array of per-vertex curvature radii (or None ) quality : (#v,)-shaped NumPy array of per-vertex quality measures (or None ) flags : (#v,)-shaped NumPy array of 32-bit integer flags per vertex (or None ) face_data : vertex_ids : (#f, 3)-shaped NumPy array of integer face indices into TrianglMesh.vertex_data.positions normals : (#f, 3)-shaped NumPy array of per-face normals (or None ) colors : (#f, 4)-shaped NumPy array of per-face RBGA colors in [0.0, 1.0] (or None ) quality : (#f,)-shaped NumPy array of per-face quality measures (or None ) flags : (#f,(-shaped NumPy array of 32-bit integer flags per face (or None ) wedge_colors : (#f, 3, 4)-shaped NumPy array of per-wedge RBGA colors in [0.0, 1.0] (or None ) wedge_normals : (#f, 3, 3)-shaped NumPy array of per-wedge normals (or None ) wedge_texcoords : (#f, 3, 2)-shaped NumPy array of per-wedge] uv coordinates (or None ) wedge_tex_ids : (#f, 3)-shaped NumPy array of integer indices into TriangleMesh.textures indicating which texture to use at this wedge (or None ) textures : A list of paths to texture image files for this mesh normal_maps : A list of paths to texture image files for this mesh The hierarchy of the list above denotes composition. For example, to access the vertex colors of a TriangleMesh , you would read the TriangleMesh.vertex_data.colors property. Remark on wedge face attributes The face_data member of the TriangleMesh class contains a number of wedge attributes. These all start with wedge_ . In this context a wedge is a corner of a triangle face. Each face contains three wedges corresponding to each corner. Wedge attributes have shape (#f, 3, d) where d is the dimension of the attribute. Wedges attributes are useful for storing which are discontinous across face boundaries.","title":"Mesh I/O"},{"location":"sections/mesh_io/#mesh-and-point-cloud-io","text":"If your file can be imported into MeshLab, we can read it! Point Cloud Utils supports reading and writing many common 3D formats (PLY, STL, OFF, OBJ, 3DS, VRML 2.0, X3D, COLLADA). In all the functions in this section, the type of file is inferred from its file extension.","title":"Mesh and Point Cloud I/O"},{"location":"sections/mesh_io/#3d-data-representation-in-point-cloud-utils","text":"Point Cloud Utils uses NumPy arrays as a fundamental data structure for storing 3D data.","title":"3D Data Representation in Point Cloud Utils"},{"location":"sections/mesh_io/#representing-point-clouds","text":"A point cloud with #p points is represented as a simple Numpy array with shape (#p, 3) (one point per row). The example below illustrates a point cloud with six points.","title":"Representing Point Clouds"},{"location":"sections/mesh_io/#representing-triangle-meshes","text":"A triangle mesh with #v vertices and #f faces is stored using a pair of NumPy arrays v, f with shape (#v, 3) and (#f, 3) respectively. Each row of v stores a vertex coordinate and each row of f stores three integer indexes into v denoting the three vertices forming that face. Per-vertex attributes are stored as separate NumPy arrays with #v rows (one row per vertex). For example, consider the mesh with 6 vertices and 5 faces illustrated above. We would store this as two numpy arrays v, f with v.shape = (6, 3) and f.shape = (5, 3) . The i th row of v is a 3D vector encoding the position of the vertex v i , and j th row of f holds three indices to each of the vertices of the j th face. In the figure, the second face is formed by the vertices v 1 , v 2 , v 5 , so the second row of f are the integers (1, 2, 5) .","title":"Representing Triangle Meshes"},{"location":"sections/mesh_io/#representing-point-and-face-attributes","text":"In addition to vertices and face data, we often want to store attributes alongside a point cloud or mesh. Attributes can be stored per-point as well as per-face. Attributes are stored as NumPy arrays with one attribute per row. Examples of attributes include point cloud normals, point colors, per-face colors, or per-vertex texture coordinates. Example - Storing face colors and vertex normals in a mesh: For example, consider the mesh described above with 6 vertices and 5 faces, stored as two arrays v and f with shapes (6, 3) and (5, 3) respectively. We could store per-face colors as a NumPy array with shape (5, 3) each row is the color of the correponding face: Per-face attributes are stored in an array with the same number of rows as the face array We could store per-vertex normals as a NumPy array of shape (6, 3) where each row contains the normal at the corresponding vertex: Per-vertex attributes (e.g. normals) are stored in an array with the same number of rows as the vertex array","title":"Representing Point and Face Attributes"},{"location":"sections/mesh_io/#shorthand-functions-for-loading-and-saving-3d-data","text":"Many times, we only need to load a few attributes from a mesh or point cloud. For example, we may only want the vertices, faces, and vertex colors for mesh. Point Cloud Utils provides a number of shorthand helper functions which can load these attributes directly into NumPy arrays. These functions have the form load_mesh_* and save_mesh_* where * indicates which data to load. If some attribute is not present in the file being loaded, these functions will simply return an empty array.","title":"Shorthand functions for loading and saving 3D data"},{"location":"sections/mesh_io/#loadsave-only-points","text":"import point_cloud_utils as pcu # v is a NumPy array of shape (#v, 3) of points v = pcu.load_mesh_v(\"path/to/mesh\") pcu.save_mesh_v(\"path/to/mash\", v)","title":"Load/Save only points"},{"location":"sections/mesh_io/#loadsave-mesh-vertices-and-faces","text":"import point_cloud_utils as pcu # v is a NumPy array of shape (#v, 3) of points # f is a NumPy array of shape (#f, 3) of face indices v, f = pcu.load_mesh_vf(\"path/to/mesh\") pcu.save_mesh_vf(\"path/to/mash\", v, f)","title":"Load/Save mesh vertices and faces"},{"location":"sections/mesh_io/#loadsave-points-and-per-point-normals","text":"import point_cloud_utils as pcu # v is a NumPy array of shape (#v, 3) of points # n is a NumPy array of shape (#v, 3) of per-vertex normals v, n = pcu.load_mesh_vn(\"path/to/mesh\") pcu.save_mesh_vn(\"path/to/mash\", v, n)","title":"Load/Save points and per-point normals"},{"location":"sections/mesh_io/#loadsave-mesh-vertices-faces-and-vertex-colors","text":"import point_cloud_utils as pcu # v is a NumPy array of shape (#v, 3) of points # f is a NumPy array of shape (#f, 3) of face indices # c is a NumPy array of shape (#v, 4) of RBGA per-vertex colors v, f, c = pcu.load_mesh_vfc(\"path/to/mesh\") pcu.save_mesh_vfc(\"path/to/mash\", v, f, c)","title":"Load/Save mesh vertices, faces, and vertex colors"},{"location":"sections/mesh_io/#loadsave-mesh-vertices-faces-and-vertex-normals","text":"import point_cloud_utils as pcu # v is a NumPy array of shape (#v, 3) of points # f is a NumPy array of shape (#f, 3) of face indices # n is a NumPy array of shape (#v, 3) of per-vertex normals v, f, n = pcu.load_mesh_vfn(\"path/to/mesh\") pcu.save_mesh_vfn(\"path/to/mash\", v, f, n)","title":"Load/Save mesh vertices, faces, and vertex normals"},{"location":"sections/mesh_io/#loadsave-mesh-vertices-faces-vertex-normals-and-vertex-colors","text":"import point_cloud_utils as pcu # v is a NumPy array of shape (#v, 3) of points # f is a NumPy array of shape (#f, 3) of face indices # n is a NumPy array of shape (#v, 3) of per-vertex normals # c is a NumPy array of shape (#v, 4) of RBGA per-vertex colors v, f, n, c = pcu.load_mesh_vfn(\"path/to/mesh\") pcu.save_mesh_vfnc(\"path/to/mash\", v, f, n, c)","title":"Load/Save mesh vertices, faces, vertex normals, and vertex colors"},{"location":"sections/mesh_io/#loading-3d-data-with-all-attributes","text":"Some meshes or point clouds may have more complex attribute structures, or we may not know which attributes are stored in the mesh file before loading it. In this case, Point Cloud Utils provides utilities to load a mesh into a TriangleMesh class. TriangleMesh is a lightweight container containing numpy arrays for vertices, faces, textures, and other attributes. To load a mesh into a TriangleMesh class simply construct it with the path to the mesh: import point_cloud_utils as pcu mesh = pcu.TriangleMesh(\"path/to/mesh\") To save a TriangleMesh object, simply call the save method with the desired path: mesh.save(\"path/to/mesh\") The TriangleMesh class contains attributes encoding vertex and face data as well as texture information. It is structured as follows: TriangleMesh : vertex_data : positions : (#v, 3)-shaped NumPy array of per-vertex positions normals : (#v, 3)-shaped NumPy array of per-vertex normals (or None ) texcoords : (#v, 2)-shaped NumPy array of per-vertex uv coordinates (or None ) tex_ids : (#v,)-shaped NumPy array of integer indices into TriangleMesh.textures indicating which texture to use at this vertex (or None ) colors : (#v, 4)-shaped NumPy array of per-vertex RBGA colors in [0.0, 1.0] (or None ) radius : (#v,)-shaped NumPy array of per-vertex curvature radii (or None ) quality : (#v,)-shaped NumPy array of per-vertex quality measures (or None ) flags : (#v,)-shaped NumPy array of 32-bit integer flags per vertex (or None ) face_data : vertex_ids : (#f, 3)-shaped NumPy array of integer face indices into TrianglMesh.vertex_data.positions normals : (#f, 3)-shaped NumPy array of per-face normals (or None ) colors : (#f, 4)-shaped NumPy array of per-face RBGA colors in [0.0, 1.0] (or None ) quality : (#f,)-shaped NumPy array of per-face quality measures (or None ) flags : (#f,(-shaped NumPy array of 32-bit integer flags per face (or None ) wedge_colors : (#f, 3, 4)-shaped NumPy array of per-wedge RBGA colors in [0.0, 1.0] (or None ) wedge_normals : (#f, 3, 3)-shaped NumPy array of per-wedge normals (or None ) wedge_texcoords : (#f, 3, 2)-shaped NumPy array of per-wedge] uv coordinates (or None ) wedge_tex_ids : (#f, 3)-shaped NumPy array of integer indices into TriangleMesh.textures indicating which texture to use at this wedge (or None ) textures : A list of paths to texture image files for this mesh normal_maps : A list of paths to texture image files for this mesh The hierarchy of the list above denotes composition. For example, to access the vertex colors of a TriangleMesh , you would read the TriangleMesh.vertex_data.colors property. Remark on wedge face attributes The face_data member of the TriangleMesh class contains a number of wedge attributes. These all start with wedge_ . In this context a wedge is a corner of a triangle face. Each face contains three wedges corresponding to each corner. Wedge attributes have shape (#f, 3, d) where d is the dimension of the attribute. Wedges attributes are useful for storing which are discontinous across face boundaries.","title":"Loading 3D data with all attributes"},{"location":"sections/mesh_normal_estimation/","text":"Computing Normals for a Triangle Mesh Point-Cloud-Utils lets you easily compute both vertex and face normals for a mesh Computing Vertex Normals for a Mesh import point_cloud_utils as pcu v, f = pcu.load_mesh_vf(\"bunny.ply\") # n is a NumPy array with the same shape as v containing vertex normals n = pcu.estimate_mesh_normals(v, f) Estimating vertex normals for a triangle mesh. Computing Face Normals for a Mesh import point_cloud_utils as pcu v, f = pcu.load_mesh_vf(\"bunny.ply\") # n is a NumPy array with the same shape as f containing face normals n = pcu.estimate_mesh_face_normals(v, f) Estimating face normals for a triangle mesh","title":"Computing Mesh Normals"},{"location":"sections/mesh_normal_estimation/#computing-normals-for-a-triangle-mesh","text":"Point-Cloud-Utils lets you easily compute both vertex and face normals for a mesh","title":"Computing Normals for a Triangle Mesh"},{"location":"sections/mesh_normal_estimation/#computing-vertex-normals-for-a-mesh","text":"import point_cloud_utils as pcu v, f = pcu.load_mesh_vf(\"bunny.ply\") # n is a NumPy array with the same shape as v containing vertex normals n = pcu.estimate_mesh_normals(v, f) Estimating vertex normals for a triangle mesh.","title":"Computing Vertex Normals for a Mesh"},{"location":"sections/mesh_normal_estimation/#computing-face-normals-for-a-mesh","text":"import point_cloud_utils as pcu v, f = pcu.load_mesh_vf(\"bunny.ply\") # n is a NumPy array with the same shape as f containing face normals n = pcu.estimate_mesh_face_normals(v, f) Estimating face normals for a triangle mesh","title":"Computing Face Normals for a Mesh"},{"location":"sections/mesh_sampling/","text":"Mesh Sampling Point Cloud Utils provides tools for generating point samples on a triangle mesh. Data in examples In all the examples, below we first load the point cloud here Representing mesh-surface samples in Point Cloud Utils Point Cloud Utils returns samples on the surface of a mesh using Barycentric Coordinates . i.e. each sample is encoded as: The index of the mesh face containing it (usually referred to as fid ) The barycentric coordinates of the point within that face (usually referred to as bc ) The reason for encoding points in this way is that it allows us to interpolate any quantity stored at the vertices (including their positions) of a mesh to the sample positions, and thus sample vertex attributes. To recover vertex quantities from fid , bc pairs use the function pcu.interpolate_barycentric_coords(f, fid, bc, vertex_quantity) Generating random samples on a mesh We often want to sample points uniformly at random on a 3D surface. Point Cloud Utils provides a simple function for generating iid point samples such that each sample has equal probability of landing anywhere on the surface. import point_cloud_utils as pcu # v is a [n, 3] shaped NumPy array of vertices # f is a [m, 3] shaped integer NumPy array of indices into v # n is a [n, 3] shaped NumPy array of vertex normals v, f, n = pcu.load_mesh_vfn(\"bunny.ply\") # Generate barycentric coordinates of random samples num_samples = 1000 fid, bc = pcu.sample_mesh_random(v, f, num_samples) # Interpolate the vertex positions and normals using the returned barycentric coordinates # to get sample positions and normals rand_positions = pcu.interpolate_barycentric_coords(f, fid, bc, v) rand_normals = pcu.interpolate_barycentric_coords(f, fid, bc, n) Generating random (yellow) points on the mesh. We can also extract vertex attributes such as normals (pink arrows) at the points. Generating blue-noise random samples on a mesh We may want to sample a surface in a random way such that the samples are evenly spaced apart. Such a distribution of points is called a \"blue noise\" distribution. Formally, this means that the expected distance between points on the surface is some constant. i.e. for a set of points \\(P\\) : $$ \\mathbb{E}_{x \\in P} ||x - \\text{nearest_neighbor}(x)|| = \\epsilon $$ This can be achieved with Poisson Disk Sampling. Point cloud utils supports sampling a mesh such that there are either (1) a target number of points or (2) such that the points are separated by some radius. import point_cloud_utils as pcu import numpy as np # v is a [n, 3] shaped NumPy array of vertices # f is a [m, 3] shaped integer NumPy array of indices into v # n is a [n, 3] shaped NumPy array of vertex normals v, f, n = pcu.load_mesh_vfn(\"bunny.ply\") ### Option 1: ### Generating points according to a blue noise distribution with a target number of points ### NOTE: The number of returned points may not be exactly 1000 target_num_pts= 1000 # Generate barycentric coordinates of random samples fid, bc = pcu.sample_mesh_poisson_disk(v, f, num_samples=target_num_pts) # Interpolate the vertex positions and normals using the returned barycentric coordinates # to get sample positions and normals rand_positions = pcu.interpolate_barycentric_coords(f, fid, bc, v) rand_normals = pcu.interpolate_barycentric_coords(f, fid, bc, n) ### Option 2: ### Generating points according to a blue noise distribution with a target nradius separating each point target_radius = np.linalg.norm(p.max(0) - p.min(0)) * 0.01 # 1% of the bounding box radius # Generate barycentric coordinates of random samples fid, bc = pcu.sample_mesh_poisson_disk(v, f, num_samples=-1, radius=target_radius) # Interpolate the vertex positions and normals using the returned barycentric coordinates # to get sample positions and normals rand_positions = pcu.interpolate_barycentric_coords(f, fid, bc, v) rand_normals = pcu.interpolate_barycentric_coords(f, fid, bc, n) Generating blue noise samples on a mesh using a target number of points (left) and a target radius (right).","title":"Generating Point Samples on a Mesh"},{"location":"sections/mesh_sampling/#mesh-sampling","text":"Point Cloud Utils provides tools for generating point samples on a triangle mesh. Data in examples In all the examples, below we first load the point cloud here Representing mesh-surface samples in Point Cloud Utils Point Cloud Utils returns samples on the surface of a mesh using Barycentric Coordinates . i.e. each sample is encoded as: The index of the mesh face containing it (usually referred to as fid ) The barycentric coordinates of the point within that face (usually referred to as bc ) The reason for encoding points in this way is that it allows us to interpolate any quantity stored at the vertices (including their positions) of a mesh to the sample positions, and thus sample vertex attributes. To recover vertex quantities from fid , bc pairs use the function pcu.interpolate_barycentric_coords(f, fid, bc, vertex_quantity)","title":"Mesh Sampling"},{"location":"sections/mesh_sampling/#generating-random-samples-on-a-mesh","text":"We often want to sample points uniformly at random on a 3D surface. Point Cloud Utils provides a simple function for generating iid point samples such that each sample has equal probability of landing anywhere on the surface. import point_cloud_utils as pcu # v is a [n, 3] shaped NumPy array of vertices # f is a [m, 3] shaped integer NumPy array of indices into v # n is a [n, 3] shaped NumPy array of vertex normals v, f, n = pcu.load_mesh_vfn(\"bunny.ply\") # Generate barycentric coordinates of random samples num_samples = 1000 fid, bc = pcu.sample_mesh_random(v, f, num_samples) # Interpolate the vertex positions and normals using the returned barycentric coordinates # to get sample positions and normals rand_positions = pcu.interpolate_barycentric_coords(f, fid, bc, v) rand_normals = pcu.interpolate_barycentric_coords(f, fid, bc, n) Generating random (yellow) points on the mesh. We can also extract vertex attributes such as normals (pink arrows) at the points.","title":"Generating random samples on a mesh"},{"location":"sections/mesh_sampling/#generating-blue-noise-random-samples-on-a-mesh","text":"We may want to sample a surface in a random way such that the samples are evenly spaced apart. Such a distribution of points is called a \"blue noise\" distribution. Formally, this means that the expected distance between points on the surface is some constant. i.e. for a set of points \\(P\\) : $$ \\mathbb{E}_{x \\in P} ||x - \\text{nearest_neighbor}(x)|| = \\epsilon $$ This can be achieved with Poisson Disk Sampling. Point cloud utils supports sampling a mesh such that there are either (1) a target number of points or (2) such that the points are separated by some radius. import point_cloud_utils as pcu import numpy as np # v is a [n, 3] shaped NumPy array of vertices # f is a [m, 3] shaped integer NumPy array of indices into v # n is a [n, 3] shaped NumPy array of vertex normals v, f, n = pcu.load_mesh_vfn(\"bunny.ply\") ### Option 1: ### Generating points according to a blue noise distribution with a target number of points ### NOTE: The number of returned points may not be exactly 1000 target_num_pts= 1000 # Generate barycentric coordinates of random samples fid, bc = pcu.sample_mesh_poisson_disk(v, f, num_samples=target_num_pts) # Interpolate the vertex positions and normals using the returned barycentric coordinates # to get sample positions and normals rand_positions = pcu.interpolate_barycentric_coords(f, fid, bc, v) rand_normals = pcu.interpolate_barycentric_coords(f, fid, bc, n) ### Option 2: ### Generating points according to a blue noise distribution with a target nradius separating each point target_radius = np.linalg.norm(p.max(0) - p.min(0)) * 0.01 # 1% of the bounding box radius # Generate barycentric coordinates of random samples fid, bc = pcu.sample_mesh_poisson_disk(v, f, num_samples=-1, radius=target_radius) # Interpolate the vertex positions and normals using the returned barycentric coordinates # to get sample positions and normals rand_positions = pcu.interpolate_barycentric_coords(f, fid, bc, v) rand_normals = pcu.interpolate_barycentric_coords(f, fid, bc, n) Generating blue noise samples on a mesh using a target number of points (left) and a target radius (right).","title":"Generating blue-noise random samples on a mesh"},{"location":"sections/mesh_sdf/","text":"Computing Signed Distances to Triangle Meshes Many applications require a signed distance function (SDF) representation for a 3D shape . For example, many shape reconstruction neural networks such as DeepSDF require such a representation for training. Unfortunately, most 3D shape data is stored as a triangle mesh, making SDFs not readily available. Point-Cloud-Utils makes it very easy to extract signed distances from a triangle mesh. Remark about mesh quality To extract an SDF for a triangle mesh, the mesh must be of relatively good quality (manifold, watertight, no sliver triangles, etc...). To clean up a mesh for SDF extraction see Making a triangle mesh watertight . SDF Overview A signed distance function \\(f : \\mathbb{R}^3 \\rightarrow \\mathbb{R}\\) maps 3D points \\(x \\in \\mathbb{R}^3\\) to the nearest distance between \\(x\\) and some surface \\(S\\) . In other words: $$ f(x) = \\min_{x' \\in S} |x - x'|_2 $$ The zero level set of the SDF \\(f\\) are precisely the set of points which lie on the surface. i.e. $$ S = {x : f(x) = 0} $$ The image below shows a plot of the SDF for the boundary of the letters PCU. Level sets of the signed distance function for the letters PCU. The zero level set (surface) is colored as a white line. Computing an SDF from a triangle mesh We can compute the signed distance of a set of points in Point-Cloud-Utils in the following way: import numpy as np import point_cloud_utils as pcu # 1000 random query points to compute the SDF at query_pts = np.random.rand(1000, 3) v, f = pcu.load_mesh_vf(\"bunny.ply\") # sdf is the signed distance for each query point # fid is the nearest face to each query point on the mesh # bc are the barycentric coordinates of the nearest point to each query point within the face sdf, fid, bc = pcu.signed_distance_to_mesh(query_pts, v, f) Below we plot the sampled points colored by their SDF values: A thousand points sammpled around the bunny colored by their signed distance values.","title":"Computing SDFs from Triangle Meshes"},{"location":"sections/mesh_sdf/#computing-signed-distances-to-triangle-meshes","text":"Many applications require a signed distance function (SDF) representation for a 3D shape . For example, many shape reconstruction neural networks such as DeepSDF require such a representation for training. Unfortunately, most 3D shape data is stored as a triangle mesh, making SDFs not readily available. Point-Cloud-Utils makes it very easy to extract signed distances from a triangle mesh. Remark about mesh quality To extract an SDF for a triangle mesh, the mesh must be of relatively good quality (manifold, watertight, no sliver triangles, etc...). To clean up a mesh for SDF extraction see Making a triangle mesh watertight .","title":"Computing Signed Distances to Triangle Meshes"},{"location":"sections/mesh_sdf/#sdf-overview","text":"A signed distance function \\(f : \\mathbb{R}^3 \\rightarrow \\mathbb{R}\\) maps 3D points \\(x \\in \\mathbb{R}^3\\) to the nearest distance between \\(x\\) and some surface \\(S\\) . In other words: $$ f(x) = \\min_{x' \\in S} |x - x'|_2 $$ The zero level set of the SDF \\(f\\) are precisely the set of points which lie on the surface. i.e. $$ S = {x : f(x) = 0} $$ The image below shows a plot of the SDF for the boundary of the letters PCU. Level sets of the signed distance function for the letters PCU. The zero level set (surface) is colored as a white line.","title":"SDF Overview"},{"location":"sections/mesh_sdf/#computing-an-sdf-from-a-triangle-mesh","text":"We can compute the signed distance of a set of points in Point-Cloud-Utils in the following way: import numpy as np import point_cloud_utils as pcu # 1000 random query points to compute the SDF at query_pts = np.random.rand(1000, 3) v, f = pcu.load_mesh_vf(\"bunny.ply\") # sdf is the signed distance for each query point # fid is the nearest face to each query point on the mesh # bc are the barycentric coordinates of the nearest point to each query point within the face sdf, fid, bc = pcu.signed_distance_to_mesh(query_pts, v, f) Below we plot the sampled points colored by their SDF values: A thousand points sammpled around the bunny colored by their signed distance values.","title":"Computing an SDF from a triangle mesh"},{"location":"sections/mesh_smoothing/","text":"","title":"Mesh Smoothing"},{"location":"sections/point_cloud_normal_estimation/","text":"Estimating Normals for a Point Cloud Point clouds aqcuired from 3D sensors often do not come equipped with surface normals. Sensors can, however, always provide a direction vector pointing from a scanned point to origin of the scanner. Point-Cloud-Utils can estimate normals for 3D point clouds, and orient these normals when the user provides sensor direction vectors. The method fits a plane in the neigbhorhood of each point using principle component analysis , and assigns the fitted plane normal to the point. If sensor directions are provided, the normal is flipped to have the same orientation as the sensor direction. 2D Sketch of normal estimation. We fit the purple plane using PCA to the red points. The center point is assigned the normal of the fitted plane. If (gray-dotted) sensor-directions are passed in, we orient the normal to point towards the sensor. Sensor directions are optional You don't have to pass in sensor directions but then the normals will not be consistently oriented. You should usually be able to get sensor directions from point cloud scans. Estimating Normals using k-Nearest-Neighbors The following code uses the k-nearest neighbors to a point to contruct a local neighborhood for fitting a plane. import point_cloud_utils as pcu # sensor_dirs are stored in the normal channel and are encoded as unit # vectors pointing from the point to the scanner pts, sensor_dirs = pcu.load_mesh_vf(\"point_with_sensor_dirs.ply\") # Optionally delete point whose normal is at an oblique (greather than 85 degree) angle with the sensor direction drop_angle = np.deg2rad(85.0) # Size of the neighborhood used for each point num_nbrs = 32 # n are the fitted normals # n_idx are used to delete points which were filterd (ignore this if you don't pass in drop_angle) _, n = pcu.estimate_normals_knn(pts, num_nbrs, view_dirs=sensor_dirs) Left: Input point cloud with directions to sensors (pink arrows). Right: Predicted normals for point cloud (green arrows) using fitted planes to k-nearest neighbors. Filterting out points with oblique angles to the sensor You can optionally filter out points whose predicted normal angle is close to 90 degrees to the sensor direction. This can prevent certain types of noise when reconstructing a surface from oriented points. import point_cloud_utils as pcu # sensor_dirs are stored in the normal channel and are encoded as unit # vectors pointing from the point to the scanner pts, sensor_dirs = pcu.load_mesh_vf(\"point_with_sensor_dirs.ply\") # Optionally delete point whose normal is at an oblique (greather than 85 degree) angle with the sensor direction drop_angle = np.deg2rad(85.0) # Size of the neighborhood used for each point num_nbrs = 32 # n are the fitted normals # n_idx are used to delete points which were filterd (ignore this if you don't pass in drop_angle) n_idx, n = pcu.estimate_normals_knn(pts, num_nbrs, view_dirs=sensor_dirs, drop_angle_threshold=drop_angle) # Only include points which were not dropped pts_n = pts[n_idx] Estimating Normals using a Radius The following code uses neighbors within a ball around a point to contruct a local neighborhood for fitting a plane. import point_cloud_utils as pcu # sensor_dirs are stored in the normal channel and are encoded as unit # vectors pointing from the point to the scanner pts, sensor_dirs = pcu.load_mesh_vf(\"point_with_sensor_dirs.ply\") # Optionally delete point whose normal is at an oblique (greather than 85 degree) angle with the sensor direction drop_angle = np.deg2rad(85.0) # Size of the neighborhood used for each point ball_radius = 0.015 # n are the fitted normals _, n = pcu.estimate_normals_knn(pts, ball_radius, view_dirs=sensor_dirs) Left: Input point cloud with directions to sensors (pink arrows). Right: Predicted normals for point cloud (green arrows) using planes fitted inside a ball neighborhood. Filterting out points with oblique angles to the sensor You can optionally filter out points whose predicted normal angle is close to 90 degrees to the sensor direction. This can prevent certain types of noise when reconstructing a surface from oriented points. import point_cloud_utils as pcu # sensor_dirs are stored in the normal channel and are encoded as unit # vectors pointing from the point to the scanner pts, sensor_dirs = pcu.load_mesh_vf(\"point_with_sensor_dirs.ply\") # Optionally delete point whose normal is at an oblique (greather than 85 degree) angle with the sensor direction drop_angle = np.deg2rad(85.0) # Size of the neighborhood used for each point ball_radius = 0.015 # n are the fitted normals # n_idx are used to delete points which were filterd (ignore this if you don't pass in drop_angle) n_idx, n = pcu.estimate_normals_ball(pts, ball_radius, view_dirs=sensor_dirs, drop_angle_threshold=drop_angle) # Only include points which were not dropped pts_n = pts[n_idx]","title":"Estimating Normals for a Point Cloud"},{"location":"sections/point_cloud_normal_estimation/#estimating-normals-for-a-point-cloud","text":"Point clouds aqcuired from 3D sensors often do not come equipped with surface normals. Sensors can, however, always provide a direction vector pointing from a scanned point to origin of the scanner. Point-Cloud-Utils can estimate normals for 3D point clouds, and orient these normals when the user provides sensor direction vectors. The method fits a plane in the neigbhorhood of each point using principle component analysis , and assigns the fitted plane normal to the point. If sensor directions are provided, the normal is flipped to have the same orientation as the sensor direction. 2D Sketch of normal estimation. We fit the purple plane using PCA to the red points. The center point is assigned the normal of the fitted plane. If (gray-dotted) sensor-directions are passed in, we orient the normal to point towards the sensor. Sensor directions are optional You don't have to pass in sensor directions but then the normals will not be consistently oriented. You should usually be able to get sensor directions from point cloud scans.","title":"Estimating Normals for a Point Cloud"},{"location":"sections/point_cloud_normal_estimation/#estimating-normals-using-k-nearest-neighbors","text":"The following code uses the k-nearest neighbors to a point to contruct a local neighborhood for fitting a plane. import point_cloud_utils as pcu # sensor_dirs are stored in the normal channel and are encoded as unit # vectors pointing from the point to the scanner pts, sensor_dirs = pcu.load_mesh_vf(\"point_with_sensor_dirs.ply\") # Optionally delete point whose normal is at an oblique (greather than 85 degree) angle with the sensor direction drop_angle = np.deg2rad(85.0) # Size of the neighborhood used for each point num_nbrs = 32 # n are the fitted normals # n_idx are used to delete points which were filterd (ignore this if you don't pass in drop_angle) _, n = pcu.estimate_normals_knn(pts, num_nbrs, view_dirs=sensor_dirs) Left: Input point cloud with directions to sensors (pink arrows). Right: Predicted normals for point cloud (green arrows) using fitted planes to k-nearest neighbors.","title":"Estimating Normals using k-Nearest-Neighbors"},{"location":"sections/point_cloud_normal_estimation/#filterting-out-points-with-oblique-angles-to-the-sensor","text":"You can optionally filter out points whose predicted normal angle is close to 90 degrees to the sensor direction. This can prevent certain types of noise when reconstructing a surface from oriented points. import point_cloud_utils as pcu # sensor_dirs are stored in the normal channel and are encoded as unit # vectors pointing from the point to the scanner pts, sensor_dirs = pcu.load_mesh_vf(\"point_with_sensor_dirs.ply\") # Optionally delete point whose normal is at an oblique (greather than 85 degree) angle with the sensor direction drop_angle = np.deg2rad(85.0) # Size of the neighborhood used for each point num_nbrs = 32 # n are the fitted normals # n_idx are used to delete points which were filterd (ignore this if you don't pass in drop_angle) n_idx, n = pcu.estimate_normals_knn(pts, num_nbrs, view_dirs=sensor_dirs, drop_angle_threshold=drop_angle) # Only include points which were not dropped pts_n = pts[n_idx]","title":"Filterting out points with oblique angles to the sensor"},{"location":"sections/point_cloud_normal_estimation/#estimating-normals-using-a-radius","text":"The following code uses neighbors within a ball around a point to contruct a local neighborhood for fitting a plane. import point_cloud_utils as pcu # sensor_dirs are stored in the normal channel and are encoded as unit # vectors pointing from the point to the scanner pts, sensor_dirs = pcu.load_mesh_vf(\"point_with_sensor_dirs.ply\") # Optionally delete point whose normal is at an oblique (greather than 85 degree) angle with the sensor direction drop_angle = np.deg2rad(85.0) # Size of the neighborhood used for each point ball_radius = 0.015 # n are the fitted normals _, n = pcu.estimate_normals_knn(pts, ball_radius, view_dirs=sensor_dirs) Left: Input point cloud with directions to sensors (pink arrows). Right: Predicted normals for point cloud (green arrows) using planes fitted inside a ball neighborhood.","title":"Estimating Normals using a Radius"},{"location":"sections/point_cloud_normal_estimation/#filterting-out-points-with-oblique-angles-to-the-sensor_1","text":"You can optionally filter out points whose predicted normal angle is close to 90 degrees to the sensor direction. This can prevent certain types of noise when reconstructing a surface from oriented points. import point_cloud_utils as pcu # sensor_dirs are stored in the normal channel and are encoded as unit # vectors pointing from the point to the scanner pts, sensor_dirs = pcu.load_mesh_vf(\"point_with_sensor_dirs.ply\") # Optionally delete point whose normal is at an oblique (greather than 85 degree) angle with the sensor direction drop_angle = np.deg2rad(85.0) # Size of the neighborhood used for each point ball_radius = 0.015 # n are the fitted normals # n_idx are used to delete points which were filterd (ignore this if you don't pass in drop_angle) n_idx, n = pcu.estimate_normals_ball(pts, ball_radius, view_dirs=sensor_dirs, drop_angle_threshold=drop_angle) # Only include points which were not dropped pts_n = pts[n_idx]","title":"Filterting out points with oblique angles to the sensor"},{"location":"sections/point_cloud_resampling/","text":"Point Cloud Re-Sampling Point Cloud Utils provides tools for re-sampling a point cloud in several ways. Data in examples In all the examples, below we first load the point cloud here Binning points in a voxel grid In many 3D tasks, it is often advantageous to quantize a point cloud to a regular voxel grid in space. Such quantization can reduce the number of input points to an algorithm to match the resolution at which that algorithm operates. Point Cloud Utils provides a simple function for quantizing a point cloud with arbitrary attributes into a voxel grid. Attributes are averaged within a voxel. The code below shows an example of this functionality with the figure showing the result. import point_cloud_utils as pcu # v is a [n, 3] shaped NumPy array of vertices # n is a [n, 3] NumPy array of vertex normals p, n = pcu.load_mesh_vnc(\"wheel.ply\") # We'll quantize our point cloud to a voxel grid with 128 voxels per axis num_voxels_per_axis = 128 # Size of the axis aligned bounding box of the point cloud bbox_size = p.max(0) - p.min(0) # The size per-axis of a single voxel sizeof_voxel = bbox_size / num_voxels_per_axis # Downsample a point cloud on a voxel grid so there is at most one point per voxel. # Any arguments after the points are treated as attribute arrays and get averaged within each voxel v_sampled, n_sampled = pcu.downsample_point_cloud_on_voxel_grid(sizeof_voxel, p, n) Downsampling the blue point cloud by averaging points within each voxel. The yellow points are the downsampled points. The right image shows the downsampled normals. Downsampling a point cloud to have a blue noise distribution If we have a dense point cloud, we may want to downsample it to sparse point cloud where all points are about evenly spaced apart. Such a distribution of points is called a \"blue noise\" distribution. Formally, this means that the expected distance between points on the surface is some constant. i.e. for a point cloud \\(P\\) : $$ \\mathbb{E}_{x \\in P} ||x - \\text{nearest_neighbor}(x)|| = \\epsilon $$ This can be achieved with Poisson Disk Sampling. Point cloud utils supports downsampling a point cloud to a target radius or to a target number of points Downsampling a points to a blue noise distribution with a target number of points import point_cloud_utils as pcu import numpy as np # v is a [n, 3] shaped NumPy array of vertices # n is a [n, 3] NumPy array of vertex normals p, n = pcu.load_mesh_vn(\"wheel.ply\") ### Option 1: ### Downsampling a points to a blue noise distribution with a target number of points # idx is an array of integer indices into v indicating which samples to keep target_num_pts= int(0.1*p.shape[0]) # 10% of the number of input points idx = pcu.downsample_point_cloud_poisson_disk(p, num_samples=target_num_pts) ### Option 2: ### Downsampling a points to a blue noise distribution with a target radius # idx is an array of integer indices into v indicating which samples to keep target_radius = np.linalg.norm(p.max(0) - p.min(0)) * 0.02 # 2% of the bounding box radius idx = pcu.downsample_point_cloud_poisson_disk(p, -1, radius=target_radius) # Use the indices to get the sample positions and normals v_sampled = p[idx] n_sampled = n[idx] Downsampling the blue point cloud according to a blue noise distribution so that the resulting points (yellow) are approximately evenly spaced Deduplicating a point cloud You can deduplicate a point cloud by removing vertices that are equal up to some threshold. The example below removes duplicate points with a threshold of \\(10^{-1}\\) import point_cloud_utils as pcu # p is a (n, 3)-shaped array of points (one per row) # p is a (n, 3)-shaped array of normals at each point p, n = pcu.load_mesh_vn(\"my_pcloud.ply\") # Treat any points closer than 1e-7 apart as the same point # idx_i is an array of indices such that p_dedup = p[idx_i] # idx_j is an array of indices such that p = p_dedup[idx_j] p_dedup, idx_i, idx_j = pcu.deduplicate_point_cloud(p, 1e-7) # Use idx_i to deduplicate the normals n_dedup = n[idx_i]","title":"Point Cloud Resampling"},{"location":"sections/point_cloud_resampling/#point-cloud-re-sampling","text":"Point Cloud Utils provides tools for re-sampling a point cloud in several ways. Data in examples In all the examples, below we first load the point cloud here","title":"Point Cloud Re-Sampling"},{"location":"sections/point_cloud_resampling/#binning-points-in-a-voxel-grid","text":"In many 3D tasks, it is often advantageous to quantize a point cloud to a regular voxel grid in space. Such quantization can reduce the number of input points to an algorithm to match the resolution at which that algorithm operates. Point Cloud Utils provides a simple function for quantizing a point cloud with arbitrary attributes into a voxel grid. Attributes are averaged within a voxel. The code below shows an example of this functionality with the figure showing the result. import point_cloud_utils as pcu # v is a [n, 3] shaped NumPy array of vertices # n is a [n, 3] NumPy array of vertex normals p, n = pcu.load_mesh_vnc(\"wheel.ply\") # We'll quantize our point cloud to a voxel grid with 128 voxels per axis num_voxels_per_axis = 128 # Size of the axis aligned bounding box of the point cloud bbox_size = p.max(0) - p.min(0) # The size per-axis of a single voxel sizeof_voxel = bbox_size / num_voxels_per_axis # Downsample a point cloud on a voxel grid so there is at most one point per voxel. # Any arguments after the points are treated as attribute arrays and get averaged within each voxel v_sampled, n_sampled = pcu.downsample_point_cloud_on_voxel_grid(sizeof_voxel, p, n) Downsampling the blue point cloud by averaging points within each voxel. The yellow points are the downsampled points. The right image shows the downsampled normals.","title":"Binning points in a voxel grid"},{"location":"sections/point_cloud_resampling/#downsampling-a-point-cloud-to-have-a-blue-noise-distribution","text":"If we have a dense point cloud, we may want to downsample it to sparse point cloud where all points are about evenly spaced apart. Such a distribution of points is called a \"blue noise\" distribution. Formally, this means that the expected distance between points on the surface is some constant. i.e. for a point cloud \\(P\\) : $$ \\mathbb{E}_{x \\in P} ||x - \\text{nearest_neighbor}(x)|| = \\epsilon $$ This can be achieved with Poisson Disk Sampling. Point cloud utils supports downsampling a point cloud to a target radius or to a target number of points Downsampling a points to a blue noise distribution with a target number of points import point_cloud_utils as pcu import numpy as np # v is a [n, 3] shaped NumPy array of vertices # n is a [n, 3] NumPy array of vertex normals p, n = pcu.load_mesh_vn(\"wheel.ply\") ### Option 1: ### Downsampling a points to a blue noise distribution with a target number of points # idx is an array of integer indices into v indicating which samples to keep target_num_pts= int(0.1*p.shape[0]) # 10% of the number of input points idx = pcu.downsample_point_cloud_poisson_disk(p, num_samples=target_num_pts) ### Option 2: ### Downsampling a points to a blue noise distribution with a target radius # idx is an array of integer indices into v indicating which samples to keep target_radius = np.linalg.norm(p.max(0) - p.min(0)) * 0.02 # 2% of the bounding box radius idx = pcu.downsample_point_cloud_poisson_disk(p, -1, radius=target_radius) # Use the indices to get the sample positions and normals v_sampled = p[idx] n_sampled = n[idx] Downsampling the blue point cloud according to a blue noise distribution so that the resulting points (yellow) are approximately evenly spaced","title":"Downsampling a point cloud to have a blue noise distribution"},{"location":"sections/point_cloud_resampling/#deduplicating-a-point-cloud","text":"You can deduplicate a point cloud by removing vertices that are equal up to some threshold. The example below removes duplicate points with a threshold of \\(10^{-1}\\) import point_cloud_utils as pcu # p is a (n, 3)-shaped array of points (one per row) # p is a (n, 3)-shaped array of normals at each point p, n = pcu.load_mesh_vn(\"my_pcloud.ply\") # Treat any points closer than 1e-7 apart as the same point # idx_i is an array of indices such that p_dedup = p[idx_i] # idx_j is an array of indices such that p = p_dedup[idx_j] p_dedup, idx_i, idx_j = pcu.deduplicate_point_cloud(p, 1e-7) # Use idx_i to deduplicate the normals n_dedup = n[idx_i]","title":"Deduplicating a point cloud"},{"location":"sections/ray_mesh_intersection/","text":"","title":"Ray/Mesh Intersection"},{"location":"sections/ray_surfel_intersection/","text":"","title":"Ray/Surfel Intersection"},{"location":"sections/shape_metrics/","text":"Shape Metrics Point Cloud Utils has functions to compute a number of commonly used metrics between point clouds. Chamfer Distance The Chamfer distance between two point clouds \\(P_1 = \\{x_i \\in \\mathbb{R}^3\\}_{i=1}^n\\) and \\(P_2 = \\{x_j \\in \\mathbb{R}^3\\}_{j=1}^m\\) is defined as the average distance between pairs of nearest neighbors between \\(P_1\\) and \\(P_2\\) i.e. $$ \\text{chamfer}(P_1, P_2) = \\frac{1}{2n} \\sum_{i=1}^n |x_i - \\text{NN}(x_i, P_2)| + \\frac{1}{2m} \\sum_{j=1}^n |x_j - \\text{NN}(x_j, P_1)| $$ and \\(\\text{NN}(x, P) = \\text{argmin}_{x' \\in P} \\|x - x'\\|\\) is the nearest neighbor function. The following code computes the Chamfer distance between two point clouds: import point_cloud_utils as pcu # p1 is an (n, 3)-shaped numpy array containing one point per row p1 = pcu.load_mesh_v(\"point_cloud_1.ply\") # p2 is an (m, 3)-shaped numpy array containing one point per row p2 = pcu.load_mesh_v(\"point_cloud_2.ply\") # Compute the chamfer distance between p1 and p2 cd = pcu.chamfer_distance(p1, p2) Hausdorff distance The Hausdorff distance between two point clouds \\(P_1 = \\{x_i \\in \\mathbb{R}^3\\}_{i=1}^n\\) and \\(P_2 = \\{x_j \\in \\mathbb{R}^3\\}_{j=1}^m\\) is defined as the maxmimum distance between any pair of nearest neighbors between \\(P_1\\) and \\(P_2\\) i.e. $$ \\text{hausdorff}(P_1, P_2) = \\frac{1}{2} \\max_{x \\in P_1} |x - \\text{NN}(x, P_2)| + \\frac{1}{2} \\max_{x' \\in P_2} |x' - \\text{NN}(x', P_1)| $$ and \\(\\text{NN}(x, P) = \\text{argmin}_{x' \\in P} \\|x - x'\\|\\) is the nearest neighbor function. The following code computes the Hausdorff distance between two point clouds: import point_cloud_utils as pcu # p1 is an (n, 3)-shaped numpy array containing one point per row p1 = pcu.load_mesh_v(\"point_cloud_1.ply\") # p2 is an (m, 3)-shaped numpy array containing one point per row p2 = pcu.load_mesh_v(\"point_cloud_2.ply\") # Compute the chamfer distance between p1 and p2 hd = pcu.hausdorff_distance(p1, p2) One sided Hausdorff distance In some applications, one only needs the one-sided Hausdorff distance between \\(P_1\\) and \\(P_2\\) , i.e. \\[ \\text{hausdorff}_{P_1 \\rightarrow P_2}(P_1, P_2) = \\max_{x \\in P_1} \\|x - \\text{NN}(x, P_2)\\| \\] The following code computes the one-sided Hausdorff distance between two point clouds: import point_cloud_utils as pcu # p1 is an (n, 3)-shaped numpy array containing one point per row p1 = pcu.load_mesh_v(\"point_cloud_1.ply\") # p2 is an (m, 3)-shaped numpy array containing one point per row p2 = pcu.load_mesh_v(\"point_cloud_2.ply\") # Compute the chamfer distance between p1 and p2 hd_p1_to_p2 = pcu.one_sided_hausdorff_distance(p1, p2) Note To get the \\(P_2 \\rightarrow P_1\\) Hausdorff distance, just swap the arguments to pcu.one_sided_hausdorff_distance Earth-Mover's (Sinkhorn) distance The Earth Mover's distance between two point clouds \\(P = \\{p_i \\in \\mathbb{R}^3\\}_{i=1}^n\\) and \\(Q = \\{q_j \\in \\mathbb{R}^3\\}_{j=1}^m\\) is computed as the average distance between pairs of points according to an optimal correspondence \\(\\pi \\in \\Pi(P, Q)\\) , where \\(\\Pi(P, Q)\\) is the set of \\(n \\times m\\) matrices where the rows and columns sum to one. The assignment \\(\\pi\\) is thus a matrix where \\(\\Pi_{i,j}\\) is a number between \\(0\\) and \\(1\\) denoting how much point \\(p_i\\) and \\(q_j\\) correspond. We can write the EMD formally as: $$ \\text{EMD}(P, Q) = \\min_{\\pi \\in \\Pi(P, Q)} \\sum_{i = 1}^n \\sum_{j = 1}^m \\pi_{i,j} |p_i - q_j| % \\langle \\pi, D \\rangle \\qquad D_{ij} = |p_i - q_j| $$ Point Cloud Utils implements the sinkhorn algorithm for computing the (approximate) Earth Mover's Distance. To compute the EMD, run: import point_cloud_utils as pcu # p1 is an (n, 3)-shaped numpy array containing one point per row p1 = pcu.load_mesh_v(\"point_cloud_1.ply\") # p2 is an (m, 3)-shaped numpy array containing one point per row p2 = pcu.load_mesh_v(\"point_cloud_2.ply\") # Compute the chamfer distance between p1 and p2 emd, pi = pcu.earth_movers_distance(p1, p2)","title":"Shape Metrics"},{"location":"sections/shape_metrics/#shape-metrics","text":"Point Cloud Utils has functions to compute a number of commonly used metrics between point clouds.","title":"Shape Metrics"},{"location":"sections/shape_metrics/#chamfer-distance","text":"The Chamfer distance between two point clouds \\(P_1 = \\{x_i \\in \\mathbb{R}^3\\}_{i=1}^n\\) and \\(P_2 = \\{x_j \\in \\mathbb{R}^3\\}_{j=1}^m\\) is defined as the average distance between pairs of nearest neighbors between \\(P_1\\) and \\(P_2\\) i.e. $$ \\text{chamfer}(P_1, P_2) = \\frac{1}{2n} \\sum_{i=1}^n |x_i - \\text{NN}(x_i, P_2)| + \\frac{1}{2m} \\sum_{j=1}^n |x_j - \\text{NN}(x_j, P_1)| $$ and \\(\\text{NN}(x, P) = \\text{argmin}_{x' \\in P} \\|x - x'\\|\\) is the nearest neighbor function. The following code computes the Chamfer distance between two point clouds: import point_cloud_utils as pcu # p1 is an (n, 3)-shaped numpy array containing one point per row p1 = pcu.load_mesh_v(\"point_cloud_1.ply\") # p2 is an (m, 3)-shaped numpy array containing one point per row p2 = pcu.load_mesh_v(\"point_cloud_2.ply\") # Compute the chamfer distance between p1 and p2 cd = pcu.chamfer_distance(p1, p2)","title":"Chamfer Distance"},{"location":"sections/shape_metrics/#hausdorff-distance","text":"The Hausdorff distance between two point clouds \\(P_1 = \\{x_i \\in \\mathbb{R}^3\\}_{i=1}^n\\) and \\(P_2 = \\{x_j \\in \\mathbb{R}^3\\}_{j=1}^m\\) is defined as the maxmimum distance between any pair of nearest neighbors between \\(P_1\\) and \\(P_2\\) i.e. $$ \\text{hausdorff}(P_1, P_2) = \\frac{1}{2} \\max_{x \\in P_1} |x - \\text{NN}(x, P_2)| + \\frac{1}{2} \\max_{x' \\in P_2} |x' - \\text{NN}(x', P_1)| $$ and \\(\\text{NN}(x, P) = \\text{argmin}_{x' \\in P} \\|x - x'\\|\\) is the nearest neighbor function. The following code computes the Hausdorff distance between two point clouds: import point_cloud_utils as pcu # p1 is an (n, 3)-shaped numpy array containing one point per row p1 = pcu.load_mesh_v(\"point_cloud_1.ply\") # p2 is an (m, 3)-shaped numpy array containing one point per row p2 = pcu.load_mesh_v(\"point_cloud_2.ply\") # Compute the chamfer distance between p1 and p2 hd = pcu.hausdorff_distance(p1, p2)","title":"Hausdorff distance"},{"location":"sections/shape_metrics/#one-sided-hausdorff-distance","text":"In some applications, one only needs the one-sided Hausdorff distance between \\(P_1\\) and \\(P_2\\) , i.e. \\[ \\text{hausdorff}_{P_1 \\rightarrow P_2}(P_1, P_2) = \\max_{x \\in P_1} \\|x - \\text{NN}(x, P_2)\\| \\] The following code computes the one-sided Hausdorff distance between two point clouds: import point_cloud_utils as pcu # p1 is an (n, 3)-shaped numpy array containing one point per row p1 = pcu.load_mesh_v(\"point_cloud_1.ply\") # p2 is an (m, 3)-shaped numpy array containing one point per row p2 = pcu.load_mesh_v(\"point_cloud_2.ply\") # Compute the chamfer distance between p1 and p2 hd_p1_to_p2 = pcu.one_sided_hausdorff_distance(p1, p2) Note To get the \\(P_2 \\rightarrow P_1\\) Hausdorff distance, just swap the arguments to pcu.one_sided_hausdorff_distance","title":"One sided Hausdorff distance"},{"location":"sections/shape_metrics/#earth-movers-sinkhorn-distance","text":"The Earth Mover's distance between two point clouds \\(P = \\{p_i \\in \\mathbb{R}^3\\}_{i=1}^n\\) and \\(Q = \\{q_j \\in \\mathbb{R}^3\\}_{j=1}^m\\) is computed as the average distance between pairs of points according to an optimal correspondence \\(\\pi \\in \\Pi(P, Q)\\) , where \\(\\Pi(P, Q)\\) is the set of \\(n \\times m\\) matrices where the rows and columns sum to one. The assignment \\(\\pi\\) is thus a matrix where \\(\\Pi_{i,j}\\) is a number between \\(0\\) and \\(1\\) denoting how much point \\(p_i\\) and \\(q_j\\) correspond. We can write the EMD formally as: $$ \\text{EMD}(P, Q) = \\min_{\\pi \\in \\Pi(P, Q)} \\sum_{i = 1}^n \\sum_{j = 1}^m \\pi_{i,j} |p_i - q_j| % \\langle \\pi, D \\rangle \\qquad D_{ij} = |p_i - q_j| $$ Point Cloud Utils implements the sinkhorn algorithm for computing the (approximate) Earth Mover's Distance. To compute the EMD, run: import point_cloud_utils as pcu # p1 is an (n, 3)-shaped numpy array containing one point per row p1 = pcu.load_mesh_v(\"point_cloud_1.ply\") # p2 is an (m, 3)-shaped numpy array containing one point per row p2 = pcu.load_mesh_v(\"point_cloud_2.ply\") # Compute the chamfer distance between p1 and p2 emd, pi = pcu.earth_movers_distance(p1, p2)","title":"Earth-Mover's (Sinkhorn) distance"},{"location":"sections/watertight_manifold/","text":"Making a Mesh a Watertight Manifold Many algorithms in geometry processing require a mesh to be manifold , and watertight . For example, computing signed distances from meshes requires watertight shapes. Point-Cloud-Utils implements the Robust Watertight Manifold Surface Generation Method for ShapeNet Models algorithm by Huang et.al. for converting meshes to watertight manifolds. import point_cloud_utils as pcu v, f = pcu.load_mesh_vf(\"chair.ply\") # The resolution parameter controls the density of the output mesh # It is linearly proportional to the number of faces in the output # mesh. A higher value corresponds to a denser mesh. resolution = 50_000 vw, fw = pcu.make_mesh_watertight(v, f, resolution) The left mesh is non-manifold and non-watertight. The Manifold algorithm converts it to a watertight manifold on the left.","title":"Making a Mesh a Watertight Manifold"},{"location":"sections/watertight_manifold/#making-a-mesh-a-watertight-manifold","text":"Many algorithms in geometry processing require a mesh to be manifold , and watertight . For example, computing signed distances from meshes requires watertight shapes. Point-Cloud-Utils implements the Robust Watertight Manifold Surface Generation Method for ShapeNet Models algorithm by Huang et.al. for converting meshes to watertight manifolds. import point_cloud_utils as pcu v, f = pcu.load_mesh_vf(\"chair.ply\") # The resolution parameter controls the density of the output mesh # It is linearly proportional to the number of faces in the output # mesh. A higher value corresponds to a denser mesh. resolution = 50_000 vw, fw = pcu.make_mesh_watertight(v, f, resolution) The left mesh is non-manifold and non-watertight. The Manifold algorithm converts it to a watertight manifold on the left.","title":"Making a Mesh a Watertight Manifold"}]}