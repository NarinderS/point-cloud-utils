{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Point Cloud Utils is an easy-to-use Python library for processing and manipulating 3D point clouds and meshes. Note In spite of its name, Point Cloud Utils should really be thought of as a general purpose geometry library, used for more than operating on point clouds. Installation pip install point-cloud-utils Source Code Point Cloud Utils is open source under the MIT license. The source code is available on GitHub A very simple example Point Cloud Utils uses NumPy arrays as fundamental data structure, making it very easy to integrate with existing numerical code. For example, here's how to remove all points in a point cloud which are greater than some distance from a mesh. import point_cloud_utils as pcu # Load a mesh stored in my_mesh.ply: # v is a NumPy array of coordinates with shape (V, 3) # f is a NumPy array of face indices with shape (F, 3) v, f = pcu.load_mesh_vf(\"my_mesh.ply\") # Load a point cloud stored in my_point_cloud.ply: # p is a NumPy array of point coordinates with shape (P, 3) p = pcu.load_mesh_v(\"my_point_cloud.ply\") # Compute the shortest distance between each point in p and the mesh: # dists is a NumPy array of shape (P,) where dists[i] is the # shortest distnace between the point p[i, :] and the mesh (v, f) dists, _, _ = pcu.closest_points_on_mesh(p, v, f) # Delete all points which are farther than some distance away from the mesh dist_thresh = 0.1 keep_points = p[dists < dist_thresh] # Save the filtered point cloud to my_point_cloud_trimmed.ply pcu.save_mesh_v(\"my_point_cloud_trimmed.ply\", keep_points) Functionality Point Cloud Utils includes utilities to perform the following tasks: Mesh and Point Cloud I/O . Point Cloud Utils can handle any file that can be opened in MeshLab. Resampling Point Clouds to have different distributions. Generating Point Samples on a Mesh . Computing Metrics Between Point Clouds (e.g. Chamfer Distance, Hausdorff Distance, etc...). Making a Mesh a Watertight Manifold . Computing Signed Distances (SDFs) to Meshes . Estimating Normals for Point Clouds . Computing Mesh Normals . Ray/Mesh Intersection . Generating Surfels from Point Clouds . Smooting a Mesh . Decimating a Mesh . Finding Closest Points Between Point Clouds and Meshes . Computing Connected Components of a Mesh . Deduplicating Point Clouds and Meshes . Calculating Mesh Face Areas . Consistently Orienting Mesh Faces . Morton Encoding/Decoding a Point Cloud . Voxelizing a Triangle Mesh . Recipes for Common Tasks We include recipes for common geometry tasks that you should be able to copy paste into your existing codebase. These only depend on Point-Cloud-Utils, NumPy and the Python standard library making them very easy to integrate with your code. Cleaning ShapeNet and Generating an SDF Dataset API Reference All available functions and classes are listed in the API reference About Author: Francis Williams . Source Code: https://github.com/fwilliams/point-cloud-utils If Point Cloud Utils contributes to an academic publication, cite it as: @misc{point-cloud-utils, title = {Point Cloud Utils}, author = {Francis Williams}, note = {https://www.github.com/fwilliams/point-cloud-utils}, year = {2022} }","title":"Home"},{"location":"#installation","text":"pip install point-cloud-utils","title":"Installation"},{"location":"#source-code","text":"Point Cloud Utils is open source under the MIT license. The source code is available on GitHub","title":"Source Code"},{"location":"#a-very-simple-example","text":"Point Cloud Utils uses NumPy arrays as fundamental data structure, making it very easy to integrate with existing numerical code. For example, here's how to remove all points in a point cloud which are greater than some distance from a mesh. import point_cloud_utils as pcu # Load a mesh stored in my_mesh.ply: # v is a NumPy array of coordinates with shape (V, 3) # f is a NumPy array of face indices with shape (F, 3) v, f = pcu.load_mesh_vf(\"my_mesh.ply\") # Load a point cloud stored in my_point_cloud.ply: # p is a NumPy array of point coordinates with shape (P, 3) p = pcu.load_mesh_v(\"my_point_cloud.ply\") # Compute the shortest distance between each point in p and the mesh: # dists is a NumPy array of shape (P,) where dists[i] is the # shortest distnace between the point p[i, :] and the mesh (v, f) dists, _, _ = pcu.closest_points_on_mesh(p, v, f) # Delete all points which are farther than some distance away from the mesh dist_thresh = 0.1 keep_points = p[dists < dist_thresh] # Save the filtered point cloud to my_point_cloud_trimmed.ply pcu.save_mesh_v(\"my_point_cloud_trimmed.ply\", keep_points)","title":"A very simple example"},{"location":"#functionality","text":"Point Cloud Utils includes utilities to perform the following tasks: Mesh and Point Cloud I/O . Point Cloud Utils can handle any file that can be opened in MeshLab. Resampling Point Clouds to have different distributions. Generating Point Samples on a Mesh . Computing Metrics Between Point Clouds (e.g. Chamfer Distance, Hausdorff Distance, etc...). Making a Mesh a Watertight Manifold . Computing Signed Distances (SDFs) to Meshes . Estimating Normals for Point Clouds . Computing Mesh Normals . Ray/Mesh Intersection . Generating Surfels from Point Clouds . Smooting a Mesh . Decimating a Mesh . Finding Closest Points Between Point Clouds and Meshes . Computing Connected Components of a Mesh . Deduplicating Point Clouds and Meshes . Calculating Mesh Face Areas . Consistently Orienting Mesh Faces . Morton Encoding/Decoding a Point Cloud . Voxelizing a Triangle Mesh .","title":"Functionality"},{"location":"#recipes-for-common-tasks","text":"We include recipes for common geometry tasks that you should be able to copy paste into your existing codebase. These only depend on Point-Cloud-Utils, NumPy and the Python standard library making them very easy to integrate with your code. Cleaning ShapeNet and Generating an SDF Dataset","title":"Recipes for Common Tasks"},{"location":"#api-reference","text":"All available functions and classes are listed in the API reference","title":"API Reference"},{"location":"#about","text":"Author: Francis Williams . Source Code: https://github.com/fwilliams/point-cloud-utils If Point Cloud Utils contributes to an academic publication, cite it as: @misc{point-cloud-utils, title = {Point Cloud Utils}, author = {Francis Williams}, note = {https://www.github.com/fwilliams/point-cloud-utils}, year = {2022} }","title":"About"},{"location":"about/","text":"","title":"About"},{"location":"sections/api_reference/","text":"API Reference point_cloud_utils . MORTON_MAX point_cloud_utils . MORTON_MIN point_cloud_utils._ray_mesh_intersector.RayMeshIntersector Class used to find the intersection between rays and a triangle mesh. __init__ ( self , mesh_v , mesh_f ) special Create a RayMeshIntersector object which can be used to do ray/mesh queries with a triangle mesh. Parameters: mesh_v \u2013 #v by 3 array of vertex positions (each row is a vertex) mesh_f \u2013 #f by 3 Matrix of face (triangle) indices intersect_rays ( self , ray_o , ray_d , ray_near = 0.0 , ray_far = inf ) Compute intersection between a set of rays and the triangle mesh enclosed in this class Parameters: ray_o \u2013 array of shape (#rays, 3) of ray origins (one per row) or a single array of shape (3,) to use ray_d \u2013 array of shape (#rays, 3) of ray directions (one per row) ray_near \u2013 an optional floating point value indicating the distance along each ray to start searching (default 0.0) ray_far \u2013 an optional floating point value indicating the maximum distance along each ray to search (default inf) Returns: f_id \u2013 an array of shape (#rays,) representing the face id hit by each ray bc : an array of shape (#rays, 3) where each row is the barycentric coordinates within each face of the ray intersection t : the distance along each ray to the intersection point_cloud_utils._ray_point_cloud_intersector.RaySurfelIntersector Class used to find the intersection between rays and a point cloud converted to surfels (i.e. a point cloud represented as circles centered at each point and oriented perpendicularly to each normal). __init__ ( self , p , n , r = 0.1 , subdivs = 7 ) special Construct a RayPointCloudIntersector which can be used to compute the intersection between a set of rays and a point cloud converted to circular patches oriented with the point normals Parameters: p \u2013 #p by 3 array of vertex positions (each row is a vertex) n \u2013 #p by 3 Matrix of vertex normals (each row is a vertex) r \u2013 Array or Scalar describing the size of each geometry element (Either one radius per vertex, or a global size for the whole point cloud) subdivs \u2013 Number of times to subdivide the patch geometry for each point (i.e. # tris per cicle) intersect_rays ( self , ray_o , ray_d , ray_near = 0.0 , ray_far = inf ) Compute intersection between a set of rays and the point cloud converted to circular patches oriented with the point normals Parameters: ray_o \u2013 array of shape (#rays, 3) of ray origins (one per row) or a single array of shape (3,) to use ray_d \u2013 array of shape (#rays, 3) of ray directions (one per row) ray_near \u2013 an optional floating point value indicating the distance along each ray to start searching (default 0.0) ray_far \u2013 an optional floating point value indicating the maximum distance along each ray to search (default inf) Returns: t \u2013 a (#rays,) shaped array encoding the distance between the ray origin and intersection point for each ray (inf for missed rays) pid : a (#rays,) shaped array of integer indices corresponding to which points were hit (-1 for a ray miss) point_cloud_utils._mesh_io.TriangleMesh A lightweight container class representing a triangle mesh with attributes stored at each vertex, wedge, and face, where: A vertex is a 3D position A wedge is a vertex and its two adjacent edges A face is a triangle connecting 3 vertices (Each triangle has 3 vertices and 3 wedges). The data in encapsulated into vertex data and face data, accessible via TriangleMes.vertex_data and TriangleMesh.face_data respectively: TriangleMesh.vertex_data : positions : [V, 3]-shaped numpy array of per-vertex positions normals : [V, 3]-shaped numpy array of per-vertex normals (or None) texcoords : [V, 2]-shaped numpy array of per-vertex uv coordinates (or None) tex_ids : [V,]-shaped numpy array of integer indices into TriangleMesh.textures indicating which texture to use at this vertex (or None) colors : [V, 4]-shaped numpy array of per-vertex RBGA colors in [0.0, 1.0] (or None) radius : [V,]-shaped numpy array of per-vertex curvature radii (or None) quality : [V,]-shaped numpy array of per-vertex quality measures (or None) flags : [V,]-shaped numpy array of 32-bit integer flags per vertex (or None) TriangleMesh.face_data : vertex_ids : [F, 3]-shaped numpy array of integer face indices into TrianglMesh.vertex_data.positions normals : [F, 3]-shaped numpy array of per-face normals (or None) colors : [F, 4]-shaped numpy array of per-face RBGA colors in [0.0, 1.0] (or None) quality : [F,]-shaped numpy array of per-face quality measures (or None) flags : [F,]-shaped numpy array of 32-bit integer flags per face (or None) wedge_colors : [F, 3, 4]-shaped numpy array of per-wedge RBGA colors in [0.0, 1.0] (or None) wedge_normals : [F, 3, 3]-shaped numpy array of per-wedge normals (or None) wedge_texcoords : [F, 3, 2]-shaped numpy array of per-wedge] uv coordinates (or None) wedge_tex_ids : [F, 3]-shaped numpy array of integer indices into TriangleMesh.textures indicating which texture to use at this wedge (or None) textures : A list of paths to texture image files for this mesh normal_maps : A list of paths to texture image files for this mesh f property readonly An (m, 3)-shaped integer array containing this mesh's face indices (None if no faces) fc property readonly An (m, 4)-shaped array containing this mesh's per-face RBGA colors (None if no face colors) fn property readonly An (m, 3)-shaped array containing this mesh's per-face normals (None if no face normals) v property readonly An (n, 3)-shaped array containing this mesh's vertex positions vc property readonly An (n, 4)-shaped array containing this mesh's per-vertex RGBA (None if no vertex colors) vn property readonly An (n, 3)-shaped array containing this mesh's per-vertex normals (None if no vertex normals) FaceData A lightweight container class representing per-face information within a TriangleMesh with the following attributes vertex_ids : [F, 3]-shaped numpy array of integer face indices into TrianglMesh.vertex_data.positions normals : [F, 3]-shaped numpy array of per-face normals (or None) colors : [F, 4]-shaped numpy array of per-face RBGA colors in [0.0, 1.0] (or None) quality : [F,]-shaped numpy array of per-face quality measures (or None) flags : [F,]-shaped numpy array of 32-bit integer flags per face (or None) wedge_colors : [F, 3, 4]-shaped numpy array of per-wedge RBGA colors in [0.0, 1.0] (or None) wedge_normals : [F, 3, 3]-shaped numpy array of per-wedge normals (or None) wedge_texcoords : [F, 3, 2]-shaped numpy array of per-wedge] uv coordinates (or None) wedge_tex_ids : [F, 3]-shaped numpy array of integer indices into TriangleMesh.textures indicating which texture to use at this wedge (or None) textures : A list of paths to texture image files for this mesh normal_maps : A list of paths to texture image files for this mesh VertexData A lightweight container class representing per-vertex information within a TriangleMesh with the following attributes positions : [V, 3]-shaped numpy array of per-vertex positions normals : [V, 3]-shaped numpy array of per-vertex normals (or None) texcoords : [V, 2]-shaped numpy array of per-vertex uv coordinates (or None) tex_ids : [V,]-shaped numpy array of integer indices into TriangleMesh.textures indicating which texture to use at this vertex (or None) colors : [V, 4]-shaped numpy array of per-vertex RBGA colors in [0.0, 1.0] (or None) radius : [V,]-shaped numpy array of per-vertex curvature radii (or None) quality : [V,]-shaped numpy array of per-vertex quality measures (or None) flags : [V,]-shaped numpy array of 32-bit integer flags per vertex (or None) load ( self , filename , dtype =< class ' numpy . float64 '>) Load a mesh into this class from a file. The type of file is determined by the extension. Point Cloud Utils currently supports PLY, OBJ, STL, OFF, VRML 2.0, X3D, COLLADA, 3DS. Parameters: filename \u2013 Path to the file to be loaded. Must have a valid extension. dtype \u2013 Type to save floating point data in (defaults to np.float32) save ( self , filename , dtype =< class ' numpy . float32 '>) Save this mesh to a file. The type of file is determined by the extension. Point Cloud Utils currently supports PLY, OBJ, STL, OFF, VRML 2.0, X3D, COLLADA, 3DS. Parameters: filename \u2013 Path to the file to be saved. Must have a valid extension. dtype \u2013 Type to save floating point data in (defaults to np.float32) point_cloud_utils . chamfer_distance ( x , y , return_index = False , p_norm = 2 , max_points_per_leaf = 10 ) Compute the chamfer distance between two point clouds x, and y Parameters: x \u2013 A m-sized minibatch of point sets in R^d. i.e. shape [m, n_a, d] y \u2013 A m-sized minibatch of point sets in R^d. i.e. shape [m, n_b, d] return_index \u2013 If set to True, will return a pair (corrs_x_to_y, corrs_y_to_x) where corrs_x_to_y[i] stores the index into y of the closest point to x[i] (i.e. y[corrs_x_to_y[i]] is the nearest neighbor to x[i] in y). corrs_y_to_x is similar to corrs_x_to_y but with x and y reversed. max_points_per_leaf \u2013 The maximum number of points per leaf node in the KD tree used by this function. Default is 10. p_norm \u2013 Which norm to use. p_norm can be any real number, inf (for the max norm) -inf (for the min norm), 0 (for sum(x != 0)) Returns: The chamfer distance between x an dy. If return_index is set, then this function returns a tuple (chamfer_dist, corrs_x_to_y, corrs_y_to_x) where corrs_x_to_y and corrs_y_to_x are described above. point_cloud_utils . _pcu_internal . closest_points_on_mesh : None point_cloud_utils . _mesh_primitives . cone_mesh ( radius , height , sides = 16 , bottom = True ) Generate a triangle mesh for a cone centered at the origin and pointing up the y-axis. Parameters: radius ( float ) \u2013 Radius of the cone's base. height ( float ) \u2013 Height of the cone. sides ( int ) \u2013 Number of segments used to approximate the circular base (default = 16). bottom ( bool ) \u2013 Whether to include faces for the bottom/base of the code (default = True). Returns: vertices (np.ndarray) \u2013 Mesh vertices as an (n, 3)-shaped NumPy array faces (np.ndarray) : Mesh face indices as an (f, 3)-shaped NumPy array point_cloud_utils . _pcu_internal . connected_components : None point_cloud_utils . _mesh_primitives . cube_mesh () Generate a triangle mesh for a unit cube centered at the origin. Returns: vertices (np.ndarray) \u2013 Mesh vertices as an (n, 3)-shaped NumPy array faces (np.ndarray) : Mesh face indices as an (f, 3)-shaped NumPy array point_cloud_utils . _mesh_primitives . cylinder_mesh ( radius , height , sides = 16 , top = True , bottom = True ) Generate a triangle mesh for a cylinder centered at the origin aligned with the y-axis. Parameters: radius ( float) ) \u2013 Radius of the cylinder. height ( float) ) \u2013 Height of the cylinder. sides ( int) ) \u2013 Number of sides (segments) for the cylinder (default = 16). top ( bool) ) \u2013 Include top face if True (default = True). bottom ( bool) ) \u2013 Include bottom face if True (default = True). Returns: vertices (np.ndarray) \u2013 List of vertex coordinates (shape = (v, 3)). faces (np.ndarray) : List of faces (triplets of vertex indices with shape = (f, 3)). point_cloud_utils . _pcu_internal . decimate_triangle_mesh : None point_cloud_utils . _pcu_internal . deduplicate_mesh_vertices : None point_cloud_utils . _pcu_internal . deduplicate_point_cloud : None point_cloud_utils . downsample_point_cloud_on_voxel_grid ( voxel_size , points , * args , * , min_bound = None , max_bound = None , min_points_per_voxel = 1 ) Downsample a point set to conform with a voxel grid by taking the average of points within each voxel. Parameters: voxel_size \u2013 a scalar representing the size of each voxel or a 3 tuple representing the size per axis of each voxel. points \u2013 a [#v, 3]-shaped array of 3d points. args \u2013 Any additional arguments of shape [#v, ] are treated as attributes and will averaged into each voxel along with the points These will be returns min_bound \u2013 a 3 tuple representing the minimum coordinate of the voxel grid or None to use the bounding box of the input point cloud. max_bound \u2013 a 3 tuple representing the maximum coordinate of the voxel grid or None to use the bounding box of the input point cloud. min_points_per_voxel \u2013 If a voxel contains fewer than this many points, then don't include the points in that voxel in the output. Returns: A tuple (v, attrib0, attrib1, ....) of downsampled points, and point attributes. Attributes are returned in the same order they are passed in. If no attributes are passed in, then this function simply returns vertices. point_cloud_utils . _pcu_internal . downsample_point_cloud_poisson_disk : None point_cloud_utils . _sinkhorn . earth_movers_distance ( p , q , p_norm = 2 , eps = 0.0001 , max_iters = 100 , stop_thresh = 0.001 ) Compute the (batched) Sinkhorn correspondences between two dirac delta distributions, U, and V. This implementation is numerically stable with float32. Parameters: p \u2013 An (n, d)-shaped array of d-dimensional points b \u2013 An (m, d)-shaped array of d-dimensional points p_norm \u2013 Which norm to use. Must be one of {non-zero int, inf, -inf, \u2018fro\u2019, \u2018nuc\u2019} (default is 2), eps \u2013 The reciprocal of the sinkhorn regularization parameter (default 1e-4) max_iters \u2013 The maximum number of Sinkhorn iterations stop_thresh \u2013 Stop if the change in iterates is below this value Returns: emd \u2013 The earth mover's distance between point clouds p and q P : An (n, m)-shaped array of correspondences between point clouds p and q point_cloud_utils . _pcu_internal . estimate_mesh_face_normals : None point_cloud_utils . _pcu_internal . estimate_mesh_vertex_normals : None point_cloud_utils . _pointcloud_normals . estimate_point_cloud_normals_ball ( points , ball_radius , view_directions = None , drop_angle_threshold = 1.5707963267948966 , min_pts_per_ball = 3 , max_pts_per_ball =- 1 , weight_function = 'constant' , max_points_per_leaf = 10 , num_threads =- 1 ) Estimate normals for a point cloud by locally fitting a plane to all points within a radius of each point (possibly weighted by a radial basis function). This function can optionally consider directions to the sensor for each point to compute neighborhoods of points which are all facing the same direction, and align the final normal directions. Parameters: points \u2013 (n, 3)-shaped NumPy array of point positions (each row is a point) ball_radius \u2013 The radius of each neighborhood used to estimate normals view_directions \u2013 (n, 3)-shaped NumPy array or None, representing the unit direction to the sensor for each point. This parameter is used to align the normals and compute neighborhoods of similar facing points. drop_angle_threshold \u2013 If view_directions is passed in, drop points whose angle between the normal and view direction exceeds drop_angle_threshold (in radians). Useful for filtering out low quality points. min_pts_per_ball \u2013 Discard points whose neighborhood contains fewer than min_pts_per_ball points. max_pts_per_ball \u2013 If set to a positive number, then only use max_pts_per_ball points within each neighborhood whose number of points exceeds this value. weight_function \u2013 Weighting function for points in a neighborhood. Must be one of 'constant' or 'rbf' where: max_points_per_leaf \u2013 Maximum number of points in each leaf node of the KD-tree used for nearest neighbor queries. Tuning this can potentially improve performance on large point clouds. num_threads \u2013 Number of threads used to parallelize computation. If set to 0 ir 1, will run in single threaded mode. If set to a positive number t > 1, will use t threads. If set to -1, will use #processors threads for inputs greater than 1 million points. Returns: p \u2013 an (m, 3)-shaped Numpy array of 3d points n : an (m, 3)-shaped Numpy array of unit normals for each point in p See Also: estimate_pointcloud_normals_ball point_cloud_utils . _pointcloud_normals . estimate_point_cloud_normals_knn ( points , num_neighbors , view_directions = None , drop_angle_threshold = 1.5707963267948966 , max_points_per_leaf = 10 , num_threads =- 1 ) Estimate normals for a point cloud by locally fitting a plane to the k nearest neighbors of each point. This function can optionally consider directions to the sensor for each point to compute neighborhoods of points which are all facing the same direction, and align the final normal directions. Parameters: points \u2013 (n, 3)-shaped NumPy array of point positions (each row is a point) num_neighbors \u2013 Integer number of neighbors to use in each neigghborhood. view_directions \u2013 (n, 3)-shaped NumPy array or None, representing the unit direction to the sensor for each point. This parameter is used to align the normals and compute neighborhoods of similar facing points. drop_angle_threshold \u2013 If view_directions is passed in, drop points whose angle between the normal and view direction exceeds drop_angle_threshold (in radians). Useful for filtering out low quality points. max_points_per_leaf \u2013 Maximum number of points in each leaf node of the KD-tree used for nearest neighbor queries. Tuning this can potentially improve performance on large point clouds. num_threads \u2013 Number of threads used to parallelize computation. If set to 0 ir 1, will run in single threaded mode. If set to a positive number t > 1, will use t threads. If set to -1, will use #processors threads for inputs greater than 1 million points. Returns: idx \u2013 an (m, 1)-shaped Numpy array of indices into points n : an (m, 3)-shaped Numpy array of unit normals for each point in p See Also: estimate_pointcloud_normals_ball point_cloud_utils . _voxels . flood_fill_3d ( grid , start_coord , fill_value ) Flood fill a 3D grid starting from_start_coord with fill_value. This will return a copy of grid where the region in the input grid which is connected to start_coord and shares the value of start_coord is set to fill_value. Parameters: grid ( np.ndarray ) \u2013 [w, h, d] array of scalars as input to the flood fill start_coord \u2013 (i, j, k) integer coordinate to start the flood fill fill_value \u2013 scalar value to flood fill Returns: _type_ \u2013 A flood filled copy of grid where all voxels which are connected to start_coord are set to fill_value point_cloud_utils . hausdorff_distance ( x , y , return_index = False , squared_distances = False , max_points_per_leaf = 10 ) Compute the Hausdorff distance between x and y Parameters: x \u2013 n by 3 array of representing a set of n points (each row is a point of dimension 3) y \u2013 m by 3 array of representing a set of m points (each row is a point of dimension 3) return_index \u2013 Optionally return the index pair (i, j) into x and y such that x[i, :] and y[j, :] are the two points with maximum shortest distance. squared_distances \u2013 If set to True, then return squared L2 distances. Default is False. max_points_per_leaf \u2013 The maximum number of points per leaf node in the KD tree used by this function. Default is 10. Returns: The largest shortest distance, d between each point in source and the points in target . If return_index is set, then this function returns a tuple (d, i, j) where d is as described above and (i, j) are such that source[i, \u2013 ] and target[j, :] are the two points with maximum shortest distance. point_cloud_utils . interpolate_barycentric_coords ( f , fi , bc , attribute ) Interpolate an attribute stored at each vertex of a mesh across the faces of a triangle mesh using barycentric coordinates Parameters: f \u2013 a (#faces, 3)-shaped NumPy array of mesh faces (indexing into some vertex array). fi \u2013 a (#attribs,)-shaped NumPy array of indexes into f indicating which face each attribute lies within. bc \u2013 a (#attribs, 3)-shaped NumPy array of barycentric coordinates for each attribute attribute \u2013 a (#vertices, dim)-shaped NumPy array of attributes at each of the mesh vertices Returns: A (#attribs, dim)-shaped array of interpolated attributes. point_cloud_utils . _pcu_internal . k_nearest_neighbors : None point_cloud_utils . _pcu_internal . laplacian_smooth_mesh : None point_cloud_utils . _pcu_internal . lloyd_2d : None point_cloud_utils . _pcu_internal . lloyd_3d : None point_cloud_utils . _mesh_io . load_mesh_v ( filename , dtype =< class ' float '>) Load a point cloud consisting only of vertex positions. Point Cloud Utils currently supports PLY, OBJ, STL, OFF, VRML 2.0, X3D, COLLADA, 3DS. Parameters: filename \u2013 Path to the file to be loaded. Must have a valid extension. dtype \u2013 The floating point type of loaded data ( np.float32 or np.float64 ) Returns: v \u2013 An (n, 3)-shaped numpy array of coordinates point_cloud_utils . _mesh_io . load_mesh_vc ( filename , dtype =< class ' float '>) Load a point cloud consisting of vertex positions, and vertex colors. Point Cloud Utils currently supports PLY, OBJ, STL, OFF, VRML 2.0, X3D, COLLADA, 3DS. Parameters: filename \u2013 Path to the file to be loaded. Must have a valid extension. dtype \u2013 The floating point type of loaded data ( np.float32 or np.float64 ) Returns: v \u2013 An (n, 3)-shaped numpy array of coordinates c : An (n, 3)-shaped or (n, 4)-shaped numpy array of per-vertex RGB or RGBA colors (from 0.0 to 1.0) point_cloud_utils . _mesh_io . load_mesh_vf ( filename , dtype =< class ' float '>) Load a triangle mesh consisting of vertex positions and face indices. Point Cloud Utils currently supports PLY, OBJ, STL, OFF, VRML 2.0, X3D, COLLADA, 3DS. Parameters: filename \u2013 Path to the file to be loaded. Must have a valid extension. dtype \u2013 The floating point type of loaded data ( np.float32 or np.float64 ) Returns: v \u2013 An (n, 3)-shaped numpy array of coordinates f : An (m, 3)-shaped integer numpy array of face indices into v point_cloud_utils . _mesh_io . load_mesh_vfc ( filename , dtype =< class ' float '>) Load a triangle mesh consisting of vertex positions, face indices, and vertex colors. Point Cloud Utils currently supports PLY, OBJ, STL, OFF, VRML 2.0, X3D, COLLADA, 3DS. Parameters: filename \u2013 Path to the file to be loaded. Must have a valid extension. dtype \u2013 The floating point type of loaded data ( np.float32 or np.float64 ) Returns: v \u2013 An (n, 3)-shaped numpy array of coordinates f : An (m, 3)-shaped integer numpy array of face indices into v c : An (n, 3)-shaped or (n, 4)-shaped numpy array of per-vertex RGB or RGBA colors (from 0.0 to 1.0) point_cloud_utils . _mesh_io . load_mesh_vfn ( filename , dtype =< class ' float '>) Load a triangle mesh consisting of vertex positions, face indices, and vertex normals. Point Cloud Utils currently supports PLY, OBJ, STL, OFF, VRML 2.0, X3D, COLLADA, 3DS. Parameters: filename \u2013 Path to the file to be loaded. Must have a valid extension. dtype \u2013 The floating point type of loaded data ( np.float32 or np.float64 ) Returns: v \u2013 An (n, 3)-shaped numpy array of coordinates f : An (m, 3)-shaped integer numpy array of face indices into v n : An (n, 3)-shaped numpy array of per-vertex normals point_cloud_utils . _mesh_io . load_mesh_vfnc ( filename , dtype =< class ' float '>) Load a triangle mesh consisting of vertex positions, face indices, vertex normals, and vertex colors. Point Cloud Utils currently supports PLY, OBJ, STL, OFF, VRML 2.0, X3D, COLLADA, 3DS. Parameters: filename \u2013 Path to the file to be loaded. Must have a valid extension. dtype \u2013 The floating point type of loaded data ( np.float32 or np.float64 ) Returns: v \u2013 An (n, 3)-shaped numpy array of coordinates f : An (m, 3)-shaped integer numpy array of face indices into v n : An (n, 3)-shaped numpy array of per-vertex normals c : An (n, 3)-shaped or (n, 4)-shaped numpy array of per-vertex RGB or RGBA colors (from 0.0 to 1.0) point_cloud_utils . _mesh_io . load_mesh_vn ( filename , dtype =< class ' float '>) Load a point cloud consisting of vertex positions, and vertex normals. Point Cloud Utils currently supports PLY, OBJ, STL, OFF, VRML 2.0, X3D, COLLADA, 3DS. Parameters: filename \u2013 Path to the file to be loaded. Must have a valid extension. dtype \u2013 The floating point type of loaded data ( np.float32 or np.float64 ) Returns: v \u2013 An (n, 3)-shaped numpy array of coordinates n : An (n, 3)-shaped numpy array of per-vertex normals point_cloud_utils . _mesh_io . load_mesh_vnc ( filename , dtype =< class ' float '>) Load a point cloud consisting of vertex positions, vertex normals, and vertex colors. Point Cloud Utils currently supports PLY, OBJ, STL, OFF, VRML 2.0, X3D, COLLADA, 3DS. Parameters: filename \u2013 Path to the file to be loaded. Must have a valid extension. dtype \u2013 The floating point type of loaded data ( np.float32 or np.float64 ) Returns: v \u2013 An (n, 3)-shaped numpy array of coordinates n : An (n, 3)-shaped numpy array of per-vertex normals c : An (n, 3)-shaped or (n, 4)-shaped numpy array of per-vertex RGB or RGBA colors (from 0.0 to 1.0) point_cloud_utils . _mesh_io . load_triangle_mesh ( filename , dtype =< class ' numpy . float64 '>) Load a triangle mesh into a TriangleMesh class. Point Cloud Utils currently supports PLY, OBJ, STL, OFF, VRML 2.0, X3D, COLLADA, 3DS. Parameters: filename \u2013 Path to the file to be saved. Must have a valid extension. dtype \u2013 The type of floating point number to store the data in (np.float32 or np.float64) Returns: mesh \u2013 A TriangleMesh class containing the loaded mesh point_cloud_utils . _pcu_internal . make_mesh_watertight : None point_cloud_utils . _pcu_internal . marching_cubes_sparse_voxel_grid : None point_cloud_utils . _pcu_internal . mesh_face_areas : None point_cloud_utils . _pcu_internal . morton_add : None point_cloud_utils . _pcu_internal . morton_decode : None point_cloud_utils . _pcu_internal . morton_encode : None point_cloud_utils . _pcu_internal . morton_knn : None point_cloud_utils . _pcu_internal . morton_subtract : None point_cloud_utils . _pcu_internal . one_sided_hausdorff_distance : None point_cloud_utils . _pcu_internal . orient_mesh_faces : None point_cloud_utils . _sinkhorn . pairwise_distances ( a , b , p = None ) Compute the (batched) pairwise distance matrix between a and b which both have size [m, n, d] or [n, d]. The result is a tensor of size [m, n, n] (or [n, n]) whose entry [m, i, j] contains the distance_tensor between a[m, i, :] and b[m, j, :]. Parameters: a \u2013 A tensor containing m batches of n points of dimension d. i.e. of size (m, n, d) b \u2013 A tensor containing m batches of n points of dimension d. i.e. of size (m, n, d) p \u2013 Norm to use for the distance_tensor Returns: M \u2013 A (m, n, n)-shaped array containing the pairwise distance_tensor between each pair of inputs in a batch. point_cloud_utils . _pcu_internal . point_cloud_fast_winding_number : None point_cloud_utils . _point_cloud_geometry . pointcloud_sphere_geometry ( p , r , num_stacks , num_slices ) Generate sphere geometry for a point cloud (i.e. one sphere per point) Parameters: p \u2013 #p by 3 array of vertex positions (each row is a vertex) r \u2013 Array or Scalar describing the radius along each axis (Either one radius per vertex, or a global size for the whole point cloud) num_stacks \u2013 Number of latitudal subdivisions num_slices \u2013 Number of longitudal subdivisions Returns: verts \u2013 an array of shape (#output_vertices, 3) faces : an array of shape (#output_faces, 3) indexing into verts point_cloud_utils . _point_cloud_geometry . pointcloud_surfel_geometry ( p , n , r = 0.1 , subdivs = 7 ) Generate geometry for a point cloud encoded as surfels (i.e. circular patches centered at each point and oriented perpendicularly to each normal) Parameters: p \u2013 #p by 3 array of vertex positions (each row is a vertex) n \u2013 #p by 3 array of vertex normals (each row is a vertex) r \u2013 Array or Scalar describing the size of each geometry element (Either one radius per vertex, or a global size for the whole point cloud) subdivs \u2013 Number of times to subdivide the patch geometry for each point (i.e. # tris per cicle) Returns: verts \u2013 an array of shape (#output_vertices, 3) faces : an array of shape (#output_faces, 3) indexing into verts point_cloud_utils . _pcu_internal . ray_mesh_intersection : None point_cloud_utils . _ray_point_cloud_intersector . ray_surfel_intersection ( p , n , ray_o , ray_d , r = 0.1 , subdivs = 4 , ray_near = 0.0 , ray_far = inf ) Compute intersection between a set of rays and a point cloud converted to surfels (i.e. circular patches oriented with the point normals) Parameters: p \u2013 #p by 3 array of vertex positions (each row is a vertex) n \u2013 #p by 3 Matrix of vertex normals (each row is a vertex) ray_o \u2013 array of shape (#rays, 3) of ray origins (one per row) or a single array of shape (3,) to use ray_d \u2013 array of shape (#rays, 3) of ray directions (one per row) r \u2013 Array or Scalar describing the size of each geometry element (Either one radius per vertex, or a global size for the whole point cloud) subdivs \u2013 Number of times to subdivide the patch geometry for each point (i.e. # tris per cicle) ray_near \u2013 an optional floating point value indicating the distance along each ray to start searching (default 0.0) ray_far \u2013 an optional floating point value indicating the maximum distance along each ray to search (default inf) Returns: t \u2013 a (#rays,) shaped array encoding the distance between the ray origin and intersection point for each ray (inf for missed rays) pid : a (#rays,) shaped array of integer indices corresponding to which points were hit (-1 for a ray miss) point_cloud_utils . _pcu_internal . remove_unreferenced_mesh_vertices : None point_cloud_utils . _pcu_internal . sample_mesh_lloyd : None point_cloud_utils . _pcu_internal . sample_mesh_poisson_disk : None point_cloud_utils . _pcu_internal . sample_mesh_random : None point_cloud_utils . _mesh_io . save_mesh_v ( filename , v , dtype =< class ' numpy . float32 '>) Save a point cloud consisting only of vertex positions. Point Cloud Utils currently supports PLY, OBJ, STL, OFF, VRML 2.0, X3D, COLLADA, 3DS. Parameters: filename \u2013 Path to the file to be saved. Must have a valid extension. v \u2013 An (n, 3)-shaped numpy array of coordinates dtype \u2013 The floating point written to the file ( np.float32 or np.float64 ) point_cloud_utils . _mesh_io . save_mesh_vc ( filename , v , c , dtype =< class ' numpy . float32 '>) Save a point cloud consisting of vertex positions and vertex colors. Point Cloud Utils currently supports PLY, OBJ, STL, OFF, VRML 2.0, X3D, COLLADA, 3DS. Parameters: filename \u2013 Path to the file to be saved. Must have a valid extension. v \u2013 An (n, 3)-shaped numpy array of coordinates c \u2013 An (n, 3)-shaped or (n, 4)-shaped numpy array of per-vertex RGB or RGBA colors (from 0.0 to 1.0) dtype \u2013 The floating point written to the file ( np.float32 or np.float64 ) point_cloud_utils . _mesh_io . save_mesh_vf ( filename , v , f , dtype =< class ' numpy . float32 '>) Save a triangle mesh consisting of vertex positions and face indices. Point Cloud Utils currently supports PLY, OBJ, STL, OFF, VRML 2.0, X3D, COLLADA, 3DS. Parameters: filename \u2013 Path to the file to be saved. Must have a valid extension. v \u2013 An (n, 3)-shaped numpy array of coordinates f \u2013 An (m, 3)-shaped integer numpy array of face indices into v dtype \u2013 The floating point written to the file ( np.float32 or np.float64 ) point_cloud_utils . _mesh_io . save_mesh_vfc ( filename , v , f , c , dtype =< class ' numpy . float32 '>) Save a triangle mesh consisting of vertex positions, face indices, and vertex colors. Point Cloud Utils currently supports PLY, OBJ, STL, OFF, VRML 2.0, X3D, COLLADA, 3DS. Parameters: filename \u2013 Path to the file to be saved. Must have a valid extension. v \u2013 An (n, 3)-shaped numpy array of coordinates f \u2013 An (m, 3)-shaped integer numpy array of face indices into v c \u2013 An (n, 3)-shaped or (n, 4)-shaped numpy array of per-vertex RGB or RGBA colors (from 0.0 to 1.0) dtype \u2013 The floating point written to the file ( np.float32 or np.float64 ) point_cloud_utils . _mesh_io . save_mesh_vfn ( filename , v , f , n , dtype =< class ' numpy . float32 '>) Save a triangle mesh consisting of vertex positions, face indices, and vertex normals. Point Cloud Utils currently supports PLY, OBJ, STL, OFF, VRML 2.0, X3D, COLLADA, 3DS. Parameters: filename \u2013 Path to the file to be saved. Must have a valid extension. v \u2013 An (n, 3)-shaped numpy array of coordinates f \u2013 An (m, 3)-shaped integer numpy array of face indices into v n \u2013 An (n, 3)-shaped numpy array of per-vertex normals dtype \u2013 The floating point written to the file ( np.float32 or np.float64 ) point_cloud_utils . _mesh_io . save_mesh_vfnc ( filename , v , f , n , c , dtype =< class ' numpy . float32 '>) Save a triangle mesh consisting of vertex positions, face indices, vertex normals, and vertex colors. Point Cloud Utils currently supports PLY, OBJ, STL, OFF, VRML 2.0, X3D, COLLADA, 3DS. Parameters: filename \u2013 Path to the file to be saved. Must have a valid extension. v \u2013 An (n, 3)-shaped numpy array of coordinates f \u2013 An (m, 3)-shaped integer numpy array of face indices into v n \u2013 An (n, 3)-shaped numpy array of per-vertex normals c \u2013 An (n, 3)-shaped or (n, 4)-shaped numpy array of per-vertex RGB or RGBA colors (from 0.0 to 1.0) dtype \u2013 The floating point written to the file ( np.float32 or np.float64 ) point_cloud_utils . _mesh_io . save_mesh_vn ( filename , v , n , dtype =< class ' numpy . float32 '>) Save a point cloud consisting of vertex positions and vertex normals. Point Cloud Utils currently supports PLY, OBJ, STL, OFF, VRML 2.0, X3D, COLLADA, 3DS. Parameters: filename \u2013 Path to the file to be saved. Must have a valid extension. v \u2013 An (n, 3)-shaped numpy array of coordinates n \u2013 An (n, 3)-shaped numpy array of per-vertex normals dtype \u2013 The floating point written to the file ( np.float32 or np.float64 ) point_cloud_utils . _mesh_io . save_mesh_vnc ( filename , v , n , c , dtype =< class ' numpy . float32 '>) Save a point cloud consisting of vertex positions, vertex normals, and vertex colors. Point Cloud Utils currently supports PLY, OBJ, STL, OFF, VRML 2.0, X3D, COLLADA, 3DS. Parameters: filename \u2013 Path to the file to be saved. Must have a valid extension. v \u2013 An (n, 3)-shaped numpy array of coordinates n \u2013 An (n, 3)-shaped numpy array of per-vertex normals c \u2013 An (n, 3)-shaped or (n, 4)-shaped numpy array of per-vertex RGB or RGBA colors (from 0.0 to 1.0) dtype \u2013 The floating point written to the file ( np.float32 or np.float64 ) point_cloud_utils . _mesh_io . save_triangle_mesh ( filename , v , f = None , vn = None , vt = None , vc = None , vq = None , vr = None , vti = None , vflags = None , fn = None , fc = None , fq = None , fflags = None , wc = None , wn = None , wt = None , wti = None , textures = [], normal_maps = [], dtype =< class ' numpy . float32 '>) Save a triangle mesh to a file with various per-vertex, per-face, and per-wedge attributes. Each argument (except v) is optional and can be None. Parameters: filename ( ) \u2013 Path to the mesh to save. The type of file will be determined from the file extension. v ( ) \u2013 [V, 3]-shaped numpy array of per-vertex positions f ( ) \u2013 [F, 3]-shaped numpy array of integer face indices into TrianglMesh.vertex_data.positions (or None) vn ( ) \u2013 [V, 3]-shaped numpy array of per-vertex normals (or None) vt ( ) \u2013 [V, 2]-shaped numpy array of per-vertex uv coordinates (or None) vc ( ) \u2013 [V, 4]-shaped numpy array of per-vertex RBGA colors in [0.0, 1.0] (or None) vq ( ) \u2013 [V,]-shaped numpy array of per-vertex quality measures (or None) vr ( ) \u2013 [V,]-shaped numpy array of per-vertex curvature radii (or None) vti ( ) \u2013 [V,]-shaped numpy array of integer indices into TriangleMesh.textures indicating which texture to use at this vertex (or None) vflags ( ) \u2013 [V,]-shaped numpy array of 32-bit integer flags per vertex (or None) fn ( ) \u2013 [F, 3]-shaped numpy array of per-face normals (or None) fc ( ) \u2013 [F, 4]-shaped numpy array of per-face RBGA colors in [0.0, 1.0] (or None) fq ( ) \u2013 [F,]-shaped numpy array of per-face quality measures (or None) fflags ( ) \u2013 [F,]-shaped numpy array of 32-bit integer flags per face (or None) wc ( ) \u2013 [F, 3, 4]-shaped numpy array of per-wedge RBGA colors in [0.0, 1.0] (or None) wn ( ) \u2013 [F, 3, 3]-shaped numpy array of per-wedge normals (or None) wt ( ) \u2013 [F, 3, 2]-shaped numpy array of per-wedge] uv coordinates (or None) wti ( ) \u2013 [F, 3]-shaped numpy array of integer indices into TriangleMesh.textures indicating which textures ( ) \u2013 A list of paths to texture image files for this mesh normal_maps \u2013 A list of paths to texture image files for this mesh dtype ( ) \u2013 The floating point written to the file ( np.float32 or np.float64 ) point_cloud_utils . _pcu_internal . signed_distance_to_mesh : None point_cloud_utils . _sinkhorn . sinkhorn ( a , b , M , eps , max_iters = 100 , stop_thresh = 0.001 ) Compute the (batched) Sinkhorn correspondences between two dirac delta distributions, U, and V. This implementation is numerically stable with float32. Parameters: a \u2013 A m-sized minibatch of weights for each dirac in the first distribution, U. i.e. shape = (m, n) b \u2013 A m-sized minibatch of weights for each dirac in the second distribution, V. i.e. shape = (m, n) M \u2013 A minibatch of n-by-n tensors storing the distance between each pair of diracs in U and V. i.e. shape = (m, n, n) and each i.e. M[k, i, j] = ||u[k,_i] - v[k, j]|| eps \u2013 The reciprocal of the sinkhorn regularization parameter max_iters \u2013 The maximum number of Sinkhorn iterations stop_thresh \u2013 Stop if the change in iterates is below this value Returns: P \u2013 An (m, n, n)-shaped array of correspondences between distributions U and V point_cloud_utils . _pcu_internal . sparse_voxel_grid_boundary : None point_cloud_utils . _mesh_primitives . sphere_mesh ( subdivisions = 3 ) Generate a triangle mesh approximating a unit sphere centered at the origin by subdividing an isocahedron. Parameters: subdivisions ( int) ) \u2013 Number of times to subdivide an isocahedron to get the mesh (default = 3). Returns: vertices (np.ndarray) \u2013 Mesh vertices as an (n, 3)-shaped NumPy array faces (np.ndarray) : Mesh face indices as an (f, 3)-shaped NumPy array point_cloud_utils . _pcu_internal . triangle_soup_fast_winding_number : None point_cloud_utils . _pcu_internal . voronoi_centroids_unit_cube : None point_cloud_utils . _point_cloud_geometry . voxel_grid_geometry ( ijk , voxel_size = array ([ 1. , 1. , 1. ]), voxel_origin = array ([ 0. , 0. , 0. ]), gap_fraction = 0.0 ) Generate a triangle mesh of cubes for voxel coordinates ijk. The [0, 0, 0] voxel has its center at voxel_origin and each voxel has voxel_size. Parameters: ijk ( np.ndarray ) \u2013 [num_voxels, 3] array of integer voxel coordinates voxel_size \u2013 Float or triple representing the size of each voxel. Defaults to np.array((1., 1., 1.)). voxel_origin \u2013 Center coordinate of the [0, 0, 0] voxel. Defaults to np.array((0., 0., 0.)). gap_fraction \u2013 Fraction of a voxel to leave as a gap between voxels (default 0.0) Returns: v \u2013 Numpy array of vertices for the cube mesh f: Numpy array of faces for the cube mesh point_cloud_utils . _voxels . voxelize_triangle_mesh ( v , f , voxel_size , voxel_origin ) Return ijk coordinates of voxels which intersect the given mesh. Each voxel is assumed to have size voxel_size (scalar or triple of floats) and the (0, 0, 0) voxel has its bottom-back-left corner at voxel_origin Parameters: v ( np.ndarray ) \u2013 [num_vertices, 3] array of triangle mesh vertices f ( np.ndarray ) \u2013 [num_faces, 3] array of face indexes into v voxel_size \u2013 A float or triple specifying the size of each voxel voxel_origin \u2013 A float or triple specifying the the position of the bottom-back-left corner of the (0, 0, 0) voxel Returns: ijk \u2013 [num_vox, 3] array of integer ijk coordinates for each voxel intersecting the mesh","title":"API Reference"},{"location":"sections/api_reference/#api-reference","text":"","title":"API Reference"},{"location":"sections/api_reference/#point_cloud_utils.MORTON_MAX","text":"","title":"MORTON_MAX"},{"location":"sections/api_reference/#point_cloud_utils.MORTON_MIN","text":"","title":"MORTON_MIN"},{"location":"sections/api_reference/#point_cloud_utils._ray_mesh_intersector.RayMeshIntersector","text":"Class used to find the intersection between rays and a triangle mesh.","title":"RayMeshIntersector"},{"location":"sections/api_reference/#point_cloud_utils._ray_mesh_intersector.RayMeshIntersector.__init__","text":"Create a RayMeshIntersector object which can be used to do ray/mesh queries with a triangle mesh. Parameters: mesh_v \u2013 #v by 3 array of vertex positions (each row is a vertex) mesh_f \u2013 #f by 3 Matrix of face (triangle) indices","title":"__init__()"},{"location":"sections/api_reference/#point_cloud_utils._ray_mesh_intersector.RayMeshIntersector.intersect_rays","text":"Compute intersection between a set of rays and the triangle mesh enclosed in this class Parameters: ray_o \u2013 array of shape (#rays, 3) of ray origins (one per row) or a single array of shape (3,) to use ray_d \u2013 array of shape (#rays, 3) of ray directions (one per row) ray_near \u2013 an optional floating point value indicating the distance along each ray to start searching (default 0.0) ray_far \u2013 an optional floating point value indicating the maximum distance along each ray to search (default inf) Returns: f_id \u2013 an array of shape (#rays,) representing the face id hit by each ray bc : an array of shape (#rays, 3) where each row is the barycentric coordinates within each face of the ray intersection t : the distance along each ray to the intersection","title":"intersect_rays()"},{"location":"sections/api_reference/#point_cloud_utils._ray_point_cloud_intersector.RaySurfelIntersector","text":"Class used to find the intersection between rays and a point cloud converted to surfels (i.e. a point cloud represented as circles centered at each point and oriented perpendicularly to each normal).","title":"RaySurfelIntersector"},{"location":"sections/api_reference/#point_cloud_utils._ray_point_cloud_intersector.RaySurfelIntersector.__init__","text":"Construct a RayPointCloudIntersector which can be used to compute the intersection between a set of rays and a point cloud converted to circular patches oriented with the point normals Parameters: p \u2013 #p by 3 array of vertex positions (each row is a vertex) n \u2013 #p by 3 Matrix of vertex normals (each row is a vertex) r \u2013 Array or Scalar describing the size of each geometry element (Either one radius per vertex, or a global size for the whole point cloud) subdivs \u2013 Number of times to subdivide the patch geometry for each point (i.e. # tris per cicle)","title":"__init__()"},{"location":"sections/api_reference/#point_cloud_utils._ray_point_cloud_intersector.RaySurfelIntersector.intersect_rays","text":"Compute intersection between a set of rays and the point cloud converted to circular patches oriented with the point normals Parameters: ray_o \u2013 array of shape (#rays, 3) of ray origins (one per row) or a single array of shape (3,) to use ray_d \u2013 array of shape (#rays, 3) of ray directions (one per row) ray_near \u2013 an optional floating point value indicating the distance along each ray to start searching (default 0.0) ray_far \u2013 an optional floating point value indicating the maximum distance along each ray to search (default inf) Returns: t \u2013 a (#rays,) shaped array encoding the distance between the ray origin and intersection point for each ray (inf for missed rays) pid : a (#rays,) shaped array of integer indices corresponding to which points were hit (-1 for a ray miss)","title":"intersect_rays()"},{"location":"sections/api_reference/#point_cloud_utils._mesh_io.TriangleMesh","text":"A lightweight container class representing a triangle mesh with attributes stored at each vertex, wedge, and face, where: A vertex is a 3D position A wedge is a vertex and its two adjacent edges A face is a triangle connecting 3 vertices (Each triangle has 3 vertices and 3 wedges). The data in encapsulated into vertex data and face data, accessible via TriangleMes.vertex_data and TriangleMesh.face_data respectively: TriangleMesh.vertex_data : positions : [V, 3]-shaped numpy array of per-vertex positions normals : [V, 3]-shaped numpy array of per-vertex normals (or None) texcoords : [V, 2]-shaped numpy array of per-vertex uv coordinates (or None) tex_ids : [V,]-shaped numpy array of integer indices into TriangleMesh.textures indicating which texture to use at this vertex (or None) colors : [V, 4]-shaped numpy array of per-vertex RBGA colors in [0.0, 1.0] (or None) radius : [V,]-shaped numpy array of per-vertex curvature radii (or None) quality : [V,]-shaped numpy array of per-vertex quality measures (or None) flags : [V,]-shaped numpy array of 32-bit integer flags per vertex (or None) TriangleMesh.face_data : vertex_ids : [F, 3]-shaped numpy array of integer face indices into TrianglMesh.vertex_data.positions normals : [F, 3]-shaped numpy array of per-face normals (or None) colors : [F, 4]-shaped numpy array of per-face RBGA colors in [0.0, 1.0] (or None) quality : [F,]-shaped numpy array of per-face quality measures (or None) flags : [F,]-shaped numpy array of 32-bit integer flags per face (or None) wedge_colors : [F, 3, 4]-shaped numpy array of per-wedge RBGA colors in [0.0, 1.0] (or None) wedge_normals : [F, 3, 3]-shaped numpy array of per-wedge normals (or None) wedge_texcoords : [F, 3, 2]-shaped numpy array of per-wedge] uv coordinates (or None) wedge_tex_ids : [F, 3]-shaped numpy array of integer indices into TriangleMesh.textures indicating which texture to use at this wedge (or None) textures : A list of paths to texture image files for this mesh normal_maps : A list of paths to texture image files for this mesh","title":"TriangleMesh"},{"location":"sections/api_reference/#point_cloud_utils._mesh_io.TriangleMesh.f","text":"An (m, 3)-shaped integer array containing this mesh's face indices (None if no faces)","title":"f"},{"location":"sections/api_reference/#point_cloud_utils._mesh_io.TriangleMesh.fc","text":"An (m, 4)-shaped array containing this mesh's per-face RBGA colors (None if no face colors)","title":"fc"},{"location":"sections/api_reference/#point_cloud_utils._mesh_io.TriangleMesh.fn","text":"An (m, 3)-shaped array containing this mesh's per-face normals (None if no face normals)","title":"fn"},{"location":"sections/api_reference/#point_cloud_utils._mesh_io.TriangleMesh.v","text":"An (n, 3)-shaped array containing this mesh's vertex positions","title":"v"},{"location":"sections/api_reference/#point_cloud_utils._mesh_io.TriangleMesh.vc","text":"An (n, 4)-shaped array containing this mesh's per-vertex RGBA (None if no vertex colors)","title":"vc"},{"location":"sections/api_reference/#point_cloud_utils._mesh_io.TriangleMesh.vn","text":"An (n, 3)-shaped array containing this mesh's per-vertex normals (None if no vertex normals)","title":"vn"},{"location":"sections/api_reference/#point_cloud_utils._mesh_io.TriangleMesh.FaceData","text":"A lightweight container class representing per-face information within a TriangleMesh with the following attributes vertex_ids : [F, 3]-shaped numpy array of integer face indices into TrianglMesh.vertex_data.positions normals : [F, 3]-shaped numpy array of per-face normals (or None) colors : [F, 4]-shaped numpy array of per-face RBGA colors in [0.0, 1.0] (or None) quality : [F,]-shaped numpy array of per-face quality measures (or None) flags : [F,]-shaped numpy array of 32-bit integer flags per face (or None) wedge_colors : [F, 3, 4]-shaped numpy array of per-wedge RBGA colors in [0.0, 1.0] (or None) wedge_normals : [F, 3, 3]-shaped numpy array of per-wedge normals (or None) wedge_texcoords : [F, 3, 2]-shaped numpy array of per-wedge] uv coordinates (or None) wedge_tex_ids : [F, 3]-shaped numpy array of integer indices into TriangleMesh.textures indicating which texture to use at this wedge (or None) textures : A list of paths to texture image files for this mesh normal_maps : A list of paths to texture image files for this mesh","title":"FaceData"},{"location":"sections/api_reference/#point_cloud_utils._mesh_io.TriangleMesh.VertexData","text":"A lightweight container class representing per-vertex information within a TriangleMesh with the following attributes positions : [V, 3]-shaped numpy array of per-vertex positions normals : [V, 3]-shaped numpy array of per-vertex normals (or None) texcoords : [V, 2]-shaped numpy array of per-vertex uv coordinates (or None) tex_ids : [V,]-shaped numpy array of integer indices into TriangleMesh.textures indicating which texture to use at this vertex (or None) colors : [V, 4]-shaped numpy array of per-vertex RBGA colors in [0.0, 1.0] (or None) radius : [V,]-shaped numpy array of per-vertex curvature radii (or None) quality : [V,]-shaped numpy array of per-vertex quality measures (or None) flags : [V,]-shaped numpy array of 32-bit integer flags per vertex (or None)","title":"VertexData"},{"location":"sections/api_reference/#point_cloud_utils._mesh_io.TriangleMesh.load","text":"Load a mesh into this class from a file. The type of file is determined by the extension. Point Cloud Utils currently supports PLY, OBJ, STL, OFF, VRML 2.0, X3D, COLLADA, 3DS. Parameters: filename \u2013 Path to the file to be loaded. Must have a valid extension. dtype \u2013 Type to save floating point data in (defaults to np.float32)","title":"load()"},{"location":"sections/api_reference/#point_cloud_utils._mesh_io.TriangleMesh.save","text":"Save this mesh to a file. The type of file is determined by the extension. Point Cloud Utils currently supports PLY, OBJ, STL, OFF, VRML 2.0, X3D, COLLADA, 3DS. Parameters: filename \u2013 Path to the file to be saved. Must have a valid extension. dtype \u2013 Type to save floating point data in (defaults to np.float32)","title":"save()"},{"location":"sections/api_reference/#point_cloud_utils.chamfer_distance","text":"Compute the chamfer distance between two point clouds x, and y Parameters: x \u2013 A m-sized minibatch of point sets in R^d. i.e. shape [m, n_a, d] y \u2013 A m-sized minibatch of point sets in R^d. i.e. shape [m, n_b, d] return_index \u2013 If set to True, will return a pair (corrs_x_to_y, corrs_y_to_x) where corrs_x_to_y[i] stores the index into y of the closest point to x[i] (i.e. y[corrs_x_to_y[i]] is the nearest neighbor to x[i] in y). corrs_y_to_x is similar to corrs_x_to_y but with x and y reversed. max_points_per_leaf \u2013 The maximum number of points per leaf node in the KD tree used by this function. Default is 10. p_norm \u2013 Which norm to use. p_norm can be any real number, inf (for the max norm) -inf (for the min norm), 0 (for sum(x != 0)) Returns: The chamfer distance between x an dy. If return_index is set, then this function returns a tuple (chamfer_dist, corrs_x_to_y, corrs_y_to_x) where corrs_x_to_y and corrs_y_to_x are described above.","title":"chamfer_distance()"},{"location":"sections/api_reference/#point_cloud_utils._pcu_internal.closest_points_on_mesh","text":"","title":"closest_points_on_mesh"},{"location":"sections/api_reference/#point_cloud_utils._mesh_primitives.cone_mesh","text":"Generate a triangle mesh for a cone centered at the origin and pointing up the y-axis. Parameters: radius ( float ) \u2013 Radius of the cone's base. height ( float ) \u2013 Height of the cone. sides ( int ) \u2013 Number of segments used to approximate the circular base (default = 16). bottom ( bool ) \u2013 Whether to include faces for the bottom/base of the code (default = True). Returns: vertices (np.ndarray) \u2013 Mesh vertices as an (n, 3)-shaped NumPy array faces (np.ndarray) : Mesh face indices as an (f, 3)-shaped NumPy array","title":"cone_mesh()"},{"location":"sections/api_reference/#point_cloud_utils._pcu_internal.connected_components","text":"","title":"connected_components"},{"location":"sections/api_reference/#point_cloud_utils._mesh_primitives.cube_mesh","text":"Generate a triangle mesh for a unit cube centered at the origin. Returns: vertices (np.ndarray) \u2013 Mesh vertices as an (n, 3)-shaped NumPy array faces (np.ndarray) : Mesh face indices as an (f, 3)-shaped NumPy array","title":"cube_mesh()"},{"location":"sections/api_reference/#point_cloud_utils._mesh_primitives.cylinder_mesh","text":"Generate a triangle mesh for a cylinder centered at the origin aligned with the y-axis. Parameters: radius ( float) ) \u2013 Radius of the cylinder. height ( float) ) \u2013 Height of the cylinder. sides ( int) ) \u2013 Number of sides (segments) for the cylinder (default = 16). top ( bool) ) \u2013 Include top face if True (default = True). bottom ( bool) ) \u2013 Include bottom face if True (default = True). Returns: vertices (np.ndarray) \u2013 List of vertex coordinates (shape = (v, 3)). faces (np.ndarray) : List of faces (triplets of vertex indices with shape = (f, 3)).","title":"cylinder_mesh()"},{"location":"sections/api_reference/#point_cloud_utils._pcu_internal.decimate_triangle_mesh","text":"","title":"decimate_triangle_mesh"},{"location":"sections/api_reference/#point_cloud_utils._pcu_internal.deduplicate_mesh_vertices","text":"","title":"deduplicate_mesh_vertices"},{"location":"sections/api_reference/#point_cloud_utils._pcu_internal.deduplicate_point_cloud","text":"","title":"deduplicate_point_cloud"},{"location":"sections/api_reference/#point_cloud_utils.downsample_point_cloud_on_voxel_grid","text":"Downsample a point set to conform with a voxel grid by taking the average of points within each voxel. Parameters: voxel_size \u2013 a scalar representing the size of each voxel or a 3 tuple representing the size per axis of each voxel. points \u2013 a [#v, 3]-shaped array of 3d points. args \u2013 Any additional arguments of shape [#v, ] are treated as attributes and will averaged into each voxel along with the points These will be returns min_bound \u2013 a 3 tuple representing the minimum coordinate of the voxel grid or None to use the bounding box of the input point cloud. max_bound \u2013 a 3 tuple representing the maximum coordinate of the voxel grid or None to use the bounding box of the input point cloud. min_points_per_voxel \u2013 If a voxel contains fewer than this many points, then don't include the points in that voxel in the output. Returns: A tuple (v, attrib0, attrib1, ....) of downsampled points, and point attributes. Attributes are returned in the same order they are passed in. If no attributes are passed in, then this function simply returns vertices.","title":"downsample_point_cloud_on_voxel_grid()"},{"location":"sections/api_reference/#point_cloud_utils._pcu_internal.downsample_point_cloud_poisson_disk","text":"","title":"downsample_point_cloud_poisson_disk"},{"location":"sections/api_reference/#point_cloud_utils._sinkhorn.earth_movers_distance","text":"Compute the (batched) Sinkhorn correspondences between two dirac delta distributions, U, and V. This implementation is numerically stable with float32. Parameters: p \u2013 An (n, d)-shaped array of d-dimensional points b \u2013 An (m, d)-shaped array of d-dimensional points p_norm \u2013 Which norm to use. Must be one of {non-zero int, inf, -inf, \u2018fro\u2019, \u2018nuc\u2019} (default is 2), eps \u2013 The reciprocal of the sinkhorn regularization parameter (default 1e-4) max_iters \u2013 The maximum number of Sinkhorn iterations stop_thresh \u2013 Stop if the change in iterates is below this value Returns: emd \u2013 The earth mover's distance between point clouds p and q P : An (n, m)-shaped array of correspondences between point clouds p and q","title":"earth_movers_distance()"},{"location":"sections/api_reference/#point_cloud_utils._pcu_internal.estimate_mesh_face_normals","text":"","title":"estimate_mesh_face_normals"},{"location":"sections/api_reference/#point_cloud_utils._pcu_internal.estimate_mesh_vertex_normals","text":"","title":"estimate_mesh_vertex_normals"},{"location":"sections/api_reference/#point_cloud_utils._pointcloud_normals.estimate_point_cloud_normals_ball","text":"Estimate normals for a point cloud by locally fitting a plane to all points within a radius of each point (possibly weighted by a radial basis function). This function can optionally consider directions to the sensor for each point to compute neighborhoods of points which are all facing the same direction, and align the final normal directions. Parameters: points \u2013 (n, 3)-shaped NumPy array of point positions (each row is a point) ball_radius \u2013 The radius of each neighborhood used to estimate normals view_directions \u2013 (n, 3)-shaped NumPy array or None, representing the unit direction to the sensor for each point. This parameter is used to align the normals and compute neighborhoods of similar facing points. drop_angle_threshold \u2013 If view_directions is passed in, drop points whose angle between the normal and view direction exceeds drop_angle_threshold (in radians). Useful for filtering out low quality points. min_pts_per_ball \u2013 Discard points whose neighborhood contains fewer than min_pts_per_ball points. max_pts_per_ball \u2013 If set to a positive number, then only use max_pts_per_ball points within each neighborhood whose number of points exceeds this value. weight_function \u2013 Weighting function for points in a neighborhood. Must be one of 'constant' or 'rbf' where: max_points_per_leaf \u2013 Maximum number of points in each leaf node of the KD-tree used for nearest neighbor queries. Tuning this can potentially improve performance on large point clouds. num_threads \u2013 Number of threads used to parallelize computation. If set to 0 ir 1, will run in single threaded mode. If set to a positive number t > 1, will use t threads. If set to -1, will use #processors threads for inputs greater than 1 million points. Returns: p \u2013 an (m, 3)-shaped Numpy array of 3d points n : an (m, 3)-shaped Numpy array of unit normals for each point in p See Also: estimate_pointcloud_normals_ball","title":"estimate_point_cloud_normals_ball()"},{"location":"sections/api_reference/#point_cloud_utils._pointcloud_normals.estimate_point_cloud_normals_knn","text":"Estimate normals for a point cloud by locally fitting a plane to the k nearest neighbors of each point. This function can optionally consider directions to the sensor for each point to compute neighborhoods of points which are all facing the same direction, and align the final normal directions. Parameters: points \u2013 (n, 3)-shaped NumPy array of point positions (each row is a point) num_neighbors \u2013 Integer number of neighbors to use in each neigghborhood. view_directions \u2013 (n, 3)-shaped NumPy array or None, representing the unit direction to the sensor for each point. This parameter is used to align the normals and compute neighborhoods of similar facing points. drop_angle_threshold \u2013 If view_directions is passed in, drop points whose angle between the normal and view direction exceeds drop_angle_threshold (in radians). Useful for filtering out low quality points. max_points_per_leaf \u2013 Maximum number of points in each leaf node of the KD-tree used for nearest neighbor queries. Tuning this can potentially improve performance on large point clouds. num_threads \u2013 Number of threads used to parallelize computation. If set to 0 ir 1, will run in single threaded mode. If set to a positive number t > 1, will use t threads. If set to -1, will use #processors threads for inputs greater than 1 million points. Returns: idx \u2013 an (m, 1)-shaped Numpy array of indices into points n : an (m, 3)-shaped Numpy array of unit normals for each point in p See Also: estimate_pointcloud_normals_ball","title":"estimate_point_cloud_normals_knn()"},{"location":"sections/api_reference/#point_cloud_utils._voxels.flood_fill_3d","text":"Flood fill a 3D grid starting from_start_coord with fill_value. This will return a copy of grid where the region in the input grid which is connected to start_coord and shares the value of start_coord is set to fill_value. Parameters: grid ( np.ndarray ) \u2013 [w, h, d] array of scalars as input to the flood fill start_coord \u2013 (i, j, k) integer coordinate to start the flood fill fill_value \u2013 scalar value to flood fill Returns: _type_ \u2013 A flood filled copy of grid where all voxels which are connected to start_coord are set to fill_value","title":"flood_fill_3d()"},{"location":"sections/api_reference/#point_cloud_utils.hausdorff_distance","text":"Compute the Hausdorff distance between x and y Parameters: x \u2013 n by 3 array of representing a set of n points (each row is a point of dimension 3) y \u2013 m by 3 array of representing a set of m points (each row is a point of dimension 3) return_index \u2013 Optionally return the index pair (i, j) into x and y such that x[i, :] and y[j, :] are the two points with maximum shortest distance. squared_distances \u2013 If set to True, then return squared L2 distances. Default is False. max_points_per_leaf \u2013 The maximum number of points per leaf node in the KD tree used by this function. Default is 10. Returns: The largest shortest distance, d between each point in source and the points in target . If return_index is set, then this function returns a tuple (d, i, j) where d is as described above and (i, j) are such that source[i, \u2013 ] and target[j, :] are the two points with maximum shortest distance.","title":"hausdorff_distance()"},{"location":"sections/api_reference/#point_cloud_utils.interpolate_barycentric_coords","text":"Interpolate an attribute stored at each vertex of a mesh across the faces of a triangle mesh using barycentric coordinates Parameters: f \u2013 a (#faces, 3)-shaped NumPy array of mesh faces (indexing into some vertex array). fi \u2013 a (#attribs,)-shaped NumPy array of indexes into f indicating which face each attribute lies within. bc \u2013 a (#attribs, 3)-shaped NumPy array of barycentric coordinates for each attribute attribute \u2013 a (#vertices, dim)-shaped NumPy array of attributes at each of the mesh vertices Returns: A (#attribs, dim)-shaped array of interpolated attributes.","title":"interpolate_barycentric_coords()"},{"location":"sections/api_reference/#point_cloud_utils._pcu_internal.k_nearest_neighbors","text":"","title":"k_nearest_neighbors"},{"location":"sections/api_reference/#point_cloud_utils._pcu_internal.laplacian_smooth_mesh","text":"","title":"laplacian_smooth_mesh"},{"location":"sections/api_reference/#point_cloud_utils._pcu_internal.lloyd_2d","text":"","title":"lloyd_2d"},{"location":"sections/api_reference/#point_cloud_utils._pcu_internal.lloyd_3d","text":"","title":"lloyd_3d"},{"location":"sections/api_reference/#point_cloud_utils._mesh_io.load_mesh_v","text":"Load a point cloud consisting only of vertex positions. Point Cloud Utils currently supports PLY, OBJ, STL, OFF, VRML 2.0, X3D, COLLADA, 3DS. Parameters: filename \u2013 Path to the file to be loaded. Must have a valid extension. dtype \u2013 The floating point type of loaded data ( np.float32 or np.float64 ) Returns: v \u2013 An (n, 3)-shaped numpy array of coordinates","title":"load_mesh_v()"},{"location":"sections/api_reference/#point_cloud_utils._mesh_io.load_mesh_vc","text":"Load a point cloud consisting of vertex positions, and vertex colors. Point Cloud Utils currently supports PLY, OBJ, STL, OFF, VRML 2.0, X3D, COLLADA, 3DS. Parameters: filename \u2013 Path to the file to be loaded. Must have a valid extension. dtype \u2013 The floating point type of loaded data ( np.float32 or np.float64 ) Returns: v \u2013 An (n, 3)-shaped numpy array of coordinates c : An (n, 3)-shaped or (n, 4)-shaped numpy array of per-vertex RGB or RGBA colors (from 0.0 to 1.0)","title":"load_mesh_vc()"},{"location":"sections/api_reference/#point_cloud_utils._mesh_io.load_mesh_vf","text":"Load a triangle mesh consisting of vertex positions and face indices. Point Cloud Utils currently supports PLY, OBJ, STL, OFF, VRML 2.0, X3D, COLLADA, 3DS. Parameters: filename \u2013 Path to the file to be loaded. Must have a valid extension. dtype \u2013 The floating point type of loaded data ( np.float32 or np.float64 ) Returns: v \u2013 An (n, 3)-shaped numpy array of coordinates f : An (m, 3)-shaped integer numpy array of face indices into v","title":"load_mesh_vf()"},{"location":"sections/api_reference/#point_cloud_utils._mesh_io.load_mesh_vfc","text":"Load a triangle mesh consisting of vertex positions, face indices, and vertex colors. Point Cloud Utils currently supports PLY, OBJ, STL, OFF, VRML 2.0, X3D, COLLADA, 3DS. Parameters: filename \u2013 Path to the file to be loaded. Must have a valid extension. dtype \u2013 The floating point type of loaded data ( np.float32 or np.float64 ) Returns: v \u2013 An (n, 3)-shaped numpy array of coordinates f : An (m, 3)-shaped integer numpy array of face indices into v c : An (n, 3)-shaped or (n, 4)-shaped numpy array of per-vertex RGB or RGBA colors (from 0.0 to 1.0)","title":"load_mesh_vfc()"},{"location":"sections/api_reference/#point_cloud_utils._mesh_io.load_mesh_vfn","text":"Load a triangle mesh consisting of vertex positions, face indices, and vertex normals. Point Cloud Utils currently supports PLY, OBJ, STL, OFF, VRML 2.0, X3D, COLLADA, 3DS. Parameters: filename \u2013 Path to the file to be loaded. Must have a valid extension. dtype \u2013 The floating point type of loaded data ( np.float32 or np.float64 ) Returns: v \u2013 An (n, 3)-shaped numpy array of coordinates f : An (m, 3)-shaped integer numpy array of face indices into v n : An (n, 3)-shaped numpy array of per-vertex normals","title":"load_mesh_vfn()"},{"location":"sections/api_reference/#point_cloud_utils._mesh_io.load_mesh_vfnc","text":"Load a triangle mesh consisting of vertex positions, face indices, vertex normals, and vertex colors. Point Cloud Utils currently supports PLY, OBJ, STL, OFF, VRML 2.0, X3D, COLLADA, 3DS. Parameters: filename \u2013 Path to the file to be loaded. Must have a valid extension. dtype \u2013 The floating point type of loaded data ( np.float32 or np.float64 ) Returns: v \u2013 An (n, 3)-shaped numpy array of coordinates f : An (m, 3)-shaped integer numpy array of face indices into v n : An (n, 3)-shaped numpy array of per-vertex normals c : An (n, 3)-shaped or (n, 4)-shaped numpy array of per-vertex RGB or RGBA colors (from 0.0 to 1.0)","title":"load_mesh_vfnc()"},{"location":"sections/api_reference/#point_cloud_utils._mesh_io.load_mesh_vn","text":"Load a point cloud consisting of vertex positions, and vertex normals. Point Cloud Utils currently supports PLY, OBJ, STL, OFF, VRML 2.0, X3D, COLLADA, 3DS. Parameters: filename \u2013 Path to the file to be loaded. Must have a valid extension. dtype \u2013 The floating point type of loaded data ( np.float32 or np.float64 ) Returns: v \u2013 An (n, 3)-shaped numpy array of coordinates n : An (n, 3)-shaped numpy array of per-vertex normals","title":"load_mesh_vn()"},{"location":"sections/api_reference/#point_cloud_utils._mesh_io.load_mesh_vnc","text":"Load a point cloud consisting of vertex positions, vertex normals, and vertex colors. Point Cloud Utils currently supports PLY, OBJ, STL, OFF, VRML 2.0, X3D, COLLADA, 3DS. Parameters: filename \u2013 Path to the file to be loaded. Must have a valid extension. dtype \u2013 The floating point type of loaded data ( np.float32 or np.float64 ) Returns: v \u2013 An (n, 3)-shaped numpy array of coordinates n : An (n, 3)-shaped numpy array of per-vertex normals c : An (n, 3)-shaped or (n, 4)-shaped numpy array of per-vertex RGB or RGBA colors (from 0.0 to 1.0)","title":"load_mesh_vnc()"},{"location":"sections/api_reference/#point_cloud_utils._mesh_io.load_triangle_mesh","text":"Load a triangle mesh into a TriangleMesh class. Point Cloud Utils currently supports PLY, OBJ, STL, OFF, VRML 2.0, X3D, COLLADA, 3DS. Parameters: filename \u2013 Path to the file to be saved. Must have a valid extension. dtype \u2013 The type of floating point number to store the data in (np.float32 or np.float64) Returns: mesh \u2013 A TriangleMesh class containing the loaded mesh","title":"load_triangle_mesh()"},{"location":"sections/api_reference/#point_cloud_utils._pcu_internal.make_mesh_watertight","text":"","title":"make_mesh_watertight"},{"location":"sections/api_reference/#point_cloud_utils._pcu_internal.marching_cubes_sparse_voxel_grid","text":"","title":"marching_cubes_sparse_voxel_grid"},{"location":"sections/api_reference/#point_cloud_utils._pcu_internal.mesh_face_areas","text":"","title":"mesh_face_areas"},{"location":"sections/api_reference/#point_cloud_utils._pcu_internal.morton_add","text":"","title":"morton_add"},{"location":"sections/api_reference/#point_cloud_utils._pcu_internal.morton_decode","text":"","title":"morton_decode"},{"location":"sections/api_reference/#point_cloud_utils._pcu_internal.morton_encode","text":"","title":"morton_encode"},{"location":"sections/api_reference/#point_cloud_utils._pcu_internal.morton_knn","text":"","title":"morton_knn"},{"location":"sections/api_reference/#point_cloud_utils._pcu_internal.morton_subtract","text":"","title":"morton_subtract"},{"location":"sections/api_reference/#point_cloud_utils._pcu_internal.one_sided_hausdorff_distance","text":"","title":"one_sided_hausdorff_distance"},{"location":"sections/api_reference/#point_cloud_utils._pcu_internal.orient_mesh_faces","text":"","title":"orient_mesh_faces"},{"location":"sections/api_reference/#point_cloud_utils._sinkhorn.pairwise_distances","text":"Compute the (batched) pairwise distance matrix between a and b which both have size [m, n, d] or [n, d]. The result is a tensor of size [m, n, n] (or [n, n]) whose entry [m, i, j] contains the distance_tensor between a[m, i, :] and b[m, j, :]. Parameters: a \u2013 A tensor containing m batches of n points of dimension d. i.e. of size (m, n, d) b \u2013 A tensor containing m batches of n points of dimension d. i.e. of size (m, n, d) p \u2013 Norm to use for the distance_tensor Returns: M \u2013 A (m, n, n)-shaped array containing the pairwise distance_tensor between each pair of inputs in a batch.","title":"pairwise_distances()"},{"location":"sections/api_reference/#point_cloud_utils._pcu_internal.point_cloud_fast_winding_number","text":"","title":"point_cloud_fast_winding_number"},{"location":"sections/api_reference/#point_cloud_utils._point_cloud_geometry.pointcloud_sphere_geometry","text":"Generate sphere geometry for a point cloud (i.e. one sphere per point) Parameters: p \u2013 #p by 3 array of vertex positions (each row is a vertex) r \u2013 Array or Scalar describing the radius along each axis (Either one radius per vertex, or a global size for the whole point cloud) num_stacks \u2013 Number of latitudal subdivisions num_slices \u2013 Number of longitudal subdivisions Returns: verts \u2013 an array of shape (#output_vertices, 3) faces : an array of shape (#output_faces, 3) indexing into verts","title":"pointcloud_sphere_geometry()"},{"location":"sections/api_reference/#point_cloud_utils._point_cloud_geometry.pointcloud_surfel_geometry","text":"Generate geometry for a point cloud encoded as surfels (i.e. circular patches centered at each point and oriented perpendicularly to each normal) Parameters: p \u2013 #p by 3 array of vertex positions (each row is a vertex) n \u2013 #p by 3 array of vertex normals (each row is a vertex) r \u2013 Array or Scalar describing the size of each geometry element (Either one radius per vertex, or a global size for the whole point cloud) subdivs \u2013 Number of times to subdivide the patch geometry for each point (i.e. # tris per cicle) Returns: verts \u2013 an array of shape (#output_vertices, 3) faces : an array of shape (#output_faces, 3) indexing into verts","title":"pointcloud_surfel_geometry()"},{"location":"sections/api_reference/#point_cloud_utils._pcu_internal.ray_mesh_intersection","text":"","title":"ray_mesh_intersection"},{"location":"sections/api_reference/#point_cloud_utils._ray_point_cloud_intersector.ray_surfel_intersection","text":"Compute intersection between a set of rays and a point cloud converted to surfels (i.e. circular patches oriented with the point normals) Parameters: p \u2013 #p by 3 array of vertex positions (each row is a vertex) n \u2013 #p by 3 Matrix of vertex normals (each row is a vertex) ray_o \u2013 array of shape (#rays, 3) of ray origins (one per row) or a single array of shape (3,) to use ray_d \u2013 array of shape (#rays, 3) of ray directions (one per row) r \u2013 Array or Scalar describing the size of each geometry element (Either one radius per vertex, or a global size for the whole point cloud) subdivs \u2013 Number of times to subdivide the patch geometry for each point (i.e. # tris per cicle) ray_near \u2013 an optional floating point value indicating the distance along each ray to start searching (default 0.0) ray_far \u2013 an optional floating point value indicating the maximum distance along each ray to search (default inf) Returns: t \u2013 a (#rays,) shaped array encoding the distance between the ray origin and intersection point for each ray (inf for missed rays) pid : a (#rays,) shaped array of integer indices corresponding to which points were hit (-1 for a ray miss)","title":"ray_surfel_intersection()"},{"location":"sections/api_reference/#point_cloud_utils._pcu_internal.remove_unreferenced_mesh_vertices","text":"","title":"remove_unreferenced_mesh_vertices"},{"location":"sections/api_reference/#point_cloud_utils._pcu_internal.sample_mesh_lloyd","text":"","title":"sample_mesh_lloyd"},{"location":"sections/api_reference/#point_cloud_utils._pcu_internal.sample_mesh_poisson_disk","text":"","title":"sample_mesh_poisson_disk"},{"location":"sections/api_reference/#point_cloud_utils._pcu_internal.sample_mesh_random","text":"","title":"sample_mesh_random"},{"location":"sections/api_reference/#point_cloud_utils._mesh_io.save_mesh_v","text":"Save a point cloud consisting only of vertex positions. Point Cloud Utils currently supports PLY, OBJ, STL, OFF, VRML 2.0, X3D, COLLADA, 3DS. Parameters: filename \u2013 Path to the file to be saved. Must have a valid extension. v \u2013 An (n, 3)-shaped numpy array of coordinates dtype \u2013 The floating point written to the file ( np.float32 or np.float64 )","title":"save_mesh_v()"},{"location":"sections/api_reference/#point_cloud_utils._mesh_io.save_mesh_vc","text":"Save a point cloud consisting of vertex positions and vertex colors. Point Cloud Utils currently supports PLY, OBJ, STL, OFF, VRML 2.0, X3D, COLLADA, 3DS. Parameters: filename \u2013 Path to the file to be saved. Must have a valid extension. v \u2013 An (n, 3)-shaped numpy array of coordinates c \u2013 An (n, 3)-shaped or (n, 4)-shaped numpy array of per-vertex RGB or RGBA colors (from 0.0 to 1.0) dtype \u2013 The floating point written to the file ( np.float32 or np.float64 )","title":"save_mesh_vc()"},{"location":"sections/api_reference/#point_cloud_utils._mesh_io.save_mesh_vf","text":"Save a triangle mesh consisting of vertex positions and face indices. Point Cloud Utils currently supports PLY, OBJ, STL, OFF, VRML 2.0, X3D, COLLADA, 3DS. Parameters: filename \u2013 Path to the file to be saved. Must have a valid extension. v \u2013 An (n, 3)-shaped numpy array of coordinates f \u2013 An (m, 3)-shaped integer numpy array of face indices into v dtype \u2013 The floating point written to the file ( np.float32 or np.float64 )","title":"save_mesh_vf()"},{"location":"sections/api_reference/#point_cloud_utils._mesh_io.save_mesh_vfc","text":"Save a triangle mesh consisting of vertex positions, face indices, and vertex colors. Point Cloud Utils currently supports PLY, OBJ, STL, OFF, VRML 2.0, X3D, COLLADA, 3DS. Parameters: filename \u2013 Path to the file to be saved. Must have a valid extension. v \u2013 An (n, 3)-shaped numpy array of coordinates f \u2013 An (m, 3)-shaped integer numpy array of face indices into v c \u2013 An (n, 3)-shaped or (n, 4)-shaped numpy array of per-vertex RGB or RGBA colors (from 0.0 to 1.0) dtype \u2013 The floating point written to the file ( np.float32 or np.float64 )","title":"save_mesh_vfc()"},{"location":"sections/api_reference/#point_cloud_utils._mesh_io.save_mesh_vfn","text":"Save a triangle mesh consisting of vertex positions, face indices, and vertex normals. Point Cloud Utils currently supports PLY, OBJ, STL, OFF, VRML 2.0, X3D, COLLADA, 3DS. Parameters: filename \u2013 Path to the file to be saved. Must have a valid extension. v \u2013 An (n, 3)-shaped numpy array of coordinates f \u2013 An (m, 3)-shaped integer numpy array of face indices into v n \u2013 An (n, 3)-shaped numpy array of per-vertex normals dtype \u2013 The floating point written to the file ( np.float32 or np.float64 )","title":"save_mesh_vfn()"},{"location":"sections/api_reference/#point_cloud_utils._mesh_io.save_mesh_vfnc","text":"Save a triangle mesh consisting of vertex positions, face indices, vertex normals, and vertex colors. Point Cloud Utils currently supports PLY, OBJ, STL, OFF, VRML 2.0, X3D, COLLADA, 3DS. Parameters: filename \u2013 Path to the file to be saved. Must have a valid extension. v \u2013 An (n, 3)-shaped numpy array of coordinates f \u2013 An (m, 3)-shaped integer numpy array of face indices into v n \u2013 An (n, 3)-shaped numpy array of per-vertex normals c \u2013 An (n, 3)-shaped or (n, 4)-shaped numpy array of per-vertex RGB or RGBA colors (from 0.0 to 1.0) dtype \u2013 The floating point written to the file ( np.float32 or np.float64 )","title":"save_mesh_vfnc()"},{"location":"sections/api_reference/#point_cloud_utils._mesh_io.save_mesh_vn","text":"Save a point cloud consisting of vertex positions and vertex normals. Point Cloud Utils currently supports PLY, OBJ, STL, OFF, VRML 2.0, X3D, COLLADA, 3DS. Parameters: filename \u2013 Path to the file to be saved. Must have a valid extension. v \u2013 An (n, 3)-shaped numpy array of coordinates n \u2013 An (n, 3)-shaped numpy array of per-vertex normals dtype \u2013 The floating point written to the file ( np.float32 or np.float64 )","title":"save_mesh_vn()"},{"location":"sections/api_reference/#point_cloud_utils._mesh_io.save_mesh_vnc","text":"Save a point cloud consisting of vertex positions, vertex normals, and vertex colors. Point Cloud Utils currently supports PLY, OBJ, STL, OFF, VRML 2.0, X3D, COLLADA, 3DS. Parameters: filename \u2013 Path to the file to be saved. Must have a valid extension. v \u2013 An (n, 3)-shaped numpy array of coordinates n \u2013 An (n, 3)-shaped numpy array of per-vertex normals c \u2013 An (n, 3)-shaped or (n, 4)-shaped numpy array of per-vertex RGB or RGBA colors (from 0.0 to 1.0) dtype \u2013 The floating point written to the file ( np.float32 or np.float64 )","title":"save_mesh_vnc()"},{"location":"sections/api_reference/#point_cloud_utils._mesh_io.save_triangle_mesh","text":"Save a triangle mesh to a file with various per-vertex, per-face, and per-wedge attributes. Each argument (except v) is optional and can be None. Parameters: filename ( ) \u2013 Path to the mesh to save. The type of file will be determined from the file extension. v ( ) \u2013 [V, 3]-shaped numpy array of per-vertex positions f ( ) \u2013 [F, 3]-shaped numpy array of integer face indices into TrianglMesh.vertex_data.positions (or None) vn ( ) \u2013 [V, 3]-shaped numpy array of per-vertex normals (or None) vt ( ) \u2013 [V, 2]-shaped numpy array of per-vertex uv coordinates (or None) vc ( ) \u2013 [V, 4]-shaped numpy array of per-vertex RBGA colors in [0.0, 1.0] (or None) vq ( ) \u2013 [V,]-shaped numpy array of per-vertex quality measures (or None) vr ( ) \u2013 [V,]-shaped numpy array of per-vertex curvature radii (or None) vti ( ) \u2013 [V,]-shaped numpy array of integer indices into TriangleMesh.textures indicating which texture to use at this vertex (or None) vflags ( ) \u2013 [V,]-shaped numpy array of 32-bit integer flags per vertex (or None) fn ( ) \u2013 [F, 3]-shaped numpy array of per-face normals (or None) fc ( ) \u2013 [F, 4]-shaped numpy array of per-face RBGA colors in [0.0, 1.0] (or None) fq ( ) \u2013 [F,]-shaped numpy array of per-face quality measures (or None) fflags ( ) \u2013 [F,]-shaped numpy array of 32-bit integer flags per face (or None) wc ( ) \u2013 [F, 3, 4]-shaped numpy array of per-wedge RBGA colors in [0.0, 1.0] (or None) wn ( ) \u2013 [F, 3, 3]-shaped numpy array of per-wedge normals (or None) wt ( ) \u2013 [F, 3, 2]-shaped numpy array of per-wedge] uv coordinates (or None) wti ( ) \u2013 [F, 3]-shaped numpy array of integer indices into TriangleMesh.textures indicating which textures ( ) \u2013 A list of paths to texture image files for this mesh normal_maps \u2013 A list of paths to texture image files for this mesh dtype ( ) \u2013 The floating point written to the file ( np.float32 or np.float64 )","title":"save_triangle_mesh()"},{"location":"sections/api_reference/#point_cloud_utils._pcu_internal.signed_distance_to_mesh","text":"","title":"signed_distance_to_mesh"},{"location":"sections/api_reference/#point_cloud_utils._sinkhorn.sinkhorn","text":"Compute the (batched) Sinkhorn correspondences between two dirac delta distributions, U, and V. This implementation is numerically stable with float32. Parameters: a \u2013 A m-sized minibatch of weights for each dirac in the first distribution, U. i.e. shape = (m, n) b \u2013 A m-sized minibatch of weights for each dirac in the second distribution, V. i.e. shape = (m, n) M \u2013 A minibatch of n-by-n tensors storing the distance between each pair of diracs in U and V. i.e. shape = (m, n, n) and each i.e. M[k, i, j] = ||u[k,_i] - v[k, j]|| eps \u2013 The reciprocal of the sinkhorn regularization parameter max_iters \u2013 The maximum number of Sinkhorn iterations stop_thresh \u2013 Stop if the change in iterates is below this value Returns: P \u2013 An (m, n, n)-shaped array of correspondences between distributions U and V","title":"sinkhorn()"},{"location":"sections/api_reference/#point_cloud_utils._pcu_internal.sparse_voxel_grid_boundary","text":"","title":"sparse_voxel_grid_boundary"},{"location":"sections/api_reference/#point_cloud_utils._mesh_primitives.sphere_mesh","text":"Generate a triangle mesh approximating a unit sphere centered at the origin by subdividing an isocahedron. Parameters: subdivisions ( int) ) \u2013 Number of times to subdivide an isocahedron to get the mesh (default = 3). Returns: vertices (np.ndarray) \u2013 Mesh vertices as an (n, 3)-shaped NumPy array faces (np.ndarray) : Mesh face indices as an (f, 3)-shaped NumPy array","title":"sphere_mesh()"},{"location":"sections/api_reference/#point_cloud_utils._pcu_internal.triangle_soup_fast_winding_number","text":"","title":"triangle_soup_fast_winding_number"},{"location":"sections/api_reference/#point_cloud_utils._pcu_internal.voronoi_centroids_unit_cube","text":"","title":"voronoi_centroids_unit_cube"},{"location":"sections/api_reference/#point_cloud_utils._point_cloud_geometry.voxel_grid_geometry","text":"Generate a triangle mesh of cubes for voxel coordinates ijk. The [0, 0, 0] voxel has its center at voxel_origin and each voxel has voxel_size. Parameters: ijk ( np.ndarray ) \u2013 [num_voxels, 3] array of integer voxel coordinates voxel_size \u2013 Float or triple representing the size of each voxel. Defaults to np.array((1., 1., 1.)). voxel_origin \u2013 Center coordinate of the [0, 0, 0] voxel. Defaults to np.array((0., 0., 0.)). gap_fraction \u2013 Fraction of a voxel to leave as a gap between voxels (default 0.0) Returns: v \u2013 Numpy array of vertices for the cube mesh f: Numpy array of faces for the cube mesh","title":"voxel_grid_geometry()"},{"location":"sections/api_reference/#point_cloud_utils._voxels.voxelize_triangle_mesh","text":"Return ijk coordinates of voxels which intersect the given mesh. Each voxel is assumed to have size voxel_size (scalar or triple of floats) and the (0, 0, 0) voxel has its bottom-back-left corner at voxel_origin Parameters: v ( np.ndarray ) \u2013 [num_vertices, 3] array of triangle mesh vertices f ( np.ndarray ) \u2013 [num_faces, 3] array of face indexes into v voxel_size \u2013 A float or triple specifying the size of each voxel voxel_origin \u2013 A float or triple specifying the the position of the bottom-back-left corner of the (0, 0, 0) voxel Returns: ijk \u2013 [num_vox, 3] array of integer ijk coordinates for each voxel intersecting the mesh","title":"voxelize_triangle_mesh()"},{"location":"sections/calculating_mesh_face_areas/","text":"Calculating Mesh Face Areas You can easily calculate mesh face areas in Point-Cloud-Utils import point_cloud_utils as pcu v, f = pcu.load_mesh_vf(\"bunny.ply\") areas = pcu.mesh_face_areas(v, f) Mesh colored by face areas.","title":"Calculating Mesh Face Areas"},{"location":"sections/calculating_mesh_face_areas/#calculating-mesh-face-areas","text":"You can easily calculate mesh face areas in Point-Cloud-Utils import point_cloud_utils as pcu v, f = pcu.load_mesh_vf(\"bunny.ply\") areas = pcu.mesh_face_areas(v, f) Mesh colored by face areas.","title":"Calculating Mesh Face Areas"},{"location":"sections/cleaning_shapenet/","text":"Making an SDF Dataset for ShapeNet The code below is a simple script for making a dataset of signed distance functions for the ShapeNet Dataset . To get started, first make an account and download ShapeNet here . Once you have downloaded ShapeNet, run the script below from the root of the dataset. It loads each ShapeNet model, which may be non-watertight and non-manifold, computes a watertight and manifold mesh for that object and generates 100k points in the volume around the shape along with their corresponding signed distances. It also generates 100k points on the surface of the shape with surface normals at those points. import os import numpy as np import point_cloud_utils as pcu # Path to the bench category as an example category_path = \"./02828884\" # Resolution used to convert shapes to watertight manifolds # Higher value means better quality and slower manifold_resolution = 20_000 # Number of points in the volume to sample around the shape num_vol_pts = 100_000 # Number of points on the surface to sample num_surf_pts = 100_000 for model_path in os.listdir(category_path): v, f = pcu.load_mesh_vf(os.path.join(category_path, model_path, \"model.obj\")) # Convert mesh to watertight manifold vm, fm = pcu.make_mesh_watertight(v, f, manifold_resolution) nm = pcu.estimate_mesh_vertex_normals(vm, fm) # Compute vertex normals for watertight mesh # Generate random points in the volume around the shape # NOTE: ShapeNet shapes are normalized within [-0.5, 0.5]^3 p_vol = (np.random.rand(num_vol_pts, 3) - 0.5) * 1.1 # Comput the SDF of the random points sdf, _, _ = pcu.signed_distance_to_mesh(p_vol, vm, fm) # Sample points on the surface as face ids and barycentric coordinates fid_surf, bc_surf = pcu.sample_mesh_random(vm, fm, num_surf_pts) # Compute 3D coordinates and normals of surface samples p_surf = pcu.interpolate_barycentric_coords(fm, fid_surf, bc_surf, vm) n_surf = pcu.interpolate_barycentric_coords(fm, fid_surf, bc_surf, nm) # Save volume points + SDF and surface points + normals # Load using np.load() npz_path = os.path.join(category_path, model_path, \"samples.npz\") np.savez(npz_path, p_vol=p_vol, sdf_vol=sdf, p_surf=p_surf, n_surf=n_surf) # Save the watertight mesh watertight_mesh_path = os.path.join(category_math, model_path, \"model_watertight.obj\") pcu.save_mesh_vfn(watertight_mesh_path, vm, fm, nm) Top Left: Input ShapeNet mesh (not manifold or watertight), Top Right: Watertight manifold extracted from input ShapeNet mesh, Bottom Left: Points sampled on the surface of the watertight mesh, Bottom Right: Volume points colored by SDF for the extracted watertight shape.","title":"Making a ShapeNet SDF dataset"},{"location":"sections/cleaning_shapenet/#making-an-sdf-dataset-for-shapenet","text":"The code below is a simple script for making a dataset of signed distance functions for the ShapeNet Dataset . To get started, first make an account and download ShapeNet here . Once you have downloaded ShapeNet, run the script below from the root of the dataset. It loads each ShapeNet model, which may be non-watertight and non-manifold, computes a watertight and manifold mesh for that object and generates 100k points in the volume around the shape along with their corresponding signed distances. It also generates 100k points on the surface of the shape with surface normals at those points. import os import numpy as np import point_cloud_utils as pcu # Path to the bench category as an example category_path = \"./02828884\" # Resolution used to convert shapes to watertight manifolds # Higher value means better quality and slower manifold_resolution = 20_000 # Number of points in the volume to sample around the shape num_vol_pts = 100_000 # Number of points on the surface to sample num_surf_pts = 100_000 for model_path in os.listdir(category_path): v, f = pcu.load_mesh_vf(os.path.join(category_path, model_path, \"model.obj\")) # Convert mesh to watertight manifold vm, fm = pcu.make_mesh_watertight(v, f, manifold_resolution) nm = pcu.estimate_mesh_vertex_normals(vm, fm) # Compute vertex normals for watertight mesh # Generate random points in the volume around the shape # NOTE: ShapeNet shapes are normalized within [-0.5, 0.5]^3 p_vol = (np.random.rand(num_vol_pts, 3) - 0.5) * 1.1 # Comput the SDF of the random points sdf, _, _ = pcu.signed_distance_to_mesh(p_vol, vm, fm) # Sample points on the surface as face ids and barycentric coordinates fid_surf, bc_surf = pcu.sample_mesh_random(vm, fm, num_surf_pts) # Compute 3D coordinates and normals of surface samples p_surf = pcu.interpolate_barycentric_coords(fm, fid_surf, bc_surf, vm) n_surf = pcu.interpolate_barycentric_coords(fm, fid_surf, bc_surf, nm) # Save volume points + SDF and surface points + normals # Load using np.load() npz_path = os.path.join(category_path, model_path, \"samples.npz\") np.savez(npz_path, p_vol=p_vol, sdf_vol=sdf, p_surf=p_surf, n_surf=n_surf) # Save the watertight mesh watertight_mesh_path = os.path.join(category_math, model_path, \"model_watertight.obj\") pcu.save_mesh_vfn(watertight_mesh_path, vm, fm, nm) Top Left: Input ShapeNet mesh (not manifold or watertight), Top Right: Watertight manifold extracted from input ShapeNet mesh, Bottom Left: Points sampled on the surface of the watertight mesh, Bottom Right: Volume points colored by SDF for the extracted watertight shape.","title":"Making an SDF Dataset for ShapeNet"},{"location":"sections/closest_point_on_mesh/","text":"Finding Closest Points Between Point Clouds and Meshes You can easily find the closest point on a mesh to any 3D point in space with Point-Cloud-Utils. import point_cloud_utils as pcu # Load a mesh stored in my_mesh.ply: # v is a NumPy array of coordinates with shape (V, 3) # f is a NumPy array of face indices with shape (F, 3) v, f = pcu.load_mesh_vf(\"bunny.ply\") # Generate random points on a sphere around the shape p = np.random.randn(33, 3) p /= np.linalg.norm(p, axis=-1, keepdims=True) # Compute the shortest distance between each point in p and the mesh: # dists is a NumPy array of shape (P,) where dists[i] is the # shortest distnace between the point p[i, :] and the mesh (v, f) dists, fid, bc = pcu.closest_points_on_mesh(p, v, f) # Interpolate the barycentric coordinates to get the coordinates of # the closest points on the mesh to each point in p closest_pts = pcu.interpolate_barycentric_coords(f, fid, bc, v) The nearest neighbors (purple dots) on the mesh to the blue points. The edges connect each point to its nearest point. Representing mesh-surface samples in Point Cloud Utils Point Cloud Utils returns samples on the surface of a mesh using Barycentric Coordinates . i.e. each sample is encoded as: The index of the mesh face containing it (usually referred to as fid ) The barycentric coordinates of the point within that face (usually referred to as bc ) Encoding surface samples as barycentric coordinates. The teal point is the barycentric combination with weights \\((\\alpha, \\beta, \\gamma)\\) in face 3. The reason for encoding points in this way is that it allows us to interpolate any quantity stored at the vertices (including their positions) of a mesh to the sample positions, and thus sample vertex attributes. To recover vertex quantities from fid , bc pairs use the function pcu.interpolate_barycentric_coords(f, fid, bc, vertex_quantity)","title":"Finding Closest Points Between Point Clouds and Meshes"},{"location":"sections/closest_point_on_mesh/#finding-closest-points-between-point-clouds-and-meshes","text":"You can easily find the closest point on a mesh to any 3D point in space with Point-Cloud-Utils. import point_cloud_utils as pcu # Load a mesh stored in my_mesh.ply: # v is a NumPy array of coordinates with shape (V, 3) # f is a NumPy array of face indices with shape (F, 3) v, f = pcu.load_mesh_vf(\"bunny.ply\") # Generate random points on a sphere around the shape p = np.random.randn(33, 3) p /= np.linalg.norm(p, axis=-1, keepdims=True) # Compute the shortest distance between each point in p and the mesh: # dists is a NumPy array of shape (P,) where dists[i] is the # shortest distnace between the point p[i, :] and the mesh (v, f) dists, fid, bc = pcu.closest_points_on_mesh(p, v, f) # Interpolate the barycentric coordinates to get the coordinates of # the closest points on the mesh to each point in p closest_pts = pcu.interpolate_barycentric_coords(f, fid, bc, v) The nearest neighbors (purple dots) on the mesh to the blue points. The edges connect each point to its nearest point. Representing mesh-surface samples in Point Cloud Utils Point Cloud Utils returns samples on the surface of a mesh using Barycentric Coordinates . i.e. each sample is encoded as: The index of the mesh face containing it (usually referred to as fid ) The barycentric coordinates of the point within that face (usually referred to as bc ) Encoding surface samples as barycentric coordinates. The teal point is the barycentric combination with weights \\((\\alpha, \\beta, \\gamma)\\) in face 3. The reason for encoding points in this way is that it allows us to interpolate any quantity stored at the vertices (including their positions) of a mesh to the sample positions, and thus sample vertex attributes. To recover vertex quantities from fid , bc pairs use the function pcu.interpolate_barycentric_coords(f, fid, bc, vertex_quantity)","title":"Finding Closest Points Between Point Clouds and Meshes"},{"location":"sections/computing_connected_components_of_a_mesh/","text":"Computing Connected Components of a Mesh Point Cloud Utils lets you easily find connected components of a mesh using the connected_components function: import point_cloud_utils as pcu v, f = pcu.load_mesh_vf(\"tree.ply\") # * cv a [num_vertices,]-shaped array where cv[i] is the integer # id of the connected component for vertex v[i] # * nv is a [num_connected_components]-shaped array where nv[j] is # the number of vertices in connected component j # * cf a [num_faces,]-shaped array where cf[i] is the integer # id of the connected component for face f[i] # * nv is a [num_connected_components]-shaped array where nf[j] is # the number of faces in connected component j cv, nv, cf, nf = pcu.connected_components(v, f) A mesh where each face is colored according to the connected component that face belongs to.","title":"Computing Connected Components of a Mesh"},{"location":"sections/computing_connected_components_of_a_mesh/#computing-connected-components-of-a-mesh","text":"Point Cloud Utils lets you easily find connected components of a mesh using the connected_components function: import point_cloud_utils as pcu v, f = pcu.load_mesh_vf(\"tree.ply\") # * cv a [num_vertices,]-shaped array where cv[i] is the integer # id of the connected component for vertex v[i] # * nv is a [num_connected_components]-shaped array where nv[j] is # the number of vertices in connected component j # * cf a [num_faces,]-shaped array where cf[i] is the integer # id of the connected component for face f[i] # * nv is a [num_connected_components]-shaped array where nf[j] is # the number of faces in connected component j cv, nv, cf, nf = pcu.connected_components(v, f) A mesh where each face is colored according to the connected component that face belongs to.","title":"Computing Connected Components of a Mesh"},{"location":"sections/consistently_orienting_mesh_faces/","text":"Consistently Orienting Mesh Faces Often, meshes in the wild have inconsistently oriented faces, which can cause issues (e.g. due to flipped normals). Point Cloud Utils lets you consistently orient normals within each component import numpy as np import point_cloud_utils as pcu v, f = pcu.load_mesh_vf(\"truck.ply\") # * f_oriented is a new face array where faces within each connected # component are consistently oriented # * f_comp is a [num_faces,]-shaped array where f_comp[i] is the # connected component of the i^th face f_oriented, f_comp = pcu.orient_mesh_faces(f) Left: Mesh with inconsistently oriented faces. Right: Cleaned mesh with consistently oriented faces.","title":"Consistently Orienting Mesh Faces"},{"location":"sections/consistently_orienting_mesh_faces/#consistently-orienting-mesh-faces","text":"Often, meshes in the wild have inconsistently oriented faces, which can cause issues (e.g. due to flipped normals). Point Cloud Utils lets you consistently orient normals within each component import numpy as np import point_cloud_utils as pcu v, f = pcu.load_mesh_vf(\"truck.ply\") # * f_oriented is a new face array where faces within each connected # component are consistently oriented # * f_comp is a [num_faces,]-shaped array where f_comp[i] is the # connected component of the i^th face f_oriented, f_comp = pcu.orient_mesh_faces(f) Left: Mesh with inconsistently oriented faces. Right: Cleaned mesh with consistently oriented faces.","title":"Consistently Orienting Mesh Faces"},{"location":"sections/deduplicating_point_clouds_and_meshes/","text":"Deduplicating Point Clouds and Meshes","title":"Deduplicating Point Clouds and Meshes"},{"location":"sections/deduplicating_point_clouds_and_meshes/#deduplicating-point-clouds-and-meshes","text":"","title":"Deduplicating Point Clouds and Meshes"},{"location":"sections/mesh_decimation/","text":"Decimating a Mesh Point Cloud Utils supports mesh decimation using the Quadric Edge Collapse algorithm. import numpy as np import point_cloud_utils as pcu v, f = pcu.load_mesh_vf(\"bunny.ply\") # v_quarter, f_quarter are the mesh vertices and faces of the decimated mesh # corr_qv and corr_qf are the correspondences between vertices and faces in the # original mesh and the decimated mesh. # i.e. corr_qv[i] is the index of the vertex in v which generated v_quarter[i] # corr_qf[i] is the index of the face in f which generated f_quarter[i] v_quarter, f_quarter, corr_qv, corr_qf = pcu.decimate_triangle_mesh(v, f, max_faces=f.shape[0]//4) v_eighth, f_eighth, _, _ = pcu.decimate_triangle_mesh(v, f, max_faces=f.shape[0]//8) From Left to Right: full mesh, a quarter of the number of faces, an eighth the number of faces.","title":"Decimating a Mesh"},{"location":"sections/mesh_decimation/#decimating-a-mesh","text":"Point Cloud Utils supports mesh decimation using the Quadric Edge Collapse algorithm. import numpy as np import point_cloud_utils as pcu v, f = pcu.load_mesh_vf(\"bunny.ply\") # v_quarter, f_quarter are the mesh vertices and faces of the decimated mesh # corr_qv and corr_qf are the correspondences between vertices and faces in the # original mesh and the decimated mesh. # i.e. corr_qv[i] is the index of the vertex in v which generated v_quarter[i] # corr_qf[i] is the index of the face in f which generated f_quarter[i] v_quarter, f_quarter, corr_qv, corr_qf = pcu.decimate_triangle_mesh(v, f, max_faces=f.shape[0]//4) v_eighth, f_eighth, _, _ = pcu.decimate_triangle_mesh(v, f, max_faces=f.shape[0]//8) From Left to Right: full mesh, a quarter of the number of faces, an eighth the number of faces.","title":"Decimating a Mesh"},{"location":"sections/mesh_io/","text":"Mesh and Point Cloud I/O If your file can be imported into MeshLab, we can read it! Point Cloud Utils supports reading and writing many common 3D formats (PLY, STL, OFF, OBJ, 3DS, VRML 2.0, X3D, COLLADA). In all the functions in this section, the type of file is inferred from its file extension. 3D Data Representation in Point Cloud Utils Point Cloud Utils uses NumPy arrays as a fundamental data structure for storing 3D data. Representing Point Clouds A point cloud with #p points is represented as a simple Numpy array with shape (#p, 3) (one point per row). The example below illustrates a point cloud with six points. Representing Triangle Meshes A triangle mesh with #v vertices and #f faces is stored using a pair of NumPy arrays v, f with shape (#v, 3) and (#f, 3) respectively. Each row of v stores a vertex coordinate and each row of f stores three integer indexes into v denoting the three vertices forming that face. Per-vertex attributes are stored as separate NumPy arrays with #v rows (one row per vertex). For example, consider the mesh with 6 vertices and 5 faces illustrated above. We would store this as two numpy arrays v, f with v.shape = (6, 3) and f.shape = (5, 3) . The i th row of v is a 3D vector encoding the position of the vertex v i , and j th row of f holds three indices to each of the vertices of the j th face. In the figure, the second face is formed by the vertices v 1 , v 2 , v 5 , so the second row of f are the integers (1, 2, 5) . Representing Point and Face Attributes In addition to vertices and face data, we often want to store attributes alongside a point cloud or mesh. Attributes can be stored per-point as well as per-face. Attributes are stored as NumPy arrays with one attribute per row. Examples of attributes include point cloud normals, point colors, per-face colors, or per-vertex texture coordinates. Example - Storing face colors and vertex normals in a mesh: For example, consider the mesh described above with 6 vertices and 5 faces, stored as two arrays v and f with shapes (6, 3) and (5, 3) respectively. We could store per-face colors as a NumPy array with shape (5, 3) each row is the color of the correponding face: Per-face attributes are stored in an array with the same number of rows as the face array We could store per-vertex normals as a NumPy array of shape (6, 3) where each row contains the normal at the corresponding vertex: Per-vertex attributes (e.g. normals) are stored in an array with the same number of rows as the vertex array Shorthand functions for loading and saving 3D data Many times, we only need to load a few attributes from a mesh or point cloud. For example, we may only want the vertices, faces, and vertex colors for mesh. Point Cloud Utils provides a number of shorthand helper functions which can load these attributes directly into NumPy arrays. These functions have the form load_mesh_* and save_mesh_* where * indicates which data to load. If some attribute is not present in the file being loaded, these functions will simply return an empty array. Load/Save only points import point_cloud_utils as pcu # v is a NumPy array of shape (#v, 3) of points v = pcu.load_mesh_v(\"path/to/mesh\") pcu.save_mesh_v(\"path/to/mash\", v) Load/Save mesh vertices and faces import point_cloud_utils as pcu # v is a NumPy array of shape (#v, 3) of points # f is a NumPy array of shape (#f, 3) of face indices v, f = pcu.load_mesh_vf(\"path/to/mesh\") pcu.save_mesh_vf(\"path/to/mash\", v, f) Load/Save points and per-point normals import point_cloud_utils as pcu # v is a NumPy array of shape (#v, 3) of points # n is a NumPy array of shape (#v, 3) of per-vertex normals v, n = pcu.load_mesh_vn(\"path/to/mesh\") pcu.save_mesh_vn(\"path/to/mash\", v, n) Load/Save mesh vertices, faces, and vertex colors import point_cloud_utils as pcu # v is a NumPy array of shape (#v, 3) of points # f is a NumPy array of shape (#f, 3) of face indices # c is a NumPy array of shape (#v, 4) of RBGA per-vertex colors v, f, c = pcu.load_mesh_vfc(\"path/to/mesh\") pcu.save_mesh_vfc(\"path/to/mash\", v, f, c) Load/Save mesh vertices, faces, and vertex normals import point_cloud_utils as pcu # v is a NumPy array of shape (#v, 3) of points # f is a NumPy array of shape (#f, 3) of face indices # n is a NumPy array of shape (#v, 3) of per-vertex normals v, f, n = pcu.load_mesh_vfn(\"path/to/mesh\") pcu.save_mesh_vfn(\"path/to/mash\", v, f, n) Load/Save mesh vertices, faces, vertex normals, and vertex colors import point_cloud_utils as pcu # v is a NumPy array of shape (#v, 3) of points # f is a NumPy array of shape (#f, 3) of face indices # n is a NumPy array of shape (#v, 3) of per-vertex normals # c is a NumPy array of shape (#v, 4) of RBGA per-vertex colors v, f, n, c = pcu.load_mesh_vfn(\"path/to/mesh\") pcu.save_mesh_vfnc(\"path/to/mash\", v, f, n, c) Loading 3D data with all attributes Some meshes or point clouds may have more complex attribute structures, or we may not know which attributes are stored in the mesh file before loading it. In this case, Point Cloud Utils provides utilities to load a mesh into a TriangleMesh class. TriangleMesh is a lightweight container containing numpy arrays for vertices, faces, textures, and other attributes. To load a mesh into a TriangleMesh class simply construct it with the path to the mesh: import point_cloud_utils as pcu mesh = pcu.TriangleMesh(\"path/to/mesh\") To save a TriangleMesh object, simply call the save method with the desired path: mesh.save(\"path/to/mesh\") The TriangleMesh class contains attributes encoding vertex and face data as well as texture information. It is structured as follows: TriangleMesh : vertex_data : positions : (#v, 3)-shaped NumPy array of per-vertex positions normals : (#v, 3)-shaped NumPy array of per-vertex normals (or None ) texcoords : (#v, 2)-shaped NumPy array of per-vertex uv coordinates (or None ) tex_ids : (#v,)-shaped NumPy array of integer indices into TriangleMesh.textures indicating which texture to use at this vertex (or None ) colors : (#v, 4)-shaped NumPy array of per-vertex RBGA colors in [0.0, 1.0] (or None ) radius : (#v,)-shaped NumPy array of per-vertex curvature radii (or None ) quality : (#v,)-shaped NumPy array of per-vertex quality measures (or None ) flags : (#v,)-shaped NumPy array of 32-bit integer flags per vertex (or None ) face_data : vertex_ids : (#f, 3)-shaped NumPy array of integer face indices into TrianglMesh.vertex_data.positions normals : (#f, 3)-shaped NumPy array of per-face normals (or None ) colors : (#f, 4)-shaped NumPy array of per-face RBGA colors in [0.0, 1.0] (or None ) quality : (#f,)-shaped NumPy array of per-face quality measures (or None ) flags : (#f,(-shaped NumPy array of 32-bit integer flags per face (or None ) wedge_colors : (#f, 3, 4)-shaped NumPy array of per-wedge RBGA colors in [0.0, 1.0] (or None ) wedge_normals : (#f, 3, 3)-shaped NumPy array of per-wedge normals (or None ) wedge_texcoords : (#f, 3, 2)-shaped NumPy array of per-wedge] uv coordinates (or None ) wedge_tex_ids : (#f, 3)-shaped NumPy array of integer indices into TriangleMesh.textures indicating which texture to use at this wedge (or None ) textures : A list of paths to texture image files for this mesh normal_maps : A list of paths to texture image files for this mesh The hierarchy of the list above denotes composition. For example, to access the vertex colors of a TriangleMesh , you would read the TriangleMesh.vertex_data.colors property. Remark on wedge face attributes The face_data member of the TriangleMesh class contains a number of wedge attributes. These all start with wedge_ . In this context a wedge is a corner of a triangle face. Each face contains three wedges corresponding to each corner. Wedge attributes have shape (#f, 3, d) where d is the dimension of the attribute. Wedges attributes are useful for storing which are discontinous across face boundaries.","title":"Mesh and Point Cloud I/O"},{"location":"sections/mesh_io/#mesh-and-point-cloud-io","text":"If your file can be imported into MeshLab, we can read it! Point Cloud Utils supports reading and writing many common 3D formats (PLY, STL, OFF, OBJ, 3DS, VRML 2.0, X3D, COLLADA). In all the functions in this section, the type of file is inferred from its file extension.","title":"Mesh and Point Cloud I/O"},{"location":"sections/mesh_io/#3d-data-representation-in-point-cloud-utils","text":"Point Cloud Utils uses NumPy arrays as a fundamental data structure for storing 3D data.","title":"3D Data Representation in Point Cloud Utils"},{"location":"sections/mesh_io/#representing-point-clouds","text":"A point cloud with #p points is represented as a simple Numpy array with shape (#p, 3) (one point per row). The example below illustrates a point cloud with six points.","title":"Representing Point Clouds"},{"location":"sections/mesh_io/#representing-triangle-meshes","text":"A triangle mesh with #v vertices and #f faces is stored using a pair of NumPy arrays v, f with shape (#v, 3) and (#f, 3) respectively. Each row of v stores a vertex coordinate and each row of f stores three integer indexes into v denoting the three vertices forming that face. Per-vertex attributes are stored as separate NumPy arrays with #v rows (one row per vertex). For example, consider the mesh with 6 vertices and 5 faces illustrated above. We would store this as two numpy arrays v, f with v.shape = (6, 3) and f.shape = (5, 3) . The i th row of v is a 3D vector encoding the position of the vertex v i , and j th row of f holds three indices to each of the vertices of the j th face. In the figure, the second face is formed by the vertices v 1 , v 2 , v 5 , so the second row of f are the integers (1, 2, 5) .","title":"Representing Triangle Meshes"},{"location":"sections/mesh_io/#representing-point-and-face-attributes","text":"In addition to vertices and face data, we often want to store attributes alongside a point cloud or mesh. Attributes can be stored per-point as well as per-face. Attributes are stored as NumPy arrays with one attribute per row. Examples of attributes include point cloud normals, point colors, per-face colors, or per-vertex texture coordinates. Example - Storing face colors and vertex normals in a mesh: For example, consider the mesh described above with 6 vertices and 5 faces, stored as two arrays v and f with shapes (6, 3) and (5, 3) respectively. We could store per-face colors as a NumPy array with shape (5, 3) each row is the color of the correponding face: Per-face attributes are stored in an array with the same number of rows as the face array We could store per-vertex normals as a NumPy array of shape (6, 3) where each row contains the normal at the corresponding vertex: Per-vertex attributes (e.g. normals) are stored in an array with the same number of rows as the vertex array","title":"Representing Point and Face Attributes"},{"location":"sections/mesh_io/#shorthand-functions-for-loading-and-saving-3d-data","text":"Many times, we only need to load a few attributes from a mesh or point cloud. For example, we may only want the vertices, faces, and vertex colors for mesh. Point Cloud Utils provides a number of shorthand helper functions which can load these attributes directly into NumPy arrays. These functions have the form load_mesh_* and save_mesh_* where * indicates which data to load. If some attribute is not present in the file being loaded, these functions will simply return an empty array.","title":"Shorthand functions for loading and saving 3D data"},{"location":"sections/mesh_io/#loadsave-only-points","text":"import point_cloud_utils as pcu # v is a NumPy array of shape (#v, 3) of points v = pcu.load_mesh_v(\"path/to/mesh\") pcu.save_mesh_v(\"path/to/mash\", v)","title":"Load/Save only points"},{"location":"sections/mesh_io/#loadsave-mesh-vertices-and-faces","text":"import point_cloud_utils as pcu # v is a NumPy array of shape (#v, 3) of points # f is a NumPy array of shape (#f, 3) of face indices v, f = pcu.load_mesh_vf(\"path/to/mesh\") pcu.save_mesh_vf(\"path/to/mash\", v, f)","title":"Load/Save mesh vertices and faces"},{"location":"sections/mesh_io/#loadsave-points-and-per-point-normals","text":"import point_cloud_utils as pcu # v is a NumPy array of shape (#v, 3) of points # n is a NumPy array of shape (#v, 3) of per-vertex normals v, n = pcu.load_mesh_vn(\"path/to/mesh\") pcu.save_mesh_vn(\"path/to/mash\", v, n)","title":"Load/Save points and per-point normals"},{"location":"sections/mesh_io/#loadsave-mesh-vertices-faces-and-vertex-colors","text":"import point_cloud_utils as pcu # v is a NumPy array of shape (#v, 3) of points # f is a NumPy array of shape (#f, 3) of face indices # c is a NumPy array of shape (#v, 4) of RBGA per-vertex colors v, f, c = pcu.load_mesh_vfc(\"path/to/mesh\") pcu.save_mesh_vfc(\"path/to/mash\", v, f, c)","title":"Load/Save mesh vertices, faces, and vertex colors"},{"location":"sections/mesh_io/#loadsave-mesh-vertices-faces-and-vertex-normals","text":"import point_cloud_utils as pcu # v is a NumPy array of shape (#v, 3) of points # f is a NumPy array of shape (#f, 3) of face indices # n is a NumPy array of shape (#v, 3) of per-vertex normals v, f, n = pcu.load_mesh_vfn(\"path/to/mesh\") pcu.save_mesh_vfn(\"path/to/mash\", v, f, n)","title":"Load/Save mesh vertices, faces, and vertex normals"},{"location":"sections/mesh_io/#loadsave-mesh-vertices-faces-vertex-normals-and-vertex-colors","text":"import point_cloud_utils as pcu # v is a NumPy array of shape (#v, 3) of points # f is a NumPy array of shape (#f, 3) of face indices # n is a NumPy array of shape (#v, 3) of per-vertex normals # c is a NumPy array of shape (#v, 4) of RBGA per-vertex colors v, f, n, c = pcu.load_mesh_vfn(\"path/to/mesh\") pcu.save_mesh_vfnc(\"path/to/mash\", v, f, n, c)","title":"Load/Save mesh vertices, faces, vertex normals, and vertex colors"},{"location":"sections/mesh_io/#loading-3d-data-with-all-attributes","text":"Some meshes or point clouds may have more complex attribute structures, or we may not know which attributes are stored in the mesh file before loading it. In this case, Point Cloud Utils provides utilities to load a mesh into a TriangleMesh class. TriangleMesh is a lightweight container containing numpy arrays for vertices, faces, textures, and other attributes. To load a mesh into a TriangleMesh class simply construct it with the path to the mesh: import point_cloud_utils as pcu mesh = pcu.TriangleMesh(\"path/to/mesh\") To save a TriangleMesh object, simply call the save method with the desired path: mesh.save(\"path/to/mesh\") The TriangleMesh class contains attributes encoding vertex and face data as well as texture information. It is structured as follows: TriangleMesh : vertex_data : positions : (#v, 3)-shaped NumPy array of per-vertex positions normals : (#v, 3)-shaped NumPy array of per-vertex normals (or None ) texcoords : (#v, 2)-shaped NumPy array of per-vertex uv coordinates (or None ) tex_ids : (#v,)-shaped NumPy array of integer indices into TriangleMesh.textures indicating which texture to use at this vertex (or None ) colors : (#v, 4)-shaped NumPy array of per-vertex RBGA colors in [0.0, 1.0] (or None ) radius : (#v,)-shaped NumPy array of per-vertex curvature radii (or None ) quality : (#v,)-shaped NumPy array of per-vertex quality measures (or None ) flags : (#v,)-shaped NumPy array of 32-bit integer flags per vertex (or None ) face_data : vertex_ids : (#f, 3)-shaped NumPy array of integer face indices into TrianglMesh.vertex_data.positions normals : (#f, 3)-shaped NumPy array of per-face normals (or None ) colors : (#f, 4)-shaped NumPy array of per-face RBGA colors in [0.0, 1.0] (or None ) quality : (#f,)-shaped NumPy array of per-face quality measures (or None ) flags : (#f,(-shaped NumPy array of 32-bit integer flags per face (or None ) wedge_colors : (#f, 3, 4)-shaped NumPy array of per-wedge RBGA colors in [0.0, 1.0] (or None ) wedge_normals : (#f, 3, 3)-shaped NumPy array of per-wedge normals (or None ) wedge_texcoords : (#f, 3, 2)-shaped NumPy array of per-wedge] uv coordinates (or None ) wedge_tex_ids : (#f, 3)-shaped NumPy array of integer indices into TriangleMesh.textures indicating which texture to use at this wedge (or None ) textures : A list of paths to texture image files for this mesh normal_maps : A list of paths to texture image files for this mesh The hierarchy of the list above denotes composition. For example, to access the vertex colors of a TriangleMesh , you would read the TriangleMesh.vertex_data.colors property. Remark on wedge face attributes The face_data member of the TriangleMesh class contains a number of wedge attributes. These all start with wedge_ . In this context a wedge is a corner of a triangle face. Each face contains three wedges corresponding to each corner. Wedge attributes have shape (#f, 3, d) where d is the dimension of the attribute. Wedges attributes are useful for storing which are discontinous across face boundaries.","title":"Loading 3D data with all attributes"},{"location":"sections/mesh_normal_estimation/","text":"Computing Mesh Normals Point-Cloud-Utils lets you easily compute both vertex and face normals for a mesh Per-Vertex Normals import point_cloud_utils as pcu v, f = pcu.load_mesh_vf(\"bunny.ply\") # n is a NumPy array with the same shape as v containing vertex normals n = pcu.estimate_mesh_normals(v, f) Estimating vertex normals for a triangle mesh. Per-Face Normals for a Mesh import point_cloud_utils as pcu v, f = pcu.load_mesh_vf(\"bunny.ply\") # n is a NumPy array with the same shape as f containing face normals n = pcu.estimate_mesh_face_normals(v, f) Estimating face normals for a triangle mesh","title":"Computing Mesh Normals"},{"location":"sections/mesh_normal_estimation/#computing-mesh-normals","text":"Point-Cloud-Utils lets you easily compute both vertex and face normals for a mesh","title":"Computing Mesh Normals"},{"location":"sections/mesh_normal_estimation/#per-vertex-normals","text":"import point_cloud_utils as pcu v, f = pcu.load_mesh_vf(\"bunny.ply\") # n is a NumPy array with the same shape as v containing vertex normals n = pcu.estimate_mesh_normals(v, f) Estimating vertex normals for a triangle mesh.","title":"Per-Vertex Normals"},{"location":"sections/mesh_normal_estimation/#per-face-normals-for-a-mesh","text":"import point_cloud_utils as pcu v, f = pcu.load_mesh_vf(\"bunny.ply\") # n is a NumPy array with the same shape as f containing face normals n = pcu.estimate_mesh_face_normals(v, f) Estimating face normals for a triangle mesh","title":"Per-Face Normals for a Mesh"},{"location":"sections/mesh_sampling/","text":"Generating Point Samples on a Mesh Point Cloud Utils provides tools for generating point samples on a triangle mesh. Representing mesh-surface samples in Point Cloud Utils Point Cloud Utils returns samples on the surface of a mesh using Barycentric Coordinates . i.e. each sample is encoded as: The index of the mesh face containing it (usually referred to as fid ) The barycentric coordinates of the point within that face (usually referred to as bc ) Encoding surface samples as barycentric coordinates. The teal point is the barycentric combination with weights \\((\\alpha, \\beta, \\gamma)\\) in face 3. The reason for encoding points in this way is that it allows us to interpolate any quantity stored at the vertices (including their positions) of a mesh to the sample positions, and thus sample vertex attributes. To recover vertex quantities from fid , bc pairs use the function pcu.interpolate_barycentric_coords(f, fid, bc, vertex_quantity) Generating random samples on a mesh We often want to sample points uniformly at random on a 3D surface. Point Cloud Utils provides a simple function for generating iid point samples such that each sample has equal probability of landing anywhere on the surface. import point_cloud_utils as pcu # v is a [n, 3] shaped NumPy array of vertices # f is a [m, 3] shaped integer NumPy array of indices into v # n is a [n, 3] shaped NumPy array of vertex normals v, f, n = pcu.load_mesh_vfn(\"bunny.ply\") # Generate barycentric coordinates of random samples num_samples = 1000 fid, bc = pcu.sample_mesh_random(v, f, num_samples) # Interpolate the vertex positions and normals using the returned barycentric coordinates # to get sample positions and normals rand_positions = pcu.interpolate_barycentric_coords(f, fid, bc, v) rand_normals = pcu.interpolate_barycentric_coords(f, fid, bc, n) Generating random (yellow) points on the mesh. We can also extract vertex attributes such as normals (pink arrows) at the points. Generating blue-noise random samples on a mesh We may want to sample a surface in a random way such that the samples are evenly spaced apart. Such a distribution of points is called a \"blue noise\" distribution. Formally, this means that the expected distance between points on the surface is some constant. i.e. for a set of points \\(P\\) : $$ \\mathbb{E}_{x \\in P} ||x - \\text{nearest_neighbor}(x)|| = \\epsilon $$ This can be achieved with Poisson Disk Sampling. Point cloud utils supports sampling a mesh such that there are either (1) a target number of points or (2) such that the points are separated by some radius. import point_cloud_utils as pcu import numpy as np # v is a [n, 3] shaped NumPy array of vertices # f is a [m, 3] shaped integer NumPy array of indices into v # n is a [n, 3] shaped NumPy array of vertex normals v, f, n = pcu.load_mesh_vfn(\"bunny.ply\") ### Option 1: ### Generating points according to a blue noise distribution with a target number of points ### NOTE: The number of returned points may not be exactly 1000 target_num_pts= 1000 # Generate barycentric coordinates of random samples fid, bc = pcu.sample_mesh_poisson_disk(v, f, num_samples=target_num_pts) # Interpolate the vertex positions and normals using the returned barycentric coordinates # to get sample positions and normals rand_positions = pcu.interpolate_barycentric_coords(f, fid, bc, v) rand_normals = pcu.interpolate_barycentric_coords(f, fid, bc, n) ### Option 2: ### Generating points according to a blue noise distribution with a target nradius separating each point target_radius = np.linalg.norm(p.max(0) - p.min(0)) * 0.01 # 1% of the bounding box radius # Generate barycentric coordinates of random samples fid, bc = pcu.sample_mesh_poisson_disk(v, f, num_samples=-1, radius=target_radius) # Interpolate the vertex positions and normals using the returned barycentric coordinates # to get sample positions and normals rand_positions = pcu.interpolate_barycentric_coords(f, fid, bc, v) rand_normals = pcu.interpolate_barycentric_coords(f, fid, bc, n) Generating blue noise samples on a mesh using a target number of points (left) and a target radius (right).","title":"Generating Point Samples on a Mesh"},{"location":"sections/mesh_sampling/#generating-point-samples-on-a-mesh","text":"Point Cloud Utils provides tools for generating point samples on a triangle mesh. Representing mesh-surface samples in Point Cloud Utils Point Cloud Utils returns samples on the surface of a mesh using Barycentric Coordinates . i.e. each sample is encoded as: The index of the mesh face containing it (usually referred to as fid ) The barycentric coordinates of the point within that face (usually referred to as bc ) Encoding surface samples as barycentric coordinates. The teal point is the barycentric combination with weights \\((\\alpha, \\beta, \\gamma)\\) in face 3. The reason for encoding points in this way is that it allows us to interpolate any quantity stored at the vertices (including their positions) of a mesh to the sample positions, and thus sample vertex attributes. To recover vertex quantities from fid , bc pairs use the function pcu.interpolate_barycentric_coords(f, fid, bc, vertex_quantity)","title":"Generating Point Samples on a Mesh"},{"location":"sections/mesh_sampling/#generating-random-samples-on-a-mesh","text":"We often want to sample points uniformly at random on a 3D surface. Point Cloud Utils provides a simple function for generating iid point samples such that each sample has equal probability of landing anywhere on the surface. import point_cloud_utils as pcu # v is a [n, 3] shaped NumPy array of vertices # f is a [m, 3] shaped integer NumPy array of indices into v # n is a [n, 3] shaped NumPy array of vertex normals v, f, n = pcu.load_mesh_vfn(\"bunny.ply\") # Generate barycentric coordinates of random samples num_samples = 1000 fid, bc = pcu.sample_mesh_random(v, f, num_samples) # Interpolate the vertex positions and normals using the returned barycentric coordinates # to get sample positions and normals rand_positions = pcu.interpolate_barycentric_coords(f, fid, bc, v) rand_normals = pcu.interpolate_barycentric_coords(f, fid, bc, n) Generating random (yellow) points on the mesh. We can also extract vertex attributes such as normals (pink arrows) at the points.","title":"Generating random samples on a mesh"},{"location":"sections/mesh_sampling/#generating-blue-noise-random-samples-on-a-mesh","text":"We may want to sample a surface in a random way such that the samples are evenly spaced apart. Such a distribution of points is called a \"blue noise\" distribution. Formally, this means that the expected distance between points on the surface is some constant. i.e. for a set of points \\(P\\) : $$ \\mathbb{E}_{x \\in P} ||x - \\text{nearest_neighbor}(x)|| = \\epsilon $$ This can be achieved with Poisson Disk Sampling. Point cloud utils supports sampling a mesh such that there are either (1) a target number of points or (2) such that the points are separated by some radius. import point_cloud_utils as pcu import numpy as np # v is a [n, 3] shaped NumPy array of vertices # f is a [m, 3] shaped integer NumPy array of indices into v # n is a [n, 3] shaped NumPy array of vertex normals v, f, n = pcu.load_mesh_vfn(\"bunny.ply\") ### Option 1: ### Generating points according to a blue noise distribution with a target number of points ### NOTE: The number of returned points may not be exactly 1000 target_num_pts= 1000 # Generate barycentric coordinates of random samples fid, bc = pcu.sample_mesh_poisson_disk(v, f, num_samples=target_num_pts) # Interpolate the vertex positions and normals using the returned barycentric coordinates # to get sample positions and normals rand_positions = pcu.interpolate_barycentric_coords(f, fid, bc, v) rand_normals = pcu.interpolate_barycentric_coords(f, fid, bc, n) ### Option 2: ### Generating points according to a blue noise distribution with a target nradius separating each point target_radius = np.linalg.norm(p.max(0) - p.min(0)) * 0.01 # 1% of the bounding box radius # Generate barycentric coordinates of random samples fid, bc = pcu.sample_mesh_poisson_disk(v, f, num_samples=-1, radius=target_radius) # Interpolate the vertex positions and normals using the returned barycentric coordinates # to get sample positions and normals rand_positions = pcu.interpolate_barycentric_coords(f, fid, bc, v) rand_normals = pcu.interpolate_barycentric_coords(f, fid, bc, n) Generating blue noise samples on a mesh using a target number of points (left) and a target radius (right).","title":"Generating blue-noise random samples on a mesh"},{"location":"sections/mesh_sdf/","text":"Computing Signed Distances (SDFs) to Meshes Many applications require a signed distance function (SDF) representation for a 3D shape . For example, many shape reconstruction neural networks such as DeepSDF require such a representation for training. Unfortunately, most 3D shape data is stored as a triangle mesh, making SDFs not readily available. Point-Cloud-Utils makes it very easy to extract signed distances from a triangle mesh. Remark about mesh quality To extract an SDF for a triangle mesh, the mesh must be of relatively good quality (manifold, watertight, no sliver triangles, etc...). To clean up a mesh for SDF extraction see Making a triangle mesh watertight . SDF Overview A signed distance function \\(f : \\mathbb{R}^3 \\rightarrow \\mathbb{R}\\) maps 3D points \\(x \\in \\mathbb{R}^3\\) to the nearest distance between \\(x\\) and some surface \\(S\\) . In other words: $$ f(x) = \\min_{x' \\in S} |x - x'|_2 $$ The zero level set of the SDF \\(f\\) are precisely the set of points which lie on the surface. i.e. $$ S = {x : f(x) = 0} $$ The image below shows a plot of the SDF for the boundary of the letters PCU. Level sets of the signed distance function for the letters PCU. The zero level set (surface) is colored as a white line. Computing an SDF to a Mesh We can compute the signed distance of a set of points in Point-Cloud-Utils in the following way: import numpy as np import point_cloud_utils as pcu # 1000 random query points to compute the SDF at query_pts = np.random.rand(1000, 3) v, f = pcu.load_mesh_vf(\"bunny.ply\") # sdf is the signed distance for each query point # fid is the nearest face to each query point on the mesh # bc are the barycentric coordinates of the nearest point to each query point within the face sdf, fid, bc = pcu.signed_distance_to_mesh(query_pts, v, f) Below we plot the sampled points colored by their SDF values: A thousand points sammpled around the bunny colored by their signed distance values. Representing mesh-surface samples in Point Cloud Utils Point Cloud Utils returns samples on the surface of a mesh using Barycentric Coordinates . i.e. each sample is encoded as: The index of the mesh face containing it (usually referred to as fid ) The barycentric coordinates of the point within that face (usually referred to as bc ) Encoding surface samples as barycentric coordinates. The teal point is the barycentric combination with weights \\((\\alpha, \\beta, \\gamma)\\) in face 3. The reason for encoding points in this way is that it allows us to interpolate any quantity stored at the vertices (including their positions) of a mesh to the sample positions, and thus sample vertex attributes. To recover vertex quantities from fid , bc pairs use the function pcu.interpolate_barycentric_coords(f, fid, bc, vertex_quantity)","title":"Computing Signed Distances (SDFs) to Meshes"},{"location":"sections/mesh_sdf/#computing-signed-distances-sdfs-to-meshes","text":"Many applications require a signed distance function (SDF) representation for a 3D shape . For example, many shape reconstruction neural networks such as DeepSDF require such a representation for training. Unfortunately, most 3D shape data is stored as a triangle mesh, making SDFs not readily available. Point-Cloud-Utils makes it very easy to extract signed distances from a triangle mesh. Remark about mesh quality To extract an SDF for a triangle mesh, the mesh must be of relatively good quality (manifold, watertight, no sliver triangles, etc...). To clean up a mesh for SDF extraction see Making a triangle mesh watertight .","title":"Computing Signed Distances (SDFs) to Meshes"},{"location":"sections/mesh_sdf/#sdf-overview","text":"A signed distance function \\(f : \\mathbb{R}^3 \\rightarrow \\mathbb{R}\\) maps 3D points \\(x \\in \\mathbb{R}^3\\) to the nearest distance between \\(x\\) and some surface \\(S\\) . In other words: $$ f(x) = \\min_{x' \\in S} |x - x'|_2 $$ The zero level set of the SDF \\(f\\) are precisely the set of points which lie on the surface. i.e. $$ S = {x : f(x) = 0} $$ The image below shows a plot of the SDF for the boundary of the letters PCU. Level sets of the signed distance function for the letters PCU. The zero level set (surface) is colored as a white line.","title":"SDF Overview"},{"location":"sections/mesh_sdf/#computing-an-sdf-to-a-mesh","text":"We can compute the signed distance of a set of points in Point-Cloud-Utils in the following way: import numpy as np import point_cloud_utils as pcu # 1000 random query points to compute the SDF at query_pts = np.random.rand(1000, 3) v, f = pcu.load_mesh_vf(\"bunny.ply\") # sdf is the signed distance for each query point # fid is the nearest face to each query point on the mesh # bc are the barycentric coordinates of the nearest point to each query point within the face sdf, fid, bc = pcu.signed_distance_to_mesh(query_pts, v, f) Below we plot the sampled points colored by their SDF values: A thousand points sammpled around the bunny colored by their signed distance values. Representing mesh-surface samples in Point Cloud Utils Point Cloud Utils returns samples on the surface of a mesh using Barycentric Coordinates . i.e. each sample is encoded as: The index of the mesh face containing it (usually referred to as fid ) The barycentric coordinates of the point within that face (usually referred to as bc ) Encoding surface samples as barycentric coordinates. The teal point is the barycentric combination with weights \\((\\alpha, \\beta, \\gamma)\\) in face 3. The reason for encoding points in this way is that it allows us to interpolate any quantity stored at the vertices (including their positions) of a mesh to the sample positions, and thus sample vertex attributes. To recover vertex quantities from fid , bc pairs use the function pcu.interpolate_barycentric_coords(f, fid, bc, vertex_quantity)","title":"Computing an SDF to a Mesh"},{"location":"sections/mesh_smoothing/","text":"Smoothing a Mesh Point Cloud Utils supports simple Laplacian Smoothing of a triangle mesh. import numpy as np import point_cloud_utils as pcu v, f = pcu.load_mesh_vf(\"bunny.ply\") n = pcu.estimate_mesh_vertex_normals(v, f) # Add Gaussian noise to each vertex along its normal v += np.random.randn(v.shape[0], 1) * n * 0.02 # Run 4 iterations of Laplacian smoothing. use_cotan_weights is an # optional parameter specifying whether to use uniform or cotangent # weights. # v_smooth has the same shape as v and contains the smooth vertices v_smooth = pcu.laplacian_smooth_mesh(v, f, num_iters=4, use_cotan_weights=True) Left: A noisy triangle mesh. Right: The noisy mesh after 4 iterations of Laplacian smoothing.","title":"Smoothing a Mesh"},{"location":"sections/mesh_smoothing/#smoothing-a-mesh","text":"Point Cloud Utils supports simple Laplacian Smoothing of a triangle mesh. import numpy as np import point_cloud_utils as pcu v, f = pcu.load_mesh_vf(\"bunny.ply\") n = pcu.estimate_mesh_vertex_normals(v, f) # Add Gaussian noise to each vertex along its normal v += np.random.randn(v.shape[0], 1) * n * 0.02 # Run 4 iterations of Laplacian smoothing. use_cotan_weights is an # optional parameter specifying whether to use uniform or cotangent # weights. # v_smooth has the same shape as v and contains the smooth vertices v_smooth = pcu.laplacian_smooth_mesh(v, f, num_iters=4, use_cotan_weights=True) Left: A noisy triangle mesh. Right: The noisy mesh after 4 iterations of Laplacian smoothing.","title":"Smoothing a Mesh"},{"location":"sections/morton_coding/","text":"Morton Encoding/Decoding a Point Cloud Point Cloud Utils has a number of tools for operating on Morton Encoded point clouds. Morton encoding works by projecting points onto a space filling Z-Curve (illustrated below), and recording the distance along this curve from the origin. Z-order curves fill space by repeated subdivision. This image shows one, two and three iterations of z-order subdivision. Morton Encoding point clouds has a number of useful application, such as approximate-k-nearest neighbor search, locality-sensitive point hashing, and point sorting, to name a few. To morton encode a point cloud, you must first convert the point coordinates to integers via quantization. The Point Cloud Utils morton coding utility uses 64 bits and can thus represent points in \\(x \\in [-1048576, 1048576]^3 \\subset \\mathbb{Z}^3\\) . Morton Encoding and Decoding Points You can quickly encode/decode points to/from Morton codes by quantizing them to integer coordinates and calling morton_encode / morton_decode . import numpy as np import point_cloud_utils as pcu pts = pcu.load_mesh_v(\"truck.ply\") # quantize points to bins of size 1/128 # NOTE: quantized point coordinates must lie between -1048576 and 1048576 eps = 1.0 / 128.0 pts_quantized = (pts / eps).astype(np.int32) # Convert points to morton codes # morton_codes has shape [pts.shape[0],] (one code per point) morton_codes = pcu.morton_encode(pts_quantized) # Decode morton codes back to integer coordinates pts_decoded = pcu.morton_decode(morton_codes) Approximate K-Nearest-Neighbor Search with Morton Coding Finding the nearest points in Morton space to a set of query points is a very fast aproximate KNN algorithm. This can be done via morton_knn : import numpy as np import point_cloud_utils as pcu # Load target point cloud pts = pcu.load_mesh_v(\"truck.ply\") # Sample random KNN query points in a bounding box 1.1x larger than the object query_pts = np.random.rand(100, 3) * (pts.max(0) - pts.min(0)) * 1.1 - pts.min(0) # quantize points to bins of size 1/128 # NOTE: quantized point coordinates must lie between -1048576 and 1048576 eps = 1.0 / 128.0 pts_quantized = (pts / eps).astype(np.int32) query_pts_quantized = (query_pts / eps).astype(np.int32) # Convert points and query points to morton codes # morton_codes has shape [pts.shape[0],] (one code per point) morton_codes = pcu.morton_encode(pts_quantized) query_codes = pcu.morton_encode(query_pts_quantized) # Number of neighbors per point num_nbrs = 7 # knn_idx is an array of size [query_pts.shape[0], num_nbrs] # where knn_idx is a vector of indices into pts/morton_codes # of the approximate k nearest neighbors (sorted) knn_idx = pcu.morton_knn(morton_codes, query_codes, num_nbrs) Sorting Points Along a Morton Curve Morton codes can be used to impose a sort order on 3D points by first quantizing them and the quantized points in Morton order. import numpy as np import point_cloud_utils as pcu pts = pcu.load_mesh_v(\"truck.ply\") # quantize points to bins of size 1/128 # NOTE: quantized point coordinates must lie between -1048576 and 1048576 eps = 1.0 / 128.0 pts_quantized = (pts / eps).astype(np.int32) # Convert points and query points to morton codes # morton_codes has shape [pts.shape[0],] (one code per point) morton_codes = pcu.morton_encode(pts_quantized) # Permute the points to sort them by their morton code sorted_pts = pts[np.argsort(morton_codes)] Adding and Subtracting Coordinates in Morton Space You can add and subtract Morton encoding of points directly via morton_add and morton_subtract import numpy as np import point_cloud_utils as pcu pts = pcu.load_mesh_v(\"truck.ply\") # Let's generate some random noise and add it to the morton # encoded points offsets = np.random.randn(*pts.shape) * 0.02 # quantize points and offsets to bins of size 1/128 # NOTE: quantized point coordinates must lie between -1048576 and 1048576 eps = 1.0 / 128.0 pts_quantized = (pts / eps).astype(np.int32) offsets_quantized = (offsets / eps).astype(np.int32) # Convert points and query points to morton codes # morton_codes has shape [pts.shape[0],] (one code per point) morton_codes = pcu.morton_encode(pts_quantized) # Convert offset to morton codes offset_codes = pcu.morton_encode(offsets_quantized) # Add noise offsets in Morton space noisy_codes = pcu.morton_add(morton_codes, offset_codes) # Subtract out the noise to recover the original points denoise_codes = pcu.morton_subtract(noisy_codes, offset_codes) assert np.all(denoise_codes == morton_codes)","title":"Morton Encoding/Decoding a Point Cloud"},{"location":"sections/morton_coding/#morton-encodingdecoding-a-point-cloud","text":"Point Cloud Utils has a number of tools for operating on Morton Encoded point clouds. Morton encoding works by projecting points onto a space filling Z-Curve (illustrated below), and recording the distance along this curve from the origin. Z-order curves fill space by repeated subdivision. This image shows one, two and three iterations of z-order subdivision. Morton Encoding point clouds has a number of useful application, such as approximate-k-nearest neighbor search, locality-sensitive point hashing, and point sorting, to name a few. To morton encode a point cloud, you must first convert the point coordinates to integers via quantization. The Point Cloud Utils morton coding utility uses 64 bits and can thus represent points in \\(x \\in [-1048576, 1048576]^3 \\subset \\mathbb{Z}^3\\) .","title":"Morton Encoding/Decoding a Point Cloud"},{"location":"sections/morton_coding/#morton-encoding-and-decoding-points","text":"You can quickly encode/decode points to/from Morton codes by quantizing them to integer coordinates and calling morton_encode / morton_decode . import numpy as np import point_cloud_utils as pcu pts = pcu.load_mesh_v(\"truck.ply\") # quantize points to bins of size 1/128 # NOTE: quantized point coordinates must lie between -1048576 and 1048576 eps = 1.0 / 128.0 pts_quantized = (pts / eps).astype(np.int32) # Convert points to morton codes # morton_codes has shape [pts.shape[0],] (one code per point) morton_codes = pcu.morton_encode(pts_quantized) # Decode morton codes back to integer coordinates pts_decoded = pcu.morton_decode(morton_codes)","title":"Morton Encoding and Decoding Points"},{"location":"sections/morton_coding/#approximate-k-nearest-neighbor-search-with-morton-coding","text":"Finding the nearest points in Morton space to a set of query points is a very fast aproximate KNN algorithm. This can be done via morton_knn : import numpy as np import point_cloud_utils as pcu # Load target point cloud pts = pcu.load_mesh_v(\"truck.ply\") # Sample random KNN query points in a bounding box 1.1x larger than the object query_pts = np.random.rand(100, 3) * (pts.max(0) - pts.min(0)) * 1.1 - pts.min(0) # quantize points to bins of size 1/128 # NOTE: quantized point coordinates must lie between -1048576 and 1048576 eps = 1.0 / 128.0 pts_quantized = (pts / eps).astype(np.int32) query_pts_quantized = (query_pts / eps).astype(np.int32) # Convert points and query points to morton codes # morton_codes has shape [pts.shape[0],] (one code per point) morton_codes = pcu.morton_encode(pts_quantized) query_codes = pcu.morton_encode(query_pts_quantized) # Number of neighbors per point num_nbrs = 7 # knn_idx is an array of size [query_pts.shape[0], num_nbrs] # where knn_idx is a vector of indices into pts/morton_codes # of the approximate k nearest neighbors (sorted) knn_idx = pcu.morton_knn(morton_codes, query_codes, num_nbrs)","title":"Approximate K-Nearest-Neighbor Search with Morton Coding"},{"location":"sections/morton_coding/#sorting-points-along-a-morton-curve","text":"Morton codes can be used to impose a sort order on 3D points by first quantizing them and the quantized points in Morton order. import numpy as np import point_cloud_utils as pcu pts = pcu.load_mesh_v(\"truck.ply\") # quantize points to bins of size 1/128 # NOTE: quantized point coordinates must lie between -1048576 and 1048576 eps = 1.0 / 128.0 pts_quantized = (pts / eps).astype(np.int32) # Convert points and query points to morton codes # morton_codes has shape [pts.shape[0],] (one code per point) morton_codes = pcu.morton_encode(pts_quantized) # Permute the points to sort them by their morton code sorted_pts = pts[np.argsort(morton_codes)]","title":"Sorting Points Along a Morton Curve"},{"location":"sections/morton_coding/#adding-and-subtracting-coordinates-in-morton-space","text":"You can add and subtract Morton encoding of points directly via morton_add and morton_subtract import numpy as np import point_cloud_utils as pcu pts = pcu.load_mesh_v(\"truck.ply\") # Let's generate some random noise and add it to the morton # encoded points offsets = np.random.randn(*pts.shape) * 0.02 # quantize points and offsets to bins of size 1/128 # NOTE: quantized point coordinates must lie between -1048576 and 1048576 eps = 1.0 / 128.0 pts_quantized = (pts / eps).astype(np.int32) offsets_quantized = (offsets / eps).astype(np.int32) # Convert points and query points to morton codes # morton_codes has shape [pts.shape[0],] (one code per point) morton_codes = pcu.morton_encode(pts_quantized) # Convert offset to morton codes offset_codes = pcu.morton_encode(offsets_quantized) # Add noise offsets in Morton space noisy_codes = pcu.morton_add(morton_codes, offset_codes) # Subtract out the noise to recover the original points denoise_codes = pcu.morton_subtract(noisy_codes, offset_codes) assert np.all(denoise_codes == morton_codes)","title":"Adding and Subtracting Coordinates in Morton Space"},{"location":"sections/point_cloud_normal_estimation/","text":"Estimating Normals for a Point Cloud Point clouds aqcuired from 3D sensors often do not come equipped with surface normals. Sensors can, however, always provide a direction vector pointing from a scanned point to origin of the scanner. Point-Cloud-Utils can estimate normals for 3D point clouds, and orient these normals when the user provides sensor direction vectors. The method fits a plane in the neigbhorhood of each point using principle component analysis , and assigns the fitted plane normal to the point. If sensor directions are provided, the normal is flipped to have the same orientation as the sensor direction. 2D Sketch of normal estimation. We fit the purple plane using PCA to the red points. The center point is assigned the normal of the fitted plane. If (gray-dotted) sensor-directions are passed in, we orient the normal to point towards the sensor. Sensor directions are optional You don't have to pass in sensor directions but then the normals will not be consistently oriented. You should usually be able to get sensor directions from point cloud scans. Estimating Normals using k-Nearest-Neighbors The following code uses the k-nearest neighbors to a point to contruct a local neighborhood for fitting a plane. import point_cloud_utils as pcu # sensor_dirs are stored in the normal channel and are encoded as unit # vectors pointing from the point to the scanner pts, sensor_dirs = pcu.load_mesh_vf(\"point_with_sensor_dirs.ply\") # Optionally delete point whose normal is at an oblique (greather than 85 degree) angle with the sensor direction drop_angle = np.deg2rad(85.0) # Size of the neighborhood used for each point num_nbrs = 32 # n are the fitted normals # n_idx are used to delete points which were filterd (ignore this if you don't pass in drop_angle) _, n = pcu.estimate_normals_knn(pts, num_nbrs, view_dirs=sensor_dirs) Left: Input point cloud with directions to sensors (pink arrows). Right: Predicted normals for point cloud (green arrows) using fitted planes to k-nearest neighbors. Filterting out points with oblique angles to the sensor You can optionally filter out points whose predicted normal angle is close to 90 degrees to the sensor direction. This can prevent certain types of noise when reconstructing a surface from oriented points. import point_cloud_utils as pcu # sensor_dirs are stored in the normal channel and are encoded as unit # vectors pointing from the point to the scanner pts, sensor_dirs = pcu.load_mesh_vf(\"point_with_sensor_dirs.ply\") # Optionally delete point whose normal is at an oblique (greather than 85 degree) angle with the sensor direction drop_angle = np.deg2rad(85.0) # Size of the neighborhood used for each point num_nbrs = 32 # n are the fitted normals # n_idx are used to delete points which were filterd (ignore this if you don't pass in drop_angle) n_idx, n = pcu.estimate_normals_knn(pts, num_nbrs, view_dirs=sensor_dirs, drop_angle_threshold=drop_angle) # Only include points which were not dropped pts_n = pts[n_idx] Estimating Normals using a Radius The following code uses neighbors within a ball around a point to contruct a local neighborhood for fitting a plane. import point_cloud_utils as pcu # sensor_dirs are stored in the normal channel and are encoded as unit # vectors pointing from the point to the scanner pts, sensor_dirs = pcu.load_mesh_vf(\"point_with_sensor_dirs.ply\") # Optionally delete point whose normal is at an oblique (greather than 85 degree) angle with the sensor direction drop_angle = np.deg2rad(85.0) # Size of the neighborhood used for each point ball_radius = 0.015 # n are the fitted normals _, n = pcu.estimate_normals_knn(pts, ball_radius, view_dirs=sensor_dirs) Left: Input point cloud with directions to sensors (pink arrows). Right: Predicted normals for point cloud (green arrows) using planes fitted inside a ball neighborhood. Filterting out points with oblique angles to the sensor You can optionally filter out points whose predicted normal angle is close to 90 degrees to the sensor direction. This can prevent certain types of noise when reconstructing a surface from oriented points. import point_cloud_utils as pcu # sensor_dirs are stored in the normal channel and are encoded as unit # vectors pointing from the point to the scanner pts, sensor_dirs = pcu.load_mesh_vf(\"point_with_sensor_dirs.ply\") # Optionally delete point whose normal is at an oblique (greather than 85 degree) angle with the sensor direction drop_angle = np.deg2rad(85.0) # Size of the neighborhood used for each point ball_radius = 0.015 # n are the fitted normals # n_idx are used to delete points which were filterd (ignore this if you don't pass in drop_angle) n_idx, n = pcu.estimate_normals_ball(pts, ball_radius, view_dirs=sensor_dirs, drop_angle_threshold=drop_angle) # Only include points which were not dropped pts_n = pts[n_idx]","title":"Estimating Normals for Point Clouds"},{"location":"sections/point_cloud_normal_estimation/#estimating-normals-for-a-point-cloud","text":"Point clouds aqcuired from 3D sensors often do not come equipped with surface normals. Sensors can, however, always provide a direction vector pointing from a scanned point to origin of the scanner. Point-Cloud-Utils can estimate normals for 3D point clouds, and orient these normals when the user provides sensor direction vectors. The method fits a plane in the neigbhorhood of each point using principle component analysis , and assigns the fitted plane normal to the point. If sensor directions are provided, the normal is flipped to have the same orientation as the sensor direction. 2D Sketch of normal estimation. We fit the purple plane using PCA to the red points. The center point is assigned the normal of the fitted plane. If (gray-dotted) sensor-directions are passed in, we orient the normal to point towards the sensor. Sensor directions are optional You don't have to pass in sensor directions but then the normals will not be consistently oriented. You should usually be able to get sensor directions from point cloud scans.","title":"Estimating Normals for a Point Cloud"},{"location":"sections/point_cloud_normal_estimation/#estimating-normals-using-k-nearest-neighbors","text":"The following code uses the k-nearest neighbors to a point to contruct a local neighborhood for fitting a plane. import point_cloud_utils as pcu # sensor_dirs are stored in the normal channel and are encoded as unit # vectors pointing from the point to the scanner pts, sensor_dirs = pcu.load_mesh_vf(\"point_with_sensor_dirs.ply\") # Optionally delete point whose normal is at an oblique (greather than 85 degree) angle with the sensor direction drop_angle = np.deg2rad(85.0) # Size of the neighborhood used for each point num_nbrs = 32 # n are the fitted normals # n_idx are used to delete points which were filterd (ignore this if you don't pass in drop_angle) _, n = pcu.estimate_normals_knn(pts, num_nbrs, view_dirs=sensor_dirs) Left: Input point cloud with directions to sensors (pink arrows). Right: Predicted normals for point cloud (green arrows) using fitted planes to k-nearest neighbors.","title":"Estimating Normals using k-Nearest-Neighbors"},{"location":"sections/point_cloud_normal_estimation/#filterting-out-points-with-oblique-angles-to-the-sensor","text":"You can optionally filter out points whose predicted normal angle is close to 90 degrees to the sensor direction. This can prevent certain types of noise when reconstructing a surface from oriented points. import point_cloud_utils as pcu # sensor_dirs are stored in the normal channel and are encoded as unit # vectors pointing from the point to the scanner pts, sensor_dirs = pcu.load_mesh_vf(\"point_with_sensor_dirs.ply\") # Optionally delete point whose normal is at an oblique (greather than 85 degree) angle with the sensor direction drop_angle = np.deg2rad(85.0) # Size of the neighborhood used for each point num_nbrs = 32 # n are the fitted normals # n_idx are used to delete points which were filterd (ignore this if you don't pass in drop_angle) n_idx, n = pcu.estimate_normals_knn(pts, num_nbrs, view_dirs=sensor_dirs, drop_angle_threshold=drop_angle) # Only include points which were not dropped pts_n = pts[n_idx]","title":"Filterting out points with oblique angles to the sensor"},{"location":"sections/point_cloud_normal_estimation/#estimating-normals-using-a-radius","text":"The following code uses neighbors within a ball around a point to contruct a local neighborhood for fitting a plane. import point_cloud_utils as pcu # sensor_dirs are stored in the normal channel and are encoded as unit # vectors pointing from the point to the scanner pts, sensor_dirs = pcu.load_mesh_vf(\"point_with_sensor_dirs.ply\") # Optionally delete point whose normal is at an oblique (greather than 85 degree) angle with the sensor direction drop_angle = np.deg2rad(85.0) # Size of the neighborhood used for each point ball_radius = 0.015 # n are the fitted normals _, n = pcu.estimate_normals_knn(pts, ball_radius, view_dirs=sensor_dirs) Left: Input point cloud with directions to sensors (pink arrows). Right: Predicted normals for point cloud (green arrows) using planes fitted inside a ball neighborhood.","title":"Estimating Normals using a Radius"},{"location":"sections/point_cloud_normal_estimation/#filterting-out-points-with-oblique-angles-to-the-sensor_1","text":"You can optionally filter out points whose predicted normal angle is close to 90 degrees to the sensor direction. This can prevent certain types of noise when reconstructing a surface from oriented points. import point_cloud_utils as pcu # sensor_dirs are stored in the normal channel and are encoded as unit # vectors pointing from the point to the scanner pts, sensor_dirs = pcu.load_mesh_vf(\"point_with_sensor_dirs.ply\") # Optionally delete point whose normal is at an oblique (greather than 85 degree) angle with the sensor direction drop_angle = np.deg2rad(85.0) # Size of the neighborhood used for each point ball_radius = 0.015 # n are the fitted normals # n_idx are used to delete points which were filterd (ignore this if you don't pass in drop_angle) n_idx, n = pcu.estimate_normals_ball(pts, ball_radius, view_dirs=sensor_dirs, drop_angle_threshold=drop_angle) # Only include points which were not dropped pts_n = pts[n_idx]","title":"Filterting out points with oblique angles to the sensor"},{"location":"sections/point_cloud_resampling/","text":"Resampling Point Clouds Point Cloud Utils provides tools for re-sampling a point cloud in several ways. Data in examples In all the examples, below we first load the point cloud here Binning points in a voxel grid In many 3D tasks, it is often advantageous to quantize a point cloud to a regular voxel grid in space. Such quantization can reduce the number of input points to an algorithm to match the resolution at which that algorithm operates. Point Cloud Utils provides a simple function for quantizing a point cloud with arbitrary attributes into a voxel grid. Attributes are averaged within a voxel. The code below shows an example of this functionality with the figure showing the result. import point_cloud_utils as pcu # v is a [n, 3] shaped NumPy array of vertices # n is a [n, 3] NumPy array of vertex normals p, n = pcu.load_mesh_vnc(\"wheel.ply\") # We'll quantize our point cloud to a voxel grid with 128 voxels per axis num_voxels_per_axis = 128 # Size of the axis aligned bounding box of the point cloud bbox_size = p.max(0) - p.min(0) # The size per-axis of a single voxel sizeof_voxel = bbox_size / num_voxels_per_axis # Downsample a point cloud on a voxel grid so there is at most one point per voxel. # Any arguments after the points are treated as attribute arrays and get averaged within each voxel v_sampled, n_sampled = pcu.downsample_point_cloud_on_voxel_grid(sizeof_voxel, p, n) Downsampling the blue point cloud by averaging points within each voxel. The yellow points are the downsampled points. The right image shows the downsampled normals. Downsampling a point cloud to have a blue noise distribution If we have a dense point cloud, we may want to downsample it to sparse point cloud where all points are about evenly spaced apart. Such a distribution of points is called a \"blue noise\" distribution. Formally, this means that the expected distance between points on the surface is some constant. i.e. for a point cloud \\(P\\) : $$ \\mathbb{E}_{x \\in P} ||x - \\text{nearest_neighbor}(x)|| = \\epsilon $$ This can be achieved with Poisson Disk Sampling. Point cloud utils supports downsampling a point cloud to a target radius or to a target number of points Downsampling a points to a blue noise distribution with a target number of points import point_cloud_utils as pcu import numpy as np # v is a [n, 3] shaped NumPy array of vertices # n is a [n, 3] NumPy array of vertex normals p, n = pcu.load_mesh_vn(\"wheel.ply\") ### Option 1: ### Downsampling a points to a blue noise distribution with a target number of points # idx is an array of integer indices into v indicating which samples to keep target_num_pts= int(0.1*p.shape[0]) # 10% of the number of input points idx = pcu.downsample_point_cloud_poisson_disk(p, num_samples=target_num_pts) ### Option 2: ### Downsampling a points to a blue noise distribution with a target radius # idx is an array of integer indices into v indicating which samples to keep target_radius = np.linalg.norm(p.max(0) - p.min(0)) * 0.02 # 2% of the bounding box radius idx = pcu.downsample_point_cloud_poisson_disk(p, -1, radius=target_radius) # Use the indices to get the sample positions and normals v_sampled = p[idx] n_sampled = n[idx] Downsampling the blue point cloud according to a blue noise distribution so that the resulting points (yellow) are approximately evenly spaced Deduplicating a point cloud You can deduplicate a point cloud by removing vertices that are equal up to some threshold. The example below removes duplicate points with a threshold of \\(10^{-1}\\) import point_cloud_utils as pcu # p is a (n, 3)-shaped array of points (one per row) # p is a (n, 3)-shaped array of normals at each point p, n = pcu.load_mesh_vn(\"my_pcloud.ply\") # Treat any points closer than 1e-7 apart as the same point # idx_i is an array of indices such that p_dedup = p[idx_i] # idx_j is an array of indices such that p = p_dedup[idx_j] p_dedup, idx_i, idx_j = pcu.deduplicate_point_cloud(p, 1e-7) # Use idx_i to deduplicate the normals n_dedup = n[idx_i]","title":"Resampling Point Clouds"},{"location":"sections/point_cloud_resampling/#resampling-point-clouds","text":"Point Cloud Utils provides tools for re-sampling a point cloud in several ways. Data in examples In all the examples, below we first load the point cloud here","title":"Resampling Point Clouds"},{"location":"sections/point_cloud_resampling/#binning-points-in-a-voxel-grid","text":"In many 3D tasks, it is often advantageous to quantize a point cloud to a regular voxel grid in space. Such quantization can reduce the number of input points to an algorithm to match the resolution at which that algorithm operates. Point Cloud Utils provides a simple function for quantizing a point cloud with arbitrary attributes into a voxel grid. Attributes are averaged within a voxel. The code below shows an example of this functionality with the figure showing the result. import point_cloud_utils as pcu # v is a [n, 3] shaped NumPy array of vertices # n is a [n, 3] NumPy array of vertex normals p, n = pcu.load_mesh_vnc(\"wheel.ply\") # We'll quantize our point cloud to a voxel grid with 128 voxels per axis num_voxels_per_axis = 128 # Size of the axis aligned bounding box of the point cloud bbox_size = p.max(0) - p.min(0) # The size per-axis of a single voxel sizeof_voxel = bbox_size / num_voxels_per_axis # Downsample a point cloud on a voxel grid so there is at most one point per voxel. # Any arguments after the points are treated as attribute arrays and get averaged within each voxel v_sampled, n_sampled = pcu.downsample_point_cloud_on_voxel_grid(sizeof_voxel, p, n) Downsampling the blue point cloud by averaging points within each voxel. The yellow points are the downsampled points. The right image shows the downsampled normals.","title":"Binning points in a voxel grid"},{"location":"sections/point_cloud_resampling/#downsampling-a-point-cloud-to-have-a-blue-noise-distribution","text":"If we have a dense point cloud, we may want to downsample it to sparse point cloud where all points are about evenly spaced apart. Such a distribution of points is called a \"blue noise\" distribution. Formally, this means that the expected distance between points on the surface is some constant. i.e. for a point cloud \\(P\\) : $$ \\mathbb{E}_{x \\in P} ||x - \\text{nearest_neighbor}(x)|| = \\epsilon $$ This can be achieved with Poisson Disk Sampling. Point cloud utils supports downsampling a point cloud to a target radius or to a target number of points Downsampling a points to a blue noise distribution with a target number of points import point_cloud_utils as pcu import numpy as np # v is a [n, 3] shaped NumPy array of vertices # n is a [n, 3] NumPy array of vertex normals p, n = pcu.load_mesh_vn(\"wheel.ply\") ### Option 1: ### Downsampling a points to a blue noise distribution with a target number of points # idx is an array of integer indices into v indicating which samples to keep target_num_pts= int(0.1*p.shape[0]) # 10% of the number of input points idx = pcu.downsample_point_cloud_poisson_disk(p, num_samples=target_num_pts) ### Option 2: ### Downsampling a points to a blue noise distribution with a target radius # idx is an array of integer indices into v indicating which samples to keep target_radius = np.linalg.norm(p.max(0) - p.min(0)) * 0.02 # 2% of the bounding box radius idx = pcu.downsample_point_cloud_poisson_disk(p, -1, radius=target_radius) # Use the indices to get the sample positions and normals v_sampled = p[idx] n_sampled = n[idx] Downsampling the blue point cloud according to a blue noise distribution so that the resulting points (yellow) are approximately evenly spaced","title":"Downsampling a point cloud to have a blue noise distribution"},{"location":"sections/point_cloud_resampling/#deduplicating-a-point-cloud","text":"You can deduplicate a point cloud by removing vertices that are equal up to some threshold. The example below removes duplicate points with a threshold of \\(10^{-1}\\) import point_cloud_utils as pcu # p is a (n, 3)-shaped array of points (one per row) # p is a (n, 3)-shaped array of normals at each point p, n = pcu.load_mesh_vn(\"my_pcloud.ply\") # Treat any points closer than 1e-7 apart as the same point # idx_i is an array of indices such that p_dedup = p[idx_i] # idx_j is an array of indices such that p = p_dedup[idx_j] p_dedup, idx_i, idx_j = pcu.deduplicate_point_cloud(p, 1e-7) # Use idx_i to deduplicate the normals n_dedup = n[idx_i]","title":"Deduplicating a point cloud"},{"location":"sections/ray_mesh_intersection/","text":"Ray Mesh Intersection Point-Cloud-Utils supports fast ray-mesh intersection using Intel Embree . There are two ways of performing ray-mesh queries. For one-off queries, use the functional interface, and for repeated queries on a mesh, use RayMeshIntersector One-off Ray-Mesh Queries using the Functional Interface You can call ray_mesh_intersection to compute the intersection between a collection of rays and a triangle mesh: import point_cloud_utils as pcu import numpy as np v, f = pcu.load_mesh_vf(\"bunny.ply\") # Generate a raster grid of Rays looking down the +Z axis x, y = np.mgrid[-0.5:0.5:32j, -0.5:0.5:32j] ray_d = np.stack([x.flatten(), y.flatten(), np.ones_like(x.flatten())], axis=-1) ray_d /= np.linalg.norm(ray_d, axis=-1, keepdims=True) # Normalize ray directions -- shape [N, 3] # Rays originating at -Z looking down the Z-axis ray_o = np.array([0.0, 0.15, -0.75]) ray_o = np.repeat(ray_o[None, :], ray_d.shape[0], axis=0) # Repeat the ray origin so there is one per ray -- shape [N, 3] fid, bc, t = pcu.ray_mesh_intersection(v.astype(ray_o.dtype), f, ray_o, ray_d) # True only at the rays which intersected the shape hit_mask = fid >= 0 ray_intersections = pcu.pcu.interpolate_barycentric_coords(f, fid[hit_mask], bc[hit_mask], v) Computing one-off ray-mesh intersection queries. Repeated Ray-Mesh Queries using RayMeshIntersector You can call ray_mesh_intersection to compute the intersection between a collection of rays and a triangle mesh: import point_cloud_utils as pcu import numpy as np v, f = pcu.load_mesh_vf(\"bunny.ply\") # Generate a raster grid of Rays looking down the +Z axis x, y = np.mgrid[-0.5:0.5:32j, -0.5:0.5:32j] ray_d = np.stack([x.flatten(), y.flatten(), np.ones_like(x.flatten())], axis=-1) ray_d /= np.linalg.norm(ray_d, axis=-1, keepdims=True) # Normalize ray directions -- shape [N, 3] # Rays originating at -Z looking down the Z-axis ray_o = np.array([0.0, 0.15, -0.75]) ray_o = np.repeat(ray_o[None, :], ray_d.shape[0], axis=0) # Repeat the ray origin so there is one per ray -- shape [N, 3] # Generate new rays via a random rotation random_rotation = np.linalg.svd(np.random.randn(3, 3))[0] ray_o2 = np.ascontiguousarray((random_rotation @ ray_o.T).T) ray_d2 = np.ascontiguousarray((random_rotation @ ray_d.T).T) intersector = pcu.RayMeshIntersector(v, f) # Intersect first batch of rays fid, bc, t = intersector.intersect_rays(ray_o, ray_d) hit_mask = fid >= 0 # True only at the rays which intersected the shape ray_intersections = pcu.interpolate_barycentric_coords(f, fid[hit_mask], bc[hit_mask], v) # Intersect second batch of rays fid2, bc2, t2 = intersector.intersect_rays(ray_o2, ray_d2) hit_mask2 = fid >= 0 # True only at the rays which intersected the shape ray_intersections2 = pcu.interpolate_barycentric_coords(f, fid2[hit_mask2], bc2[hit_mask2], v) Computing repeated ray-mesh intersections using `RayMeshIntersector`. Each seperate batch of rays is colored differently. Representing mesh-surface samples in Point Cloud Utils Point Cloud Utils returns samples on the surface of a mesh using Barycentric Coordinates . i.e. each sample is encoded as: The index of the mesh face containing it (usually referred to as fid ) The barycentric coordinates of the point within that face (usually referred to as bc ) Encoding surface samples as barycentric coordinates. The teal point is the barycentric combination with weights \\((\\alpha, \\beta, \\gamma)\\) in face 3. The reason for encoding points in this way is that it allows us to interpolate any quantity stored at the vertices (including their positions) of a mesh to the sample positions, and thus sample vertex attributes. To recover vertex quantities from fid , bc pairs use the function pcu.interpolate_barycentric_coords(f, fid, bc, vertex_quantity)","title":"Ray/Mesh Intersection"},{"location":"sections/ray_mesh_intersection/#ray-mesh-intersection","text":"Point-Cloud-Utils supports fast ray-mesh intersection using Intel Embree . There are two ways of performing ray-mesh queries. For one-off queries, use the functional interface, and for repeated queries on a mesh, use RayMeshIntersector","title":"Ray Mesh Intersection"},{"location":"sections/ray_mesh_intersection/#one-off-ray-mesh-queries-using-the-functional-interface","text":"You can call ray_mesh_intersection to compute the intersection between a collection of rays and a triangle mesh: import point_cloud_utils as pcu import numpy as np v, f = pcu.load_mesh_vf(\"bunny.ply\") # Generate a raster grid of Rays looking down the +Z axis x, y = np.mgrid[-0.5:0.5:32j, -0.5:0.5:32j] ray_d = np.stack([x.flatten(), y.flatten(), np.ones_like(x.flatten())], axis=-1) ray_d /= np.linalg.norm(ray_d, axis=-1, keepdims=True) # Normalize ray directions -- shape [N, 3] # Rays originating at -Z looking down the Z-axis ray_o = np.array([0.0, 0.15, -0.75]) ray_o = np.repeat(ray_o[None, :], ray_d.shape[0], axis=0) # Repeat the ray origin so there is one per ray -- shape [N, 3] fid, bc, t = pcu.ray_mesh_intersection(v.astype(ray_o.dtype), f, ray_o, ray_d) # True only at the rays which intersected the shape hit_mask = fid >= 0 ray_intersections = pcu.pcu.interpolate_barycentric_coords(f, fid[hit_mask], bc[hit_mask], v) Computing one-off ray-mesh intersection queries.","title":"One-off Ray-Mesh Queries using the Functional Interface"},{"location":"sections/ray_mesh_intersection/#repeated-ray-mesh-queries-using-raymeshintersector","text":"You can call ray_mesh_intersection to compute the intersection between a collection of rays and a triangle mesh: import point_cloud_utils as pcu import numpy as np v, f = pcu.load_mesh_vf(\"bunny.ply\") # Generate a raster grid of Rays looking down the +Z axis x, y = np.mgrid[-0.5:0.5:32j, -0.5:0.5:32j] ray_d = np.stack([x.flatten(), y.flatten(), np.ones_like(x.flatten())], axis=-1) ray_d /= np.linalg.norm(ray_d, axis=-1, keepdims=True) # Normalize ray directions -- shape [N, 3] # Rays originating at -Z looking down the Z-axis ray_o = np.array([0.0, 0.15, -0.75]) ray_o = np.repeat(ray_o[None, :], ray_d.shape[0], axis=0) # Repeat the ray origin so there is one per ray -- shape [N, 3] # Generate new rays via a random rotation random_rotation = np.linalg.svd(np.random.randn(3, 3))[0] ray_o2 = np.ascontiguousarray((random_rotation @ ray_o.T).T) ray_d2 = np.ascontiguousarray((random_rotation @ ray_d.T).T) intersector = pcu.RayMeshIntersector(v, f) # Intersect first batch of rays fid, bc, t = intersector.intersect_rays(ray_o, ray_d) hit_mask = fid >= 0 # True only at the rays which intersected the shape ray_intersections = pcu.interpolate_barycentric_coords(f, fid[hit_mask], bc[hit_mask], v) # Intersect second batch of rays fid2, bc2, t2 = intersector.intersect_rays(ray_o2, ray_d2) hit_mask2 = fid >= 0 # True only at the rays which intersected the shape ray_intersections2 = pcu.interpolate_barycentric_coords(f, fid2[hit_mask2], bc2[hit_mask2], v) Computing repeated ray-mesh intersections using `RayMeshIntersector`. Each seperate batch of rays is colored differently. Representing mesh-surface samples in Point Cloud Utils Point Cloud Utils returns samples on the surface of a mesh using Barycentric Coordinates . i.e. each sample is encoded as: The index of the mesh face containing it (usually referred to as fid ) The barycentric coordinates of the point within that face (usually referred to as bc ) Encoding surface samples as barycentric coordinates. The teal point is the barycentric combination with weights \\((\\alpha, \\beta, \\gamma)\\) in face 3. The reason for encoding points in this way is that it allows us to interpolate any quantity stored at the vertices (including their positions) of a mesh to the sample positions, and thus sample vertex attributes. To recover vertex quantities from fid , bc pairs use the function pcu.interpolate_barycentric_coords(f, fid, bc, vertex_quantity)","title":"Repeated Ray-Mesh Queries using RayMeshIntersector"},{"location":"sections/removing_unreferenced_mesh_vertices/","text":"Removing Unreferenced Mesh Vertices","title":"Removing Unreferenced Mesh Vertices"},{"location":"sections/removing_unreferenced_mesh_vertices/#removing-unreferenced-mesh-vertices","text":"","title":"Removing Unreferenced Mesh Vertices"},{"location":"sections/shape_metrics/","text":"Point Cloud Metrics Point Cloud Utils has functions to compute a number of commonly used metrics between point clouds. Chamfer Distance The Chamfer distance between two point clouds \\(P_1 = \\{x_i \\in \\mathbb{R}^3\\}_{i=1}^n\\) and \\(P_2 = \\{x_j \\in \\mathbb{R}^3\\}_{j=1}^m\\) is defined as the average distance between pairs of nearest neighbors between \\(P_1\\) and \\(P_2\\) i.e. $$ \\text{chamfer}(P_1, P_2) = \\frac{1}{2n} \\sum_{i=1}^n |x_i - \\text{NN}(x_i, P_2)| + \\frac{1}{2m} \\sum_{j=1}^n |x_j - \\text{NN}(x_j, P_1)| $$ and \\(\\text{NN}(x, P) = \\text{argmin}_{x' \\in P} \\|x - x'\\|\\) is the nearest neighbor function. The following code computes the Chamfer distance between two point clouds: import point_cloud_utils as pcu # p1 is an (n, 3)-shaped numpy array containing one point per row p1 = pcu.load_mesh_v(\"point_cloud_1.ply\") # p2 is an (m, 3)-shaped numpy array containing one point per row p2 = pcu.load_mesh_v(\"point_cloud_2.ply\") # Compute the chamfer distance between p1 and p2 cd = pcu.chamfer_distance(p1, p2) Hausdorff distance The Hausdorff distance between two point clouds \\(P_1 = \\{x_i \\in \\mathbb{R}^3\\}_{i=1}^n\\) and \\(P_2 = \\{x_j \\in \\mathbb{R}^3\\}_{j=1}^m\\) is defined as the maxmimum distance between any pair of nearest neighbors between \\(P_1\\) and \\(P_2\\) i.e. $$ \\text{hausdorff}(P_1, P_2) = \\frac{1}{2} \\max_{x \\in P_1} |x - \\text{NN}(x, P_2)| + \\frac{1}{2} \\max_{x' \\in P_2} |x' - \\text{NN}(x', P_1)| $$ and \\(\\text{NN}(x, P) = \\text{argmin}_{x' \\in P} \\|x - x'\\|\\) is the nearest neighbor function. The following code computes the Hausdorff distance between two point clouds: import point_cloud_utils as pcu # p1 is an (n, 3)-shaped numpy array containing one point per row p1 = pcu.load_mesh_v(\"point_cloud_1.ply\") # p2 is an (m, 3)-shaped numpy array containing one point per row p2 = pcu.load_mesh_v(\"point_cloud_2.ply\") # Compute the chamfer distance between p1 and p2 hd = pcu.hausdorff_distance(p1, p2) One sided Hausdorff distance In some applications, one only needs the one-sided Hausdorff distance between \\(P_1\\) and \\(P_2\\) , i.e. \\[ \\text{hausdorff}_{P_1 \\rightarrow P_2}(P_1, P_2) = \\max_{x \\in P_1} \\|x - \\text{NN}(x, P_2)\\| \\] The following code computes the one-sided Hausdorff distance between two point clouds: import point_cloud_utils as pcu # p1 is an (n, 3)-shaped numpy array containing one point per row p1 = pcu.load_mesh_v(\"point_cloud_1.ply\") # p2 is an (m, 3)-shaped numpy array containing one point per row p2 = pcu.load_mesh_v(\"point_cloud_2.ply\") # Compute the chamfer distance between p1 and p2 hd_p1_to_p2 = pcu.one_sided_hausdorff_distance(p1, p2) Note To get the \\(P_2 \\rightarrow P_1\\) Hausdorff distance, just swap the arguments to pcu.one_sided_hausdorff_distance Earth-Mover's (Sinkhorn) distance The Earth Mover's distance between two point clouds \\(P = \\{p_i \\in \\mathbb{R}^3\\}_{i=1}^n\\) and \\(Q = \\{q_j \\in \\mathbb{R}^3\\}_{j=1}^m\\) is computed as the average distance between pairs of points according to an optimal correspondence \\(\\pi \\in \\Pi(P, Q)\\) , where \\(\\Pi(P, Q)\\) is the set of \\(n \\times m\\) matrices where the rows and columns sum to one. The assignment \\(\\pi\\) is thus a matrix where \\(\\Pi_{i,j}\\) is a number between \\(0\\) and \\(1\\) denoting how much point \\(p_i\\) and \\(q_j\\) correspond. We can write the EMD formally as: $$ \\text{EMD}(P, Q) = \\min_{\\pi \\in \\Pi(P, Q)} \\sum_{i = 1}^n \\sum_{j = 1}^m \\pi_{i,j} |p_i - q_j| % \\langle \\pi, D \\rangle \\qquad D_{ij} = |p_i - q_j| $$ Point Cloud Utils implements the sinkhorn algorithm for computing the (approximate) Earth Mover's Distance. To compute the EMD, run: import point_cloud_utils as pcu # p1 is an (n, 3)-shaped numpy array containing one point per row p1 = pcu.load_mesh_v(\"point_cloud_1.ply\") # p2 is an (m, 3)-shaped numpy array containing one point per row p2 = pcu.load_mesh_v(\"point_cloud_2.ply\") # Compute the chamfer distance between p1 and p2 emd, pi = pcu.earth_movers_distance(p1, p2)","title":"Point Cloud Metrics"},{"location":"sections/shape_metrics/#point-cloud-metrics","text":"Point Cloud Utils has functions to compute a number of commonly used metrics between point clouds.","title":"Point Cloud Metrics"},{"location":"sections/shape_metrics/#chamfer-distance","text":"The Chamfer distance between two point clouds \\(P_1 = \\{x_i \\in \\mathbb{R}^3\\}_{i=1}^n\\) and \\(P_2 = \\{x_j \\in \\mathbb{R}^3\\}_{j=1}^m\\) is defined as the average distance between pairs of nearest neighbors between \\(P_1\\) and \\(P_2\\) i.e. $$ \\text{chamfer}(P_1, P_2) = \\frac{1}{2n} \\sum_{i=1}^n |x_i - \\text{NN}(x_i, P_2)| + \\frac{1}{2m} \\sum_{j=1}^n |x_j - \\text{NN}(x_j, P_1)| $$ and \\(\\text{NN}(x, P) = \\text{argmin}_{x' \\in P} \\|x - x'\\|\\) is the nearest neighbor function. The following code computes the Chamfer distance between two point clouds: import point_cloud_utils as pcu # p1 is an (n, 3)-shaped numpy array containing one point per row p1 = pcu.load_mesh_v(\"point_cloud_1.ply\") # p2 is an (m, 3)-shaped numpy array containing one point per row p2 = pcu.load_mesh_v(\"point_cloud_2.ply\") # Compute the chamfer distance between p1 and p2 cd = pcu.chamfer_distance(p1, p2)","title":"Chamfer Distance"},{"location":"sections/shape_metrics/#hausdorff-distance","text":"The Hausdorff distance between two point clouds \\(P_1 = \\{x_i \\in \\mathbb{R}^3\\}_{i=1}^n\\) and \\(P_2 = \\{x_j \\in \\mathbb{R}^3\\}_{j=1}^m\\) is defined as the maxmimum distance between any pair of nearest neighbors between \\(P_1\\) and \\(P_2\\) i.e. $$ \\text{hausdorff}(P_1, P_2) = \\frac{1}{2} \\max_{x \\in P_1} |x - \\text{NN}(x, P_2)| + \\frac{1}{2} \\max_{x' \\in P_2} |x' - \\text{NN}(x', P_1)| $$ and \\(\\text{NN}(x, P) = \\text{argmin}_{x' \\in P} \\|x - x'\\|\\) is the nearest neighbor function. The following code computes the Hausdorff distance between two point clouds: import point_cloud_utils as pcu # p1 is an (n, 3)-shaped numpy array containing one point per row p1 = pcu.load_mesh_v(\"point_cloud_1.ply\") # p2 is an (m, 3)-shaped numpy array containing one point per row p2 = pcu.load_mesh_v(\"point_cloud_2.ply\") # Compute the chamfer distance between p1 and p2 hd = pcu.hausdorff_distance(p1, p2)","title":"Hausdorff distance"},{"location":"sections/shape_metrics/#one-sided-hausdorff-distance","text":"In some applications, one only needs the one-sided Hausdorff distance between \\(P_1\\) and \\(P_2\\) , i.e. \\[ \\text{hausdorff}_{P_1 \\rightarrow P_2}(P_1, P_2) = \\max_{x \\in P_1} \\|x - \\text{NN}(x, P_2)\\| \\] The following code computes the one-sided Hausdorff distance between two point clouds: import point_cloud_utils as pcu # p1 is an (n, 3)-shaped numpy array containing one point per row p1 = pcu.load_mesh_v(\"point_cloud_1.ply\") # p2 is an (m, 3)-shaped numpy array containing one point per row p2 = pcu.load_mesh_v(\"point_cloud_2.ply\") # Compute the chamfer distance between p1 and p2 hd_p1_to_p2 = pcu.one_sided_hausdorff_distance(p1, p2) Note To get the \\(P_2 \\rightarrow P_1\\) Hausdorff distance, just swap the arguments to pcu.one_sided_hausdorff_distance","title":"One sided Hausdorff distance"},{"location":"sections/shape_metrics/#earth-movers-sinkhorn-distance","text":"The Earth Mover's distance between two point clouds \\(P = \\{p_i \\in \\mathbb{R}^3\\}_{i=1}^n\\) and \\(Q = \\{q_j \\in \\mathbb{R}^3\\}_{j=1}^m\\) is computed as the average distance between pairs of points according to an optimal correspondence \\(\\pi \\in \\Pi(P, Q)\\) , where \\(\\Pi(P, Q)\\) is the set of \\(n \\times m\\) matrices where the rows and columns sum to one. The assignment \\(\\pi\\) is thus a matrix where \\(\\Pi_{i,j}\\) is a number between \\(0\\) and \\(1\\) denoting how much point \\(p_i\\) and \\(q_j\\) correspond. We can write the EMD formally as: $$ \\text{EMD}(P, Q) = \\min_{\\pi \\in \\Pi(P, Q)} \\sum_{i = 1}^n \\sum_{j = 1}^m \\pi_{i,j} |p_i - q_j| % \\langle \\pi, D \\rangle \\qquad D_{ij} = |p_i - q_j| $$ Point Cloud Utils implements the sinkhorn algorithm for computing the (approximate) Earth Mover's Distance. To compute the EMD, run: import point_cloud_utils as pcu # p1 is an (n, 3)-shaped numpy array containing one point per row p1 = pcu.load_mesh_v(\"point_cloud_1.ply\") # p2 is an (m, 3)-shaped numpy array containing one point per row p2 = pcu.load_mesh_v(\"point_cloud_2.ply\") # Compute the chamfer distance between p1 and p2 emd, pi = pcu.earth_movers_distance(p1, p2)","title":"Earth-Mover's (Sinkhorn) distance"},{"location":"sections/surfels/","text":"Generating Surfels from Point Clouds A Surfel or SURF ace EL ement is a small, flat piece of geometry centered at a point and facing perpendicularly to that points normal. With dense enough points, surfels can be used as a surface representation. The figure below illustrates a surfel representation for a model. Surfel representation for the wheel model. In the zoom, note how the surface is a collection of tiny circular patches. Generating Surfel Geometry from an Oriented Point Cloud Point Cloud Utils lets you easily generate surfel geometry from a point cloud import numpy as np import point_cloud_utils as pcu # Load points and normals p, n = pcu.load_mesh_vn(\"wheel.ply\") # Constant surfel radius of 0.33 per point surfel_rad = np.ones(p.shape[0], dtype=p.dtype) * 0.33 # A triangle mesh representing surfel geometry v, f = pcu.pointcloud_surfel_geometry(p, n, surfel_rad) Ray Tracing Surfels Point Cloud Utils lets you perform fast ray-surfel queries using intel Embree. The API is very similar to the Ray-Mesh Intersection API . There is a functional interface for one-off queries, and a class ( RaySurfelIntersector ) for repeated queries. One off Ray-Surfel Intersection You can compute one-off ray-surfel interesection queries with ray_surfel_intersection import numpy as np import point_cloud_utils as pcu # Constant surfel radius of 0.33 per point. surfel_rad = np.ones(p.shape[0], dtype=p.dtype) * 0.33 # Generate a raster grid of Rays looking down the +Z axis x, y = np.mgrid[-0.5:0.5:32j, -0.5:0.5:32j] ray_d = np.stack([x.flatten(), y.flatten(), np.ones_like(x.flatten())], axis=-1) ray_d /= np.linalg.norm(ray_d, axis=-1, keepdims=True) # Normalize ray directions -- shape [N, 3] # Rays originating at -Z looking down the Z-axis ray_o = np.array([0.0, 0.0, -75.0]) ray_o = np.repeat(ray_o[None, :], ray_d.shape[0], axis=0) # Repeat the ray origin so there is one per ray -- shape [N, 3] # pid is the id of each intersected point (or -1 for misses) # t is the distance along each ray to the intersected surfel pid, t = pcu.ray_surfel_intersection(p.astype(ray_o.dtype), n.astype(ray_o.dtype), ray_o, ray_d, surfel_rad) One off ray surfel intersection queries using `ray_surfel_intersection`. Repeated Ray-Surfel Intersection with RaySurfelIntersector You can do repeated ray-surfel intersection queries to the same geometry using the RaySurfelIntersector class: import numpy as np import point_cloud_utils as pcu # Load points and normals p, n = pcu.load_mesh_vn(\"wheel.ply\") # Constant surfel radius of 0.33 per point. surfel_rad = np.ones(p.shape[0], dtype=p.dtype) * 0.33 # Generate a raster grid of Rays looking down the +Z axis x, y = np.mgrid[-0.5:0.5:32j, -0.5:0.5:32j] ray_d = np.stack([x.flatten(), y.flatten(), np.ones_like(x.flatten())], axis=-1) ray_d /= np.linalg.norm(ray_d, axis=-1, keepdims=True) # Normalize ray directions -- shape [N, 3] # Rays originating at -Z looking down the Z-axis ray_o = np.array([0.0, 0.0, -75.0]) ray_o = np.repeat(ray_o[None, :], ray_d.shape[0], axis=0) # Repeat the ray origin so there is one per ray -- shape [N, 3] # Generate new rays via a random rotation random_rotation = np.linalg.svd(np.random.randn(3, 3))[0] ray_o2 = np.ascontiguousarray((random_rotation @ ray_o.T).T) ray_d2 = np.ascontiguousarray((random_rotation @ ray_d.T).T) intersector = pcu.RaySurfelIntersetor(p, n, surfel_rad) # pid is the id of each intersected point (or -1 for misses) # t is the distance along each ray to the intersected surfel pid, t = isect.intersect_rays(ray_o, ray_d) # pid2 is the id of each intersected point (or -1 for misses) # t2 is the distance along each ray to the intersected surfel pid2, t2 = isect.intersect_rays(ray_o2, ray_d2) Repeated ray-surfel intersection queries on the same geometry using `RaySurfelIntersector`.","title":"Generating Surfels from Point Clouds"},{"location":"sections/surfels/#generating-surfels-from-point-clouds","text":"A Surfel or SURF ace EL ement is a small, flat piece of geometry centered at a point and facing perpendicularly to that points normal. With dense enough points, surfels can be used as a surface representation. The figure below illustrates a surfel representation for a model. Surfel representation for the wheel model. In the zoom, note how the surface is a collection of tiny circular patches.","title":"Generating Surfels from Point Clouds"},{"location":"sections/surfels/#generating-surfel-geometry-from-an-oriented-point-cloud","text":"Point Cloud Utils lets you easily generate surfel geometry from a point cloud import numpy as np import point_cloud_utils as pcu # Load points and normals p, n = pcu.load_mesh_vn(\"wheel.ply\") # Constant surfel radius of 0.33 per point surfel_rad = np.ones(p.shape[0], dtype=p.dtype) * 0.33 # A triangle mesh representing surfel geometry v, f = pcu.pointcloud_surfel_geometry(p, n, surfel_rad)","title":"Generating Surfel Geometry from an Oriented Point Cloud"},{"location":"sections/surfels/#ray-tracing-surfels","text":"Point Cloud Utils lets you perform fast ray-surfel queries using intel Embree. The API is very similar to the Ray-Mesh Intersection API . There is a functional interface for one-off queries, and a class ( RaySurfelIntersector ) for repeated queries.","title":"Ray Tracing Surfels"},{"location":"sections/surfels/#one-off-ray-surfel-intersection","text":"You can compute one-off ray-surfel interesection queries with ray_surfel_intersection import numpy as np import point_cloud_utils as pcu # Constant surfel radius of 0.33 per point. surfel_rad = np.ones(p.shape[0], dtype=p.dtype) * 0.33 # Generate a raster grid of Rays looking down the +Z axis x, y = np.mgrid[-0.5:0.5:32j, -0.5:0.5:32j] ray_d = np.stack([x.flatten(), y.flatten(), np.ones_like(x.flatten())], axis=-1) ray_d /= np.linalg.norm(ray_d, axis=-1, keepdims=True) # Normalize ray directions -- shape [N, 3] # Rays originating at -Z looking down the Z-axis ray_o = np.array([0.0, 0.0, -75.0]) ray_o = np.repeat(ray_o[None, :], ray_d.shape[0], axis=0) # Repeat the ray origin so there is one per ray -- shape [N, 3] # pid is the id of each intersected point (or -1 for misses) # t is the distance along each ray to the intersected surfel pid, t = pcu.ray_surfel_intersection(p.astype(ray_o.dtype), n.astype(ray_o.dtype), ray_o, ray_d, surfel_rad) One off ray surfel intersection queries using `ray_surfel_intersection`.","title":"One off Ray-Surfel Intersection"},{"location":"sections/surfels/#repeated-ray-surfel-intersection-with-raysurfelintersector","text":"You can do repeated ray-surfel intersection queries to the same geometry using the RaySurfelIntersector class: import numpy as np import point_cloud_utils as pcu # Load points and normals p, n = pcu.load_mesh_vn(\"wheel.ply\") # Constant surfel radius of 0.33 per point. surfel_rad = np.ones(p.shape[0], dtype=p.dtype) * 0.33 # Generate a raster grid of Rays looking down the +Z axis x, y = np.mgrid[-0.5:0.5:32j, -0.5:0.5:32j] ray_d = np.stack([x.flatten(), y.flatten(), np.ones_like(x.flatten())], axis=-1) ray_d /= np.linalg.norm(ray_d, axis=-1, keepdims=True) # Normalize ray directions -- shape [N, 3] # Rays originating at -Z looking down the Z-axis ray_o = np.array([0.0, 0.0, -75.0]) ray_o = np.repeat(ray_o[None, :], ray_d.shape[0], axis=0) # Repeat the ray origin so there is one per ray -- shape [N, 3] # Generate new rays via a random rotation random_rotation = np.linalg.svd(np.random.randn(3, 3))[0] ray_o2 = np.ascontiguousarray((random_rotation @ ray_o.T).T) ray_d2 = np.ascontiguousarray((random_rotation @ ray_d.T).T) intersector = pcu.RaySurfelIntersetor(p, n, surfel_rad) # pid is the id of each intersected point (or -1 for misses) # t is the distance along each ray to the intersected surfel pid, t = isect.intersect_rays(ray_o, ray_d) # pid2 is the id of each intersected point (or -1 for misses) # t2 is the distance along each ray to the intersected surfel pid2, t2 = isect.intersect_rays(ray_o2, ray_d2) Repeated ray-surfel intersection queries on the same geometry using `RaySurfelIntersector`.","title":"Repeated Ray-Surfel Intersection with RaySurfelIntersector"},{"location":"sections/voxelizing_a_triangle_mesh/","text":"Voxelizing a Triangle Mesh Point-Cloud-Utils supports rasterizing triangle meshes to voxels as well as generating cube meshes from those voxels. import numpy as np import point_cloud_utils as pcu vox_size = 1.0 / 256.0 # Size of each voxel vox_origin = [0, 0, 0] # location of the bottom-left-back corner of the [0, 0, 0] voxel v, f = pcu.load_mesh_vf(\"truck.ply\") # Voxelize the input mesh, vox_ijk is an array of integer voxel coordinates vox_ijk = pcu.voxelize_triangle_mesh(v, f, vox_size, vox_origin) # Generate a cube mesh of voxels with a spacing of 0.02 voxels between each cube cube_v, cube_f = pcu.voxel_grid_geometry(vox_ijk, vox_size, vox_origin, gap_fraction=0.02) Left: Input mesh to voxelize. Right: Visualization of voxelized mesh.","title":"Voxelizing a Triangle Mesh"},{"location":"sections/voxelizing_a_triangle_mesh/#voxelizing-a-triangle-mesh","text":"Point-Cloud-Utils supports rasterizing triangle meshes to voxels as well as generating cube meshes from those voxels. import numpy as np import point_cloud_utils as pcu vox_size = 1.0 / 256.0 # Size of each voxel vox_origin = [0, 0, 0] # location of the bottom-left-back corner of the [0, 0, 0] voxel v, f = pcu.load_mesh_vf(\"truck.ply\") # Voxelize the input mesh, vox_ijk is an array of integer voxel coordinates vox_ijk = pcu.voxelize_triangle_mesh(v, f, vox_size, vox_origin) # Generate a cube mesh of voxels with a spacing of 0.02 voxels between each cube cube_v, cube_f = pcu.voxel_grid_geometry(vox_ijk, vox_size, vox_origin, gap_fraction=0.02) Left: Input mesh to voxelize. Right: Visualization of voxelized mesh.","title":"Voxelizing a Triangle Mesh"},{"location":"sections/watertight_manifold/","text":"Making a Mesh a Watertight Manifold Many algorithms in geometry processing require a mesh to be manifold , and watertight . For example, computing signed distances from meshes requires watertight shapes. Point-Cloud-Utils implements the Robust Watertight Manifold Surface Generation Method for ShapeNet Models algorithm by Huang et.al. for converting meshes to watertight manifolds. import point_cloud_utils as pcu v, f = pcu.load_mesh_vf(\"chair.ply\") # The resolution parameter controls the density of the output mesh # It is linearly proportional to the number of faces in the output # mesh. A higher value corresponds to a denser mesh. resolution = 50_000 vw, fw = pcu.make_mesh_watertight(v, f, resolution) The left mesh is non-manifold and non-watertight. The Manifold algorithm converts it to a watertight manifold on the left.","title":"Making a Mesh a Watertight Manifold"},{"location":"sections/watertight_manifold/#making-a-mesh-a-watertight-manifold","text":"Many algorithms in geometry processing require a mesh to be manifold , and watertight . For example, computing signed distances from meshes requires watertight shapes. Point-Cloud-Utils implements the Robust Watertight Manifold Surface Generation Method for ShapeNet Models algorithm by Huang et.al. for converting meshes to watertight manifolds. import point_cloud_utils as pcu v, f = pcu.load_mesh_vf(\"chair.ply\") # The resolution parameter controls the density of the output mesh # It is linearly proportional to the number of faces in the output # mesh. A higher value corresponds to a denser mesh. resolution = 50_000 vw, fw = pcu.make_mesh_watertight(v, f, resolution) The left mesh is non-manifold and non-watertight. The Manifold algorithm converts it to a watertight manifold on the left.","title":"Making a Mesh a Watertight Manifold"},{"location":"sections/watertight_mesh/","text":"","title":"Watertight mesh"}]}