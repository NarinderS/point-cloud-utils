{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Point Cloud Utils is an easy-to-use Python library for processing and manipulating 3D point clouds and meshes. Installation With pip (requires git and a compiler supporting C++14 or later): pip install git+git://github.com/fwilliams/point-cloud-utils With conda : conda install -c conda-forge point_cloud_utils A very simple example Point Cloud Utils uses numpy arrays as fundamental data structure, making it very easy to integrate with existing numerical code. For example, here's how to remove all points in a point cloud which are greater than some distance from a mesh. import point_cloud_utils as pcu # Load a mesh stored in my_mesh.ply: # v is a NumPy array of coordinates with shape (V, 3) # f is a NumPy array of face indices with shape (F, 3) v , f = pcu . load_mesh_vf ( \"my_mesh.ply\" ) # Load a point cloud stored in my_point_cloud.ply: # p is a NumPy array of point coordinates with shape (P, 3) p = pcu . load_mesh_v ( \"my_point_cloud.ply\" ) # Compute the shortest distance between each point in p and the mesh: # dists is a NumPy array of shape (P,) where dists[i] is the # shortest distnace between the point p[i, :] and the mesh (v, f) dists , _ , _ = pcu . closest_points_on_mesh ( p , v , f ) # Delete all points which are farther than some distance away from the mesh dist_thresh = 0.1 keep_points = p [ dists < dist_thresh ] # Save the filtered point cloud to my_point_cloud_trimmed.ply pcu . save_mesh_v ( \"my_point_cloud_trimmed.ply\" , keep_points ) Core Features Point Cloud Utils includes utilities to perform the following tasks: Reading and writing meshes and point clouds from disk . Point Cloud Utils can handle any file that can be opened in MeshLab. Resampling point clouds to have different distributions. Generating point samples on a mesh . Computing metrics between point clouds and meshes (e.g. Chamfer Distance, Hausdorff Distance, etc...). Computing signed distances to triangle meshes . Estimating normals for point clouds and meshes . Fast ray/mesh intersection . Surface mesh smoothing .","title":"Home"},{"location":"#installation","text":"With pip (requires git and a compiler supporting C++14 or later): pip install git+git://github.com/fwilliams/point-cloud-utils With conda : conda install -c conda-forge point_cloud_utils","title":"Installation"},{"location":"#a-very-simple-example","text":"Point Cloud Utils uses numpy arrays as fundamental data structure, making it very easy to integrate with existing numerical code. For example, here's how to remove all points in a point cloud which are greater than some distance from a mesh. import point_cloud_utils as pcu # Load a mesh stored in my_mesh.ply: # v is a NumPy array of coordinates with shape (V, 3) # f is a NumPy array of face indices with shape (F, 3) v , f = pcu . load_mesh_vf ( \"my_mesh.ply\" ) # Load a point cloud stored in my_point_cloud.ply: # p is a NumPy array of point coordinates with shape (P, 3) p = pcu . load_mesh_v ( \"my_point_cloud.ply\" ) # Compute the shortest distance between each point in p and the mesh: # dists is a NumPy array of shape (P,) where dists[i] is the # shortest distnace between the point p[i, :] and the mesh (v, f) dists , _ , _ = pcu . closest_points_on_mesh ( p , v , f ) # Delete all points which are farther than some distance away from the mesh dist_thresh = 0.1 keep_points = p [ dists < dist_thresh ] # Save the filtered point cloud to my_point_cloud_trimmed.ply pcu . save_mesh_v ( \"my_point_cloud_trimmed.ply\" , keep_points )","title":"A very simple example"},{"location":"#core-features","text":"Point Cloud Utils includes utilities to perform the following tasks: Reading and writing meshes and point clouds from disk . Point Cloud Utils can handle any file that can be opened in MeshLab. Resampling point clouds to have different distributions. Generating point samples on a mesh . Computing metrics between point clouds and meshes (e.g. Chamfer Distance, Hausdorff Distance, etc...). Computing signed distances to triangle meshes . Estimating normals for point clouds and meshes . Fast ray/mesh intersection . Surface mesh smoothing .","title":"Core Features"},{"location":"about/","text":"","title":"About"},{"location":"sections/mesh_io/","text":"Mesh I/O Point Cloud Utils supports reading and writing many common 3D formats (PLY, STL, OFF, OBJ, 3DS, VRML 2.0, X3D, COLLADA). If your file can be imported into MeshLab, we can read it! In all the functions in this section, the type of file is inferred from its file extension. 3D Data Representation in Point Cloud Utils Point Cloud Utils uses NumPy arrays as a fundamental data structure for storing 3D data. A triangle mesh with #v vertices and #f faces is stored using a pair of NumPy arrays v, f with shape (#v, 3) and (#f, 3) respectively. Each row of v stores a vertex coordinate and each row of f stores three integer indexes into v denoting the three vertices forming that face. Per-vertex attributes are stored as separate NumPy arrays with #v rows (one row per vertex). Point clouds can simply be viewed as a special case of triangle meshes with no faces. Thus we encode a point cloud with #p points as a NumPy array p with shape (#p, 3) (one point per row). For example, consider the mesh with 6 vertices and 5 faces illustrated below. We would store this as two numpy arrays v, f with v.shape = (6, 3) and f.shape = (5, 3) . The i th row of v is a 3D vector encoding the position of the vertex v i , and j th row of f holds three indices to each of the vertices of the j th face. In the figure, the second face is formed by the vertices v 1 , v 2 , v 5 , so the second row of f are the integers (1, 2, 5) . Vertex and Face Attributes In addition to vertices and face data, we often want to store attributes alongside the mesh. Attributes can either be stored per-face or per-vertex. Examples of attributes include per-vertex normals, per-face colors, or per-vertex texture coordinates. Suppose we have a triangle mesh stored as NumPy arrays v, f with shapes (#v, 3) and (#f, 3) . A set of d -dimensionsl per-vertex attributes is stored as a NumPy array with shape (#v, d) such that the i th row of the attribute array corresponds to the i th vertex. Similarly, a d -dimensional set of per-face attributes is stored as a NumPy array with shape (#f, d) such that the j th row of the attribute array corresponds to the j th face. For example, consider the mesh described above with 6 vertices and 5 faces. We could store per-face colors as a NumPy array with shape (5, 3) each row is the color of the correponding face (first image below). We could store per-vertex normals as a NumPy array of shape (6, 3) where each row contains the normal at the corresponding vertex (second image below) Per-face attributes are stored in an array with the same number of rows as the face array Per-vertex attributes are stored in an array with the same number of rows as the vertex array Shorthand functions for loading and saving 3D data Many times, we only need to load a few attributes from a mesh or point cloud. For example, we may only want the vertices, faces, and vertex colors for mesh. Point Cloud Utils provides a number of shorthand helper functions which can load these attributes directly into NumPy arrays. These functions have the form load_mesh_* and save_mesh_* where * indicates which data to load. If some attribute is not present in the file being loaded, these functions will simply return an empty array. Load/Save only points import point_cloud_utils as pcu # v is a NumPy array of shape (#v, 3) of points v = pcu . load_mesh_v ( \"path/to/mesh\" ) pcu . save_mesh_v ( \"path/to/mash\" , v ) Load/Save mesh vertices and faces import point_cloud_utils as pcu # v is a NumPy array of shape (#v, 3) of points # f is a NumPy array of shape (#f, 3) of face indices v , f = pcu . load_mesh_vf ( \"path/to/mesh\" ) pcu . save_mesh_vf ( \"path/to/mash\" , v , f ) Load/Save points and per-point normals import point_cloud_utils as pcu # v is a NumPy array of shape (#v, 3) of points # n is a NumPy array of shape (#v, 3) of per-vertex normals v , n = pcu . load_mesh_vn ( \"path/to/mesh\" ) pcu . save_mesh_vn ( \"path/to/mash\" , v , n ) Load/Save mesh vertices, faces, and vertex colors import point_cloud_utils as pcu # v is a NumPy array of shape (#v, 3) of points # f is a NumPy array of shape (#f, 3) of face indices # c is a NumPy array of shape (#v, 4) of RBGA per-vertex colors v , f , c = pcu . load_mesh_vfc ( \"path/to/mesh\" ) pcu . save_mesh_vfc ( \"path/to/mash\" , v , f , c ) Load/Save mesh vertices, faces, and vertex normals import point_cloud_utils as pcu # v is a NumPy array of shape (#v, 3) of points # f is a NumPy array of shape (#f, 3) of face indices # n is a NumPy array of shape (#v, 3) of per-vertex normals v , f , n = pcu . load_mesh_vfn ( \"path/to/mesh\" ) pcu . save_mesh_vfn ( \"path/to/mash\" , v , f , n ) Load/Save mesh vertices, faces, vertex normals, and vertex colors import point_cloud_utils as pcu # v is a NumPy array of shape (#v, 3) of points # f is a NumPy array of shape (#f, 3) of face indices # n is a NumPy array of shape (#v, 3) of per-vertex normals # c is a NumPy array of shape (#v, 4) of RBGA per-vertex colors v , f , n , c = pcu . load_mesh_vfn ( \"path/to/mesh\" ) pcu . save_mesh_vfnc ( \"path/to/mash\" , v , f , n , c ) Loading 3D data with all attributes Some meshes or point clouds may have more complex attribute structures, or we may not know which attributes are stored in the mesh file before loading it. In this case, Point Cloud Utils provides utilities to load a mesh into a TriangleMesh class. TriangleMesh is a lightweight container containing numpy arrays for vertices, faces, textures, and other attributes. To load a mesh into a TriangleMesh class simply construct it with the path to the mesh: import point_cloud_utils as pcu mesh = pcu . TriangleMesh ( \"path/to/mesh\" ) To save a TriangleMesh object, simply call the save method with the desired path: mesh . save ( \"path/to/mesh\" ) The TriangleMesh class contains attributes encoding vertex and face data as well as texture information. It is structured as follows: TriangleMesh : vertex_data : positions : (#v, 3)-shaped NumPy array of per-vertex positions normals : (#v, 3)-shaped NumPy array of per-vertex normals (or None ) texcoords : (#v, 2)-shaped NumPy array of per-vertex uv coordinates (or None ) tex_ids : (#v,)-shaped NumPy array of integer indices into TriangleMesh.textures indicating which texture to use at this vertex (or None ) colors : (#v, 4)-shaped NumPy array of per-vertex RBGA colors in [0.0, 1.0] (or None ) radius : (#v,)-shaped NumPy array of per-vertex curvature radii (or None ) quality : (#v,)-shaped NumPy array of per-vertex quality measures (or None ) flags : (#v,)-shaped NumPy array of 32-bit integer flags per vertex (or None ) face_data : vertex_ids : (#f, 3)-shaped NumPy array of integer face indices into TrianglMesh.vertex_data.positions normals : (#f, 3)-shaped NumPy array of per-face normals (or None ) colors : (#f, 4)-shaped NumPy array of per-face RBGA colors in [0.0, 1.0] (or None ) quality : (#f,)-shaped NumPy array of per-face quality measures (or None ) flags : (#f,(-shaped NumPy array of 32-bit integer flags per face (or None ) wedge_colors : (#f, 3, 4)-shaped NumPy array of per-wedge RBGA colors in [0.0, 1.0] (or None ) wedge_normals : (#f, 3, 3)-shaped NumPy array of per-wedge normals (or None ) wedge_texcoords : (#f, 3, 2)-shaped NumPy array of per-wedge] uv coordinates (or None ) wedge_tex_ids : (#f, 3)-shaped NumPy array of integer indices into TriangleMesh.textures indicating which texture to use at this wedge (or None ) textures : A list of paths to texture image files for this mesh normal_maps : A list of paths to texture image files for this mesh The hierarchy of the list above denotes composition. For example, to access the vertex colors of a TriangleMesh , you would read the TriangleMesh.vertex_data.colors property. Remark on wedge face attributes The face_data member of the TriangleMesh class contains a number of wedge attributes. These all start with wedge_ . In this context a wedge is a corner of a triangle face. Each face contains three wedges corresponding to each corner. Wedge attributes have shape (#f, 3, d) where d is the dimension of the attribute. Wedges attributes are useful for storing which are discontinous across face boundaries.","title":"Mesh I/O"},{"location":"sections/mesh_io/#mesh-io","text":"Point Cloud Utils supports reading and writing many common 3D formats (PLY, STL, OFF, OBJ, 3DS, VRML 2.0, X3D, COLLADA). If your file can be imported into MeshLab, we can read it! In all the functions in this section, the type of file is inferred from its file extension.","title":"Mesh I/O"},{"location":"sections/mesh_io/#3d-data-representation-in-point-cloud-utils","text":"Point Cloud Utils uses NumPy arrays as a fundamental data structure for storing 3D data. A triangle mesh with #v vertices and #f faces is stored using a pair of NumPy arrays v, f with shape (#v, 3) and (#f, 3) respectively. Each row of v stores a vertex coordinate and each row of f stores three integer indexes into v denoting the three vertices forming that face. Per-vertex attributes are stored as separate NumPy arrays with #v rows (one row per vertex). Point clouds can simply be viewed as a special case of triangle meshes with no faces. Thus we encode a point cloud with #p points as a NumPy array p with shape (#p, 3) (one point per row). For example, consider the mesh with 6 vertices and 5 faces illustrated below. We would store this as two numpy arrays v, f with v.shape = (6, 3) and f.shape = (5, 3) . The i th row of v is a 3D vector encoding the position of the vertex v i , and j th row of f holds three indices to each of the vertices of the j th face. In the figure, the second face is formed by the vertices v 1 , v 2 , v 5 , so the second row of f are the integers (1, 2, 5) .","title":"3D Data Representation in Point Cloud Utils"},{"location":"sections/mesh_io/#vertex-and-face-attributes","text":"In addition to vertices and face data, we often want to store attributes alongside the mesh. Attributes can either be stored per-face or per-vertex. Examples of attributes include per-vertex normals, per-face colors, or per-vertex texture coordinates. Suppose we have a triangle mesh stored as NumPy arrays v, f with shapes (#v, 3) and (#f, 3) . A set of d -dimensionsl per-vertex attributes is stored as a NumPy array with shape (#v, d) such that the i th row of the attribute array corresponds to the i th vertex. Similarly, a d -dimensional set of per-face attributes is stored as a NumPy array with shape (#f, d) such that the j th row of the attribute array corresponds to the j th face. For example, consider the mesh described above with 6 vertices and 5 faces. We could store per-face colors as a NumPy array with shape (5, 3) each row is the color of the correponding face (first image below). We could store per-vertex normals as a NumPy array of shape (6, 3) where each row contains the normal at the corresponding vertex (second image below) Per-face attributes are stored in an array with the same number of rows as the face array Per-vertex attributes are stored in an array with the same number of rows as the vertex array","title":"Vertex and Face Attributes"},{"location":"sections/mesh_io/#shorthand-functions-for-loading-and-saving-3d-data","text":"Many times, we only need to load a few attributes from a mesh or point cloud. For example, we may only want the vertices, faces, and vertex colors for mesh. Point Cloud Utils provides a number of shorthand helper functions which can load these attributes directly into NumPy arrays. These functions have the form load_mesh_* and save_mesh_* where * indicates which data to load. If some attribute is not present in the file being loaded, these functions will simply return an empty array.","title":"Shorthand functions for loading and saving 3D data"},{"location":"sections/mesh_io/#loadsave-only-points","text":"import point_cloud_utils as pcu # v is a NumPy array of shape (#v, 3) of points v = pcu . load_mesh_v ( \"path/to/mesh\" ) pcu . save_mesh_v ( \"path/to/mash\" , v )","title":"Load/Save only points"},{"location":"sections/mesh_io/#loadsave-mesh-vertices-and-faces","text":"import point_cloud_utils as pcu # v is a NumPy array of shape (#v, 3) of points # f is a NumPy array of shape (#f, 3) of face indices v , f = pcu . load_mesh_vf ( \"path/to/mesh\" ) pcu . save_mesh_vf ( \"path/to/mash\" , v , f )","title":"Load/Save mesh vertices and faces"},{"location":"sections/mesh_io/#loadsave-points-and-per-point-normals","text":"import point_cloud_utils as pcu # v is a NumPy array of shape (#v, 3) of points # n is a NumPy array of shape (#v, 3) of per-vertex normals v , n = pcu . load_mesh_vn ( \"path/to/mesh\" ) pcu . save_mesh_vn ( \"path/to/mash\" , v , n )","title":"Load/Save points and per-point normals"},{"location":"sections/mesh_io/#loadsave-mesh-vertices-faces-and-vertex-colors","text":"import point_cloud_utils as pcu # v is a NumPy array of shape (#v, 3) of points # f is a NumPy array of shape (#f, 3) of face indices # c is a NumPy array of shape (#v, 4) of RBGA per-vertex colors v , f , c = pcu . load_mesh_vfc ( \"path/to/mesh\" ) pcu . save_mesh_vfc ( \"path/to/mash\" , v , f , c )","title":"Load/Save mesh vertices, faces, and vertex colors"},{"location":"sections/mesh_io/#loadsave-mesh-vertices-faces-and-vertex-normals","text":"import point_cloud_utils as pcu # v is a NumPy array of shape (#v, 3) of points # f is a NumPy array of shape (#f, 3) of face indices # n is a NumPy array of shape (#v, 3) of per-vertex normals v , f , n = pcu . load_mesh_vfn ( \"path/to/mesh\" ) pcu . save_mesh_vfn ( \"path/to/mash\" , v , f , n )","title":"Load/Save mesh vertices, faces, and vertex normals"},{"location":"sections/mesh_io/#loadsave-mesh-vertices-faces-vertex-normals-and-vertex-colors","text":"import point_cloud_utils as pcu # v is a NumPy array of shape (#v, 3) of points # f is a NumPy array of shape (#f, 3) of face indices # n is a NumPy array of shape (#v, 3) of per-vertex normals # c is a NumPy array of shape (#v, 4) of RBGA per-vertex colors v , f , n , c = pcu . load_mesh_vfn ( \"path/to/mesh\" ) pcu . save_mesh_vfnc ( \"path/to/mash\" , v , f , n , c )","title":"Load/Save mesh vertices, faces, vertex normals, and vertex colors"},{"location":"sections/mesh_io/#loading-3d-data-with-all-attributes","text":"Some meshes or point clouds may have more complex attribute structures, or we may not know which attributes are stored in the mesh file before loading it. In this case, Point Cloud Utils provides utilities to load a mesh into a TriangleMesh class. TriangleMesh is a lightweight container containing numpy arrays for vertices, faces, textures, and other attributes. To load a mesh into a TriangleMesh class simply construct it with the path to the mesh: import point_cloud_utils as pcu mesh = pcu . TriangleMesh ( \"path/to/mesh\" ) To save a TriangleMesh object, simply call the save method with the desired path: mesh . save ( \"path/to/mesh\" ) The TriangleMesh class contains attributes encoding vertex and face data as well as texture information. It is structured as follows: TriangleMesh : vertex_data : positions : (#v, 3)-shaped NumPy array of per-vertex positions normals : (#v, 3)-shaped NumPy array of per-vertex normals (or None ) texcoords : (#v, 2)-shaped NumPy array of per-vertex uv coordinates (or None ) tex_ids : (#v,)-shaped NumPy array of integer indices into TriangleMesh.textures indicating which texture to use at this vertex (or None ) colors : (#v, 4)-shaped NumPy array of per-vertex RBGA colors in [0.0, 1.0] (or None ) radius : (#v,)-shaped NumPy array of per-vertex curvature radii (or None ) quality : (#v,)-shaped NumPy array of per-vertex quality measures (or None ) flags : (#v,)-shaped NumPy array of 32-bit integer flags per vertex (or None ) face_data : vertex_ids : (#f, 3)-shaped NumPy array of integer face indices into TrianglMesh.vertex_data.positions normals : (#f, 3)-shaped NumPy array of per-face normals (or None ) colors : (#f, 4)-shaped NumPy array of per-face RBGA colors in [0.0, 1.0] (or None ) quality : (#f,)-shaped NumPy array of per-face quality measures (or None ) flags : (#f,(-shaped NumPy array of 32-bit integer flags per face (or None ) wedge_colors : (#f, 3, 4)-shaped NumPy array of per-wedge RBGA colors in [0.0, 1.0] (or None ) wedge_normals : (#f, 3, 3)-shaped NumPy array of per-wedge normals (or None ) wedge_texcoords : (#f, 3, 2)-shaped NumPy array of per-wedge] uv coordinates (or None ) wedge_tex_ids : (#f, 3)-shaped NumPy array of integer indices into TriangleMesh.textures indicating which texture to use at this wedge (or None ) textures : A list of paths to texture image files for this mesh normal_maps : A list of paths to texture image files for this mesh The hierarchy of the list above denotes composition. For example, to access the vertex colors of a TriangleMesh , you would read the TriangleMesh.vertex_data.colors property. Remark on wedge face attributes The face_data member of the TriangleMesh class contains a number of wedge attributes. These all start with wedge_ . In this context a wedge is a corner of a triangle face. Each face contains three wedges corresponding to each corner. Wedge attributes have shape (#f, 3, d) where d is the dimension of the attribute. Wedges attributes are useful for storing which are discontinous across face boundaries.","title":"Loading 3D data with all attributes"},{"location":"sections/mesh_sampling/","text":"","title":"Mesh Sampling"},{"location":"sections/mesh_sdf/","text":"Computing Signed Distances to Triangle Meshes Many applications require a signed distance function (SDF) representation for a 3D shape . For example, many shape reconstruction neural networks such as (DeepSDF)[https://arxiv.org/abs/1901.05103] require such a representation for training. Unfortunately, most 3D shape data is stored as a triangle mesh, making SDFs not readily available. Point-Cloud-Utils makes it very easy to extract signed distances from a triangle mesh. Remark about mesh quality To extract an SDF for a triangle mesh, the mesh must be of relatively good quality (manifold, watertight, no sliver triangles, etc...). To clean up a mesh for SDF extraction see Making a triangle mesh watertight . SDF Overview A signed distance function $f : \\mathbb{R}^3 \\rightarrow \\mathbb{R}$ maps 3D points $x \\in \\mathbb{R}^3$ to the nearest distance between $x$ and some surface $S$. In other words: $$ f(x) = \\min_{x' \\in S} |x - x'|_2 $$ The zero level set of the SDF $f$ are precisely the set of points which lie on the surface. i.e. $$ S = {x : f(x) = 0} $$ The image below shows a plot of the SDF for the boundary of the letters PCU. Level sets of the signed distance function for the letters PCU. The zero level set (surface) is colored as a green line. Computing an SDF from a triangle mesh We can compute the signed distance of a set of points in Point-Cloud-Utils in the following way: import numpy as np import point_cloud_utils as pcu # 1000 random query points to compute the SDF at query_pts = np . random . rand ( 1000 , 3 ) v , f = pcu . load_mesh_vf ( \"bunny.ply\" ) # sdf is the signed distance for each query point # fid is the nearest face to each query point on the mesh # bc are the barycentric coordinates of the nearest point to each query point within the face sdf , fid , bc = pcu . signed_distance_to_mesh ( query_pts , v , f )","title":"Mesh Signed Distances"},{"location":"sections/mesh_sdf/#computing-signed-distances-to-triangle-meshes","text":"Many applications require a signed distance function (SDF) representation for a 3D shape . For example, many shape reconstruction neural networks such as (DeepSDF)[https://arxiv.org/abs/1901.05103] require such a representation for training. Unfortunately, most 3D shape data is stored as a triangle mesh, making SDFs not readily available. Point-Cloud-Utils makes it very easy to extract signed distances from a triangle mesh. Remark about mesh quality To extract an SDF for a triangle mesh, the mesh must be of relatively good quality (manifold, watertight, no sliver triangles, etc...). To clean up a mesh for SDF extraction see Making a triangle mesh watertight .","title":"Computing Signed Distances to Triangle Meshes"},{"location":"sections/mesh_sdf/#sdf-overview","text":"A signed distance function $f : \\mathbb{R}^3 \\rightarrow \\mathbb{R}$ maps 3D points $x \\in \\mathbb{R}^3$ to the nearest distance between $x$ and some surface $S$. In other words: $$ f(x) = \\min_{x' \\in S} |x - x'|_2 $$ The zero level set of the SDF $f$ are precisely the set of points which lie on the surface. i.e. $$ S = {x : f(x) = 0} $$ The image below shows a plot of the SDF for the boundary of the letters PCU. Level sets of the signed distance function for the letters PCU. The zero level set (surface) is colored as a green line.","title":"SDF Overview"},{"location":"sections/mesh_sdf/#computing-an-sdf-from-a-triangle-mesh","text":"We can compute the signed distance of a set of points in Point-Cloud-Utils in the following way: import numpy as np import point_cloud_utils as pcu # 1000 random query points to compute the SDF at query_pts = np . random . rand ( 1000 , 3 ) v , f = pcu . load_mesh_vf ( \"bunny.ply\" ) # sdf is the signed distance for each query point # fid is the nearest face to each query point on the mesh # bc are the barycentric coordinates of the nearest point to each query point within the face sdf , fid , bc = pcu . signed_distance_to_mesh ( query_pts , v , f )","title":"Computing an SDF from a triangle mesh"},{"location":"sections/mesh_smoothing/","text":"","title":"Mesh Smoothing"},{"location":"sections/normal_estimation/","text":"","title":"Normal Estimation"},{"location":"sections/point_cloud_resampling/","text":"Point Cloud Re-Sampling Point Cloud Utils provides utilities for re-sampling a point cloud in several ways. Binning points in a voxel grid In many 3D tasks, it is often advantageous to quantize a point cloud to a regular voxel grid in space. Such quantization can reduce the number of input points to an algorithm to match the resolution at which that algorithm operates. Point Cloud Utils provides a simple function for quantizing a point cloud with attributes into a voxel grid. import point_cloud_utils as pcu pcu . downsample_point_cloud_voxel_grid Downsampling a point cloud to have a blue noise distribution Often times, we want to resample a dense point cloud to have approximately even spacing between points. This can be achieved with Poisson Disk Sampling. Point Cloud utils provides a r Deduplicating a point cloud import point_cloud_utils as pcu pcu . deduplicate_point_cloud pcu . downsample_point_cloud_voxel_grid pcu . downsample_point_cloud_poisson_disk","title":"Point Cloud Resampling"},{"location":"sections/point_cloud_resampling/#point-cloud-re-sampling","text":"Point Cloud Utils provides utilities for re-sampling a point cloud in several ways.","title":"Point Cloud Re-Sampling"},{"location":"sections/point_cloud_resampling/#binning-points-in-a-voxel-grid","text":"In many 3D tasks, it is often advantageous to quantize a point cloud to a regular voxel grid in space. Such quantization can reduce the number of input points to an algorithm to match the resolution at which that algorithm operates. Point Cloud Utils provides a simple function for quantizing a point cloud with attributes into a voxel grid. import point_cloud_utils as pcu pcu . downsample_point_cloud_voxel_grid","title":"Binning points in a voxel grid"},{"location":"sections/point_cloud_resampling/#downsampling-a-point-cloud-to-have-a-blue-noise-distribution","text":"Often times, we want to resample a dense point cloud to have approximately even spacing between points. This can be achieved with Poisson Disk Sampling. Point Cloud utils provides a r","title":"Downsampling a point cloud to have a blue noise distribution"},{"location":"sections/point_cloud_resampling/#deduplicating-a-point-cloud","text":"import point_cloud_utils as pcu pcu . deduplicate_point_cloud pcu . downsample_point_cloud_voxel_grid pcu . downsample_point_cloud_poisson_disk","title":"Deduplicating a point cloud"},{"location":"sections/ray_mesh_intersection/","text":"","title":"Ray/Mesh Intersection"},{"location":"sections/shape_metrics/","text":"","title":"Shape Metrics"},{"location":"sections/watertight_mesh/","text":"","title":"Watertight mesh"}]}